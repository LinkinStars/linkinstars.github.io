<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>k8s 意外集锦 - configmap 挂载 目录 只读</title>
    <url>/post/c86fbf9f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> OCI runtime create failed:</p>
<p> /var/lib/docker/overlay2/6573e40fef5bc51b4e565ad9554f225806f05a9f9089cc9e210c0e35a80e6e1f/merged/etc/resolv.conf: read-only</p>
<span id="more"></span>
<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused</span><br><span class="line"><span class="string">&quot;process_linux.go:424: container init caused \&quot;rootfs_linux.go:58: mounting</span></span><br><span class="line"><span class="string">\\\&quot;/var/lib/docker/containers/1ec387b2e168281ed480c5050b08893976ac84a2751691e1a9429ae6a66a788a/resolv.conf\\\&quot; to rootfs</span></span><br><span class="line"><span class="string">\\\&quot;/var/lib/docker/overlay2/6573e40fef5bc51b4e565ad9554f225806f05a9f9089cc9e210c0e35a80e6e1f/merged\\\&quot; at</span></span><br><span class="line"><span class="string">\\\&quot;/var/lib/docker/overlay2/6573e40fef5bc51b4e565ad9554f225806f05a9f9089cc9e210c0e35a80e6e1f/merged/etc/resolv.conf\\\&quot;</span></span><br><span class="line"><span class="string">caused \\\&quot;open</span></span><br><span class="line"><span class="string">/var/lib/docker/overlay2/6573e40fef5bc51b4e565ad9554f225806f05a9f9089cc9e210c0e35a80e6e1f/merged/etc/resolv.conf: read-only</span></span><br><span class="line"><span class="string">file system\\\&quot;\&quot;&quot;</span>: unknown</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>主要是这个报错信息很奇怪，一开始没有往挂载目录上的问题去想，没想到会是这个方向的上的错误</p>
<p><a href="https://github.com/kubernetes/kubernetes/issues/63477">https://github.com/kubernetes/kubernetes/issues/63477</a></p>
<p>使用 configmap 挂载目录的时候挂载到了 <code>/etc</code> 目录下面，而这个目录是 read-only 的，所以报错了。重新选择挂载目录或者挂载单个文件就可以了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/etc/conf.yaml</span></span><br><span class="line">    <span class="attr">subPath:</span> <span class="string">conf.yaml</span></span><br></pre></td></tr></table></figure>
<p>其实建议还是最好不要挂 etc 目录，后面可能也会有问题的</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s-accident</tag>
      </tags>
  </entry>
  <entry>
    <title>细说kubernetes - 初识deployment</title>
    <url>/post/8084f9ee.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当我们认识的k8s的时候，我们第一个认识的是pod，那么我觉得第二个认识的应该就是Deployment了。作为k8s中一个非常常见的对象，今天我们来看看它的实现原理和设计思想。</p>
<span id="more"></span>
<p>PS: 本文需要你对pod的定义和理解有一定的基础</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在k8s中，对象常常都是以一个yaml格式的文件来定义的，deployment也不例外。如果你对k8s还不是特别了解，你大可以将一个文件看做是一个对象的所有属性，每个属性都有对应的值，其实也并不复杂。deployment的定义如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义版本</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="comment"># 定义类型</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="comment"># 定义名称和标签</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="comment"># 定义规格</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="comment"># 定义模板</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>我也不知道网上为什么都用nginx来写这个例子，总之我拿来加上了一些注释，你就可以很清楚的看到它到底在定义些什么东西了。（其实整个deployment也并不复杂）</p>
<p>除了名字和标签类型是对于deployment的定义外，下面的规格就是deployment长得样子。而这里的模板是一个pod的模板，定义了pod的样子。</p>
<blockquote>
<p>要点1：从定义上我们可以明显的看出 deployment 并不是直接控制的 pod ，其中在规格中的定义是 replicas ，所以控制其实是 ReplicaSet，由 ReplicaSet 去控制 pod</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>通过 <code>kubectl create -f deploy-nginx.yml</code> 命令可以创建这个 Deployment</li>
<li>通过 <code>kubectl get rs</code> 命令查看 ReplicaSet 的情况</li>
<li>通过 <code>kubectl get pods</code> 命令查看 Pod 的情况</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment-54f57cf6bf   2         2         2       75s</span><br><span class="line"></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-54f57cf6bf-mjqw9   1/1     Running   0          4s</span><br><span class="line">nginx-deployment-54f57cf6bf-pvtkq   1/1     Running   0          4s</span><br></pre></td></tr></table></figure>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>看完了定义和使用，我们再来看看它有什么特点</p>
<h3 id="删除pod"><a href="#删除pod" class="headerlink" title="删除pod"></a>删除pod</h3><p>我们可以通过 <code>kubectl delete pod nginx-deployment-54f57cf6bf-mjqw9</code> 命令删除一个 pod</p>
<p>然后我们再去查看当前 pod 的情况<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-54f57cf6bf-4scrb   1/1     Running   0         43s</span><br><span class="line">nginx-deployment-54f57cf6bf-pvtkq   1/1     Running   0         5m</span><br></pre></td></tr></table></figure><br>我们会惊奇的发现，它又重新创建了一个pod</p>
<blockquote>
<p>要点2：Deployment 会维护pod的数量，一旦不满足数量的定义需求，就会进行创建</p>
</blockquote>
<h3 id="删除rs"><a href="#删除rs" class="headerlink" title="删除rs"></a>删除rs</h3><p>我们可以通过 <code>kubectl delete rs nginx-deployment-54f57cf6bf</code> 命令删除一个 rs</p>
<p>然后我们去看 rs 和 pod，你就会发现它又重新帮你创建了</p>
<blockquote>
<p>要点3：Deployment 会维护 ReplicaSet</p>
</blockquote>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>说完了删除，那我们想要扩容怎么办呢？我现在要把pod变成3个</p>
<ul>
<li>方式1 修改yml文件，将2改为3；然后使用 <code>kubectl apply -f deploy-nginx.yml</code>   </li>
<li>方式2 直接使用命令 <code>kubectl scale deploy nginx-deployment --replicas=3</code>  </li>
<li>方式3 直接使用命令 <code>kubectl edit deploy nginx-deployment</code> 修改 replicas: 3  </li>
</ul>
<blockquote>
<p>要点4：这些方式都可以完成扩容缩容的效果，同时还可以修改别的属性，如nginx版本等</p>
</blockquote>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>说完了定义和特点，来说说deployment的设计</p>
<h3 id="控制器模式"><a href="#控制器模式" class="headerlink" title="控制器模式"></a>控制器模式</h3><p>这个设计模式其实在k8s中很常见，由A控制B，由B控制C，k8s没有让我们直接去控制pod，而是通过 deployment 去控制，而 deployment 其实也不是实际干活的，其实实际干活的是 ReplicaSet，有这样的控制链路组成的控制器模式。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">  Deployment--&gt;ReplicaSet;</span><br><span class="line">  ReplicaSet--&gt;Pod1;</span><br><span class="line">  ReplicaSet--&gt;Pod2;</span><br></pre></td></tr></table></figure><br>这样一层层的控制能让我们更清晰的去控制我们的最终要的结果，同时让最终结果的控制变得简单。</p>
<h3 id="滚动更新模式"><a href="#滚动更新模式" class="headerlink" title="滚动更新模式"></a>滚动更新模式</h3><p>在使用中我们觉得非常好用的原因是，我们只要修改参数，就能获得水平扩容缩容的效果，非常简单，而这对于需要水平扩展的服务来说这无疑是非常重要的。</p>
<p>如果在以前，你需要水平扩展你的应用，你就需要复制一个你应用，或者说复制一个tomcat，然后修改各种配置避免冲突，如果服务挂了你需要手动去重新启动….</p>
<p>而k8s设计在于，<strong>你只需要描述目标状态是什么，就能帮你维护目标状态的样子</strong>，不对了我会自动帮你进行调整。你的任何更新都会及时被反映到状态中去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    实际状态 := 获取集群中对象 X 的实际状态(Actual State) </span><br><span class="line">    期望状态 := 获取集群中对象 X 的期望状态(Desired State) </span><br><span class="line">    <span class="keyword">if</span> 实际状态 == 期望状态&#123;</span><br><span class="line">        什么都不做</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        执行编排动作，将实际状态调整为期望状态</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://draveness.me/kubernetes-deployment">https://draveness.me/kubernetes-deployment</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>细说kubernetes - 为什么是pod</title>
    <url>/post/c5d761a.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>k8s作为现在最火的容器编排调度平台，好用我也就不必多说了。当我们初识k8s的时候一个新的概念就到了我们眼前，那就是pod。我们在使用了之后也就渐渐的接受了pod这个东西，但是你有没有想过，为什么是pod？k8s为什么会有这样的设计？今天我们就来细细说说这个pod</p>
<span id="more"></span>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>首先我们来回忆看看k8s的架构图是什么样子的<br><img src="http://blog.linkinstars.com/mweb/15788094532502.jpg" alt><br>这个是来源于 <a href="https://www.kubernetes.org.cn/">https://www.kubernetes.org.cn/</a> 中文官网的一个架构图<br><img src="http://blog.linkinstars.com/mweb/15788095000406.jpg" alt></p>
<p>从架构图中我们可以看到，整个k8s的设计架构有以下几个要点：</p>
<ul>
<li>master、node架构；master就是大脑充当着管理者的角色</li>
<li>master中提供了api-server、controller-manager、scheduler、etcd用于管理node并向外提供服务</li>
<li>node就是实际干活的，提供了kubelet、proxy用于向master汇报情况，并管理pod的网络</li>
<li><strong>而pod是k8s中最小的调度单位</strong>，Pod就是最小的，管理，创建，计划的最小单元.</li>
</ul>
<p>当然其他组件都非常重要，这个我们以后再说，我们今天就来看看主角“pod”</p>
<h2 id="为什么是pod？"><a href="#为什么是pod？" class="headerlink" title="为什么是pod？"></a>为什么是pod？</h2><p>一开始用的时候我就好奇为什么k8s要弄出一个pod，因为我们一开始使用的是docker，操作的是docker容器，构建的也是docker镜像，为什么不直接调度docker容器就好了，这样粒度不是更加细致，调度也会更加方便吗？<br>我们在使用k8s之前也使用过docker-compose，从另一个角度说，这也是一种容器的管理，看起来也挺好的。<br>下面我们就来说说pod</p>
<h3 id="pod扮演的是什么角色"><a href="#pod扮演的是什么角色" class="headerlink" title="pod扮演的是什么角色"></a>pod扮演的是什么角色</h3><ol>
<li>从一开始我们的服务往往是运行在服务器上的，一个应用就占用了一个服务器，但是一个大的服务器上往往不会只有一个应用。</li>
<li>后来技术的发展出现了虚拟化，将一个大的服务器，虚拟化成几个小的服务器，来使用，从</li>
<li>节省资源也做到了服务与服务之间的隔离，从而避免一个服务的问题导致整个服务器宕机。<br>后来出现了docker，于是我们在一个服务器上面运行多个容器。</li>
<li>k8s的pod…</li>
</ol>
<p><img src="http://blog.linkinstars.com/mweb/15788125895169.jpg" alt></p>
<p>从上面的图你大概可以感受到pod在k8s中其实是一个什么样的角色。<br>我们如果使用虚拟机，那么上面就会有一系列的服务这些服务可能会有一些依赖，而这样的依赖就好像在服务器中运行的一个个进程组，往往其中也有着相关的依赖，而pod中的容器也是一样的道理，其中也会有类似这样的依赖，为了更好的描述和管理这样的依赖，于是就有了pod。<br>其实这样的理念往往可以类比出很多这样的设计。</p>
<h3 id="Pod中容器的关系"><a href="#Pod中容器的关系" class="headerlink" title="Pod中容器的关系"></a>Pod中容器的关系</h3><p>一定会有这样的关系吗？我的感觉是，在现代技术服务的开发的过程中，这样的关系是不可避免的。我下面来举几个例子。</p>
<h4 id="运行时容器和项目包"><a href="#运行时容器和项目包" class="headerlink" title="运行时容器和项目包"></a>运行时容器和项目包</h4><p>我们知道 java 的 web 应用往往需要部署在tomcat这样的容器之中，在 springboot 还没有出现以前，需要自己启动一个 tomcat 容器，然后将需要部署的应用打包部署到容器中去。</p>
<p>在以前你可能会想着，将 javaweb 打包一个war，然后编写一个 dockerfile 将 war 包cp到 tomcat 中的 webapp 目录中。但是这样带来的就是每次更新发布的时候，镜像会很大，因为每次构建都会有一个基础的tomcat镜像。</p>
<p>而在k8s使用的时候，会有的设计的是，将tomcat作为一个不变的镜像（它也不应该改变）而把 war 包作为另外一个容器，而这样个容器同时挂载同一个目录，将 webapp 挂载的目录与 war包挂载的目录相同来达到目的，然后将他们放到同一个 pod 中。</p>
<p>类似的操作还有： <a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/">https://kubernetes.io/zh/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/</a>  里面说的就是前端静态页面和 nginx 的关系。</p>
<p>下面引用官网设计理念中的一句话：“<strong>比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</strong>”</p>
<h4 id="日志架构"><a href="#日志架构" class="headerlink" title="日志架构"></a>日志架构</h4><p>在使用 docker 部署项目的时候会遇到一个问题就是日志持久化的问题，因为 docker 容器如果被删除的话，其中的文件也会被删除，那么我们的日志文件同时也会被删除，也就是说我们必须要将日志持久化。</p>
<p>最常见的方式是，将日志存储的目录挂载到宿主机上，这样容器被删除的时候日志不会被删除。<br>而在k8s中常见的日志处理架构是怎么样的呢？</p>
<p><a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/logging/">https://kubernetes.io/zh/docs/concepts/cluster-administration/logging/</a></p>
<p>使用的是 sidecar，这个是什么呢？其实就是一个辅助性质的容器，同时与主容器放在同一个 pod 中，读取主容器挂载出来的日志目录。其实后续还可以做更多的操作，比如日志发送es等等。</p>
<h4 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h4><p>总之我们可以看到，在一个pod中的容器关系是非常密切的，他们可以拥有同一个目录，甚至可以拥有同一个网络，可以拥有相互的服务，这样的关系我听过的名词叫做“超亲密关系”。就类似一对夫妻之间的关系了。</p>
<p>因为在现在的多说应用中，已经几乎做不到一个人顶天立地了，总是会有各种各样的依赖，依赖一些组件，依赖一些工具，依赖一些网络服务等等，一个进程组有很多的进程互相帮助来最终实现功能一样。</p>
<p>这样的关系太过常见，于是k8s就将它设计为了pod。</p>
<h3 id="pod的实现原理"><a href="#pod的实现原理" class="headerlink" title="pod的实现原理"></a>pod的实现原理</h3><p>如果你已经对docker的实现比较熟悉，其实pod的实现并不复杂。（如果对docker实现不熟悉可以翻看之前的博客）<br>其实pod是一个逻辑上的概念，其实pod做的事情很简单：</p>
<ul>
<li>pod中的所有容器共享一个Network Namespace</li>
<li>pod中的同期可以声明互相共享Volume</li>
</ul>
<h4 id="如何实现的"><a href="#如何实现的" class="headerlink" title="如何实现的"></a>如何实现的</h4><p><img src="http://blog.linkinstars.com/mweb/15788171449954.jpg" alt="-w587"><br>其实k8s做的就是初始化一个infra的容器（这是一个很小的容器），利用这个容器去抢先占用需要使用的 Namespace ，然后在将用户指定的容器加载进来，同时使用的就是相同的 Namespace 了。（如果有 InitContainer 会优先按顺序初始化它，图上就不做说明了）</p>
<p>这样共享网络应该是没有问题了，那么要共享Volume也很简单。pod 只需要将 Volume 目录挂载到宿主机，让内部的容器挂载这个目录就可以了。</p>
<h4 id="还有哪些共享"><a href="#还有哪些共享" class="headerlink" title="还有哪些共享"></a>还有哪些共享</h4><ul>
<li>PID 命名空间（同一个Pod中应用可以看到其它进程）</li>
<li>网络 命名空间（同一个Pod的中的应用对相同的IP地址和端口有权限）</li>
<li>IPC 命名空间（同一个Pod中的应用可以通过VPC或者POSIX进行通信）</li>
<li>UTS 命名空间（同一个Pod中的应用共享一个主机名称）</li>
</ul>
<h3 id="pod还有还有哪些功能"><a href="#pod还有还有哪些功能" class="headerlink" title="pod还有还有哪些功能"></a>pod还有还有哪些功能</h3><p>再来说说pod还有哪些功能，这些功能也是k8s为什么设计pod的原因之一</p>
<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h4><p>通过Probe：LivenessProbe或者ReadinessProbe，可以探测应用是否处于健康状态，如果不健康做出相关的反应。<br>这就好比k8s可以定期的帮你监控、维持一整个应用的健康。<br>其实在我们看来，很多时候服务挂了，需要重启，需要做高可用，那么nginx呢？tomcat呢？也是一样的。所以pod的健康能保证整个服务的全部健康使用。</p>
<h4 id="限制网络带宽"><a href="#限制网络带宽" class="headerlink" title="限制网络带宽"></a>限制网络带宽</h4><p>我们可以通过给Pod增加kubernetes.io/ingress-bandwidth和kubernetes.io/egress-bandwidth这两个annotation来限制Pod的网络带宽。<br>为什么我提到了这个功能呢？因为在实际的业务开发过程中经常会使用一些网络插件，这些网络插件在流量的控制上非常有用，有的时候我们会根据网络流量来做一系列的操作，用户的突然增长导致的流量剧增是否要扩容等等…而这样的监控和限制对于pod来说无疑会更加方便，而不需要管pod内部的容器的流量。</p>
<h4 id="RestartPoliy"><a href="#RestartPoliy" class="headerlink" title="RestartPoliy"></a>RestartPoliy</h4><p>重启的策略，这个也算是一个功能吧</p>
<ul>
<li>Always：只要退出就重启</li>
<li>OnFailure：失败退出（exit code不等于0）时重启</li>
<li>Never：只要退出就不再重启<br>说明 k8s 管理 pod 的生命周期更加容易，还有调度等等这里就不再展开了。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>官网：一个Pod（就像一群鲸鱼，或者一个豌豆夹）。</p>
<p>我觉得 Pod 更证明了一种设计模式“组合”，在有的时候会，组合的合理，就会方便很多东西，比如设计了一堆组件，组合在一起；ps画图的时候方块更圆组合在一起，就可以一起多复制几个组合。</p>
<p>当然我们在认识到为什么要这样设计 Pod 的同时需要意识到，我们应该将什么样的容器组合放置在同一个 Pod 之中才比较合适。遵循一定的“容器设计模式”进行编排，调度的时候才会更加得心应手。</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手kubernetes——minikube最小实现</title>
    <url>/post/4207395e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近在研究k8s，就来写一个关于k8s快速上手，并记录采坑的点。<br>需要的前置知识点：docker、k8s的一些基本概念，下面这个可能对你有帮助。<br><a href="https://juejin.im/post/5d1b2a656fb9a07edc0b7058">https://juejin.im/post/5d1b2a656fb9a07edc0b7058</a></p>
<span id="more"></span>
<h2 id="什么是k8s"><a href="#什么是k8s" class="headerlink" title="什么是k8s"></a>什么是k8s</h2><p>我们知道，我们可以将项目制作成docker镜像，然后利用docker去部署我们的项目，这样可以解决很多服务器环境所带来的问题；<br>但是容器多了，容器与容器之间就需要访问，之间就需要网络配置等等，从而就有了docker-compose；<br>但是当我们的服务进行升级，或者服务需要进行调度，扩容等等，这个时候就需要一个大管家来管所有的东西；<br>这个大管家就是 - Kubernetes</p>
<h2 id="初学会遇到的问题"><a href="#初学会遇到的问题" class="headerlink" title="初学会遇到的问题"></a>初学会遇到的问题</h2><p>因为k8s的东西太多了，所以学习成本现在越来越高，好在k8s已经很多教程。我说一下现在学的时候肯定会遇到的大问题：</p>
<ul>
<li>国内的问题（国内环境很多镜像拉不到）</li>
<li>本地搭建环境（原来搭建k8s需要一些服务器）</li>
<li>电脑环境的问题（windows和mac都有坑点）</li>
</ul>
<h2 id="最小实现"><a href="#最小实现" class="headerlink" title="最小实现"></a>最小实现</h2><p>现在我们就来在本机实现一个最小的k8s的实现，给出一个hello-world<br>k8s提供了minikube，这个东西可以让你本机一台机器就可以搭建起这个环境。拥有和线上一样的命令行操作和模式，但是不需要你再去创建很多虚拟机来搞事情了。超级方便也。<br><a href="https://minikube.sigs.k8s.io/">https://minikube.sigs.k8s.io/</a><br>我们就利用这个来实现，下面来说说步骤：<br>我的本机环境：</p>
<ul>
<li>macOS </li>
<li>minikube version: v1.5.2</li>
<li>Docker version 18.03.1-ce</li>
</ul>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>大致步骤：<a href="https://minikube.sigs.k8s.io/docs/start/macos/">https://minikube.sigs.k8s.io/docs/start/macos/</a></p>
<p><code>brew install minikube</code><br><code>brew install docker-machine-driver-vmware</code><br><code>minikube start --vm-driver=vmware --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</code></p>
<p>成功之后：<br><code>minikube status</code> 查看minikube的状态<br><code>minikube ip</code> 查看minikube的ip<br><code>minikube dashboard</code> 打开dashboard展示k8s的状态</p>
<h3 id="安装坑点"><a href="#安装坑点" class="headerlink" title="安装坑点"></a>安装坑点</h3><ul>
<li>HyperKit最新版本可能存在问题，所以我使用VMware Fusion实现虚拟化的依赖</li>
<li>国内<code>k8s.gcr.io</code>的相关镜像国内拉取不到，使用mirrorgooglecontainers也无法拉取到，所以使用阿里云的仓库 <a href="https://github.com/kubernetes/minikube/issues/3860">https://github.com/kubernetes/minikube/issues/3860</a></li>
<li>如果之前已经使用过<code>minikube start</code>命令，建议先<code>minikube delete</code>，并删除<code>rm -rf ~/.minikube/</code>，然后重新start</li>
</ul>
<h3 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h3><p>首先描述一下部署要做的事情：linkinstar/mini-go:v1.0 是我已经上传到 docker-hub 里面的一个已经做好的最简单的项目，会暴露一个8080端口的web服务；<br>最终的目标，在k8s创建一个pod，pod中运行一个我们的容器，最终我们在外部可以访问到这个服务</p>
<h4 id="首先创建两个文件"><a href="#首先创建两个文件" class="headerlink" title="首先创建两个文件"></a>首先创建两个文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deploy.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mini-go</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mini-go</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mini-go</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mini-go</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mini-go</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">linkinstar/mini-go:v1.0</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mini-go-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mini-go</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30008</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><ul>
<li>kubectl create -f service.yaml</li>
<li>kubectl create -f deploy.yaml</li>
</ul>
<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>执行成功可以再dashboard中查看执行状态<br><img src="http://blog.linkinstars.com/mweb/15744936359705.jpg" alt><br><img src="http://blog.linkinstars.com/mweb/15744936444210.jpg" alt></p>
<p>最终访问地址查看到服务是否正常：<a href="http://192.168.231.146:30008/">http://192.168.231.146:30008/</a><br>其中的ip是通过 <code>minikube ip</code> 命令查看的</p>
<h3 id="服务操作"><a href="#服务操作" class="headerlink" title="服务操作"></a>服务操作</h3><h4 id="水平伸缩"><a href="#水平伸缩" class="headerlink" title="水平伸缩"></a>水平伸缩</h4><p>在现实的业务环境中，当用户的访问增多，我们需要扩展我们的应用，也就是水平的去多部署几个容器，有了k8s之后这件事就变得非常的容易了。</p>
<ul>
<li>修改 deploy.yaml 文件中的 replicas: 2 改成2个</li>
<li>使用命令：<code>kubectl apply -f deploy.yaml</code> 使配置生效</li>
</ul>
<p>然后我们就可以看到，原来的一个pod变成了两个，而k8s会将我们的请求负载均衡到每个pod中。整个过程可以说是非常的优雅了。</p>
<p><img src="http://blog.linkinstars.com/mweb/15744959372693.jpg" alt></p>
<p>同样的，当我们需要减少服务的数量时也是相同的道理</p>
<h4 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h4><p>对于应用的版本升级也是同样的道理</p>
<ul>
<li>修改 deploy.yaml 文件中的 image: linkinstar/mini-go:v2.0 改成2.0</li>
<li>使用命令：<code>kubectl apply -f deploy.yaml</code> 使配置生效</li>
</ul>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>当我们发现发布的服务问题，想要进行版本回退的时候，就可以使用<br><code>kubectl rollout undo deployments/mini-go</code><br>进行版本回退，下面是版本回退过程中</p>
<p><img src="http://blog.linkinstars.com/mweb/15744966749719.jpg" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>使用minikube可以快速让新手感受到k8s到底是如何使用的</li>
<li>环境配置过程中会有很多问题，需要你耐心解决</li>
<li>k8s在服务编排上面除了以上提到的用法以外还有很多牛逼的功能等着你去发现</li>
<li>学习过程中需要保持一个原则，先用着看看 -&gt; 搞清楚架构 -&gt; 尝试各种功能 -&gt; 学习各个模块的实现 -&gt; 最终实践</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 意外集锦 - oom 的连锁反应</title>
    <url>/post/b817d222.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一开始觉得 oom 是一个常见问题，应该没有什么大问题，反正 k8s 集群会调度的，但其实它造成的连锁反应很恐怖。</p>
<span id="more"></span>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>具体简单描述过程：一台机器 OMM， 导致将对应的pod调度到了其他节点上，导致其他节点 OOM 然后开始疯狂输出日志信息，然后导致 master 磁盘不足开始清理并驱逐，然后导致驱逐（Evicted）的应用再次调度到其他节点，然后连锁反应，最终相关大量服务不可用….</p>
<p><code>pod 出现告警信息 The node had condition: [DiskPressure].</code></p>
<p><img src="http://blog.linkinstars.com//blog/oom-master-df-lh.png" alt="oom-master-df-lh"></p>
<p>总的来说就是一个 应用的 oom 不停的被调度来调度去，导致日志疯狂的输出，导致磁盘不足了。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="设置合适的内存请求和限制条件"><a href="#设置合适的内存请求和限制条件" class="headerlink" title="设置合适的内存请求和限制条件"></a>设置合适的内存请求和限制条件</h3><p>限制单个应用的使用内存还是非常有必要的，免得出现很多意外的情况</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">   <span class="attr">requests:</span></span><br><span class="line">     <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">     <span class="attr">memory:</span> <span class="string">128Mi</span></span><br><span class="line">   <span class="attr">limits:</span></span><br><span class="line">     <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">     <span class="attr">memory:</span> <span class="string">256Mi</span></span><br></pre></td></tr></table></figure>
<h3 id="应用-bug-修复"><a href="#应用-bug-修复" class="headerlink" title="应用 bug 修复"></a>应用 bug 修复</h3><p>代码 bug 肯定要修复的，这个毕竟是导致问题的主要原因</p>
<h3 id="升级-ECS-的内存"><a href="#升级-ECS-的内存" class="headerlink" title="升级 ECS 的内存"></a>升级 ECS 的内存</h3><p>确实当前的集群中的内存不够应用使用了（主要是非常容易出现问题）</p>
<h3 id="定时清理-master-和-work-上的系统日志"><a href="#定时清理-master-和-work-上的系统日志" class="headerlink" title="定时清理 master 和 work 上的系统日志"></a>定时清理 master 和 work 上的系统日志</h3><p>之前都没有清理过 k8s 的日志文件，运行了很久，一直堆积也没有去管它，从而也是导致这次问题的一个原因之一，所以搞个脚本定时清理还是非常有必要的</p>
<h3 id="添加磁盘监控"><a href="#添加磁盘监控" class="headerlink" title="添加磁盘监控"></a>添加磁盘监控</h3><p>因为没有高存储类型的应用，之前完全就没有想到磁盘会出问题，所以添加磁盘的监控</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s-accident</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 小技巧</title>
    <url>/post/9ef22657.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本博客持续更新…用于记录 k8s 使用过程中的很多的小技巧，也希望你能提供更多的小技巧来~</p>
<span id="more"></span>
<h2 id="图形化管理工具-lens"><a href="#图形化管理工具-lens" class="headerlink" title="图形化管理工具 lens"></a>图形化管理工具 lens</h2><p>图形化 k8s 管理工具: <a href="https://github.com/lensapp/lens">https://github.com/lensapp/lens</a></p>
<p>我觉得可以少部署一个 dashboard，并且比官方的 dashboard 好看很多</p>
<h2 id="重启-deployment-命令"><a href="#重启-deployment-命令" class="headerlink" title="重启 deployment 命令"></a>重启 deployment 命令</h2><p>我一开始总是 delete 一次 apply 一次，感觉很蠢，又换成调整 scle 但是还是很慢，查了之后发现原来本来就有重启的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout restart deployment nginx-dep</span><br></pre></td></tr></table></figure>
<h2 id="查看链接配置信息"><a href="#查看链接配置信息" class="headerlink" title="查看链接配置信息"></a>查看链接配置信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config view --minify --raw</span><br></pre></td></tr></table></figure>
<h2 id="kubectx"><a href="#kubectx" class="headerlink" title="kubectx"></a>kubectx</h2><p>当你需要使用 kubectl 操作多个集群的时候，可以使用 kubectx 切换 context，非常方便</p>
<p>多集群管理切换工具：<a href="https://github.com/ahmetb/kubectx">https://github.com/ahmetb/kubectx</a></p>
<h2 id="更新-configmap-脚本"><a href="#更新-configmap-脚本" class="headerlink" title="更新 configmap 脚本"></a>更新 configmap 脚本</h2><p>对于配置文件 configmap 的更新我真的没有找到合适的命令，直接 使用 kubectl edit 那么原来的文件是没有被更改的，会导致配置不同步。后面会尝试找找还有没有更好的方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 配置文件 ./reload-config.sh config.yaml</span></span><br><span class="line"></span><br><span class="line">filename=<span class="variable">$1</span></span><br><span class="line">namespace=default</span><br><span class="line"></span><br><span class="line">app=`<span class="built_in">echo</span> <span class="variable">$filename</span> | cut -d . -f1`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$app</span> ];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;filename is empty!&quot;</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$namespace</span> ];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;namespace is empty!&quot;</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;start to reload [<span class="variable">$app</span>] configmap&quot;</span></span><br><span class="line"></span><br><span class="line">kubectl get configmap <span class="variable">$app</span>-config -o yaml -n <span class="variable">$namespace</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;---------------------start delete-----------------------------&quot;</span></span><br><span class="line">kubectl delete configmap <span class="variable">$app</span>-config -n <span class="variable">$namespace</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;---------------------start create-----------------------------&quot;</span></span><br><span class="line">kubectl create configmap <span class="variable">$app</span>-config --from-file=<span class="variable">$app</span>.yaml -n <span class="variable">$namespace</span></span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line">kubectl get configmap <span class="variable">$app</span>-config -o yaml -n <span class="variable">$namespace</span></span><br></pre></td></tr></table></figure>
<h2 id="单文件-subpath-挂载"><a href="#单文件-subpath-挂载" class="headerlink" title="单文件 subpath 挂载"></a>单文件 subpath 挂载</h2><p>configmap 修改无法自动热更新</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/test.yaml</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">test.yaml</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">test-config</span></span><br></pre></td></tr></table></figure>
<h2 id="单文件-mountPath-挂载"><a href="#单文件-mountPath-挂载" class="headerlink" title="单文件 mountPath 挂载"></a>单文件 mountPath 挂载</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">&quot;/conf&quot;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">test-config</span></span><br><span class="line">        <span class="attr">items:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">test.json</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">test.json</span></span><br></pre></td></tr></table></figure>
<h2 id="挂载整个目录"><a href="#挂载整个目录" class="headerlink" title="挂载整个目录"></a>挂载整个目录</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">special-config</span></span><br></pre></td></tr></table></figure>
<h2 id="不同命名空间的服务相互访问"><a href="#不同命名空间的服务相互访问" class="headerlink" title="不同命名空间的服务相互访问"></a>不同命名空间的服务相互访问</h2><p>原来 statefulset 的访问方式是不一样的哦</p>
<p><a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/">https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/</a></p>
<h3 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;pod-ip&#125;.&#123;namespace&#125;.pod.cluster.local //例如某pod的ip为 1.2.3.4,在命名空间default与DNS名称cluster.local将有一个域名：1-2-3-4.default.pod.cluster.local。</span><br><span class="line">&#123;pod-ip&#125;.&#123;namespace&#125;.svc.cluster.local</span><br><span class="line">&#123;pod-name&#125;.&#123;namespace&#125;.svc.cluster.local</span><br><span class="line">&#123;pod-name&#125;.&#123;subdomain&#125;.&#123;namespace&#125;.svc.cluster.local // subdomain是在创建pod设定的属性,和hostname可以一起设置</span><br></pre></td></tr></table></figure>
<h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;pod-name&#125;.&#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local</span><br><span class="line">可以进入到pod中查看/etc/hosts</span><br></pre></td></tr></table></figure>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local</span><br><span class="line"></span><br><span class="line">服务例子：</span><br><span class="line">redis-service.redis.svc.cluster.local //redis-service 服务名 redis namespace</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s-tips</tag>
      </tags>
  </entry>
  <entry>
    <title>你的 IO 还好吗</title>
    <url>/post/f0943d44.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 CPU 看来内存好慢啊，看我跑的多快；在内存看来磁盘你好慢啊，看我比你还快点；磁盘…</p>
<p>IO 问题并非特别常见，但是因为最终要落到磁盘上，当它成为瓶颈时，往往会拖慢你的脚本，今天我们来分析下在 linux 中的 IO 问题</p>
<span id="more"></span>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>看 IO 并不只是看 IO，记住这句话，因为很多时候，IO 问题总会伴随着别的问题一起出现，而会导致误判的，从而遗漏了问题的关键。</p>
<p>IO 问题的指标来源于两块：</p>
<ol>
<li>文件系统</li>
<li>磁盘</li>
</ol>
<h3 id="iowait"><a href="#iowait" class="headerlink" title="iowait"></a>iowait</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><code>top</code> </p>
<p><code>iostat</code></p>
<p><strong>%iowait 表示在一个采样周期内有百分之几的时间属于以下情况：CPU空闲、并且有仍未完成的I/O请求。</strong></p>
<h4 id="指标-1"><a href="#指标-1" class="headerlink" title="指标"></a>指标</h4><p>iowait 升高或者居高不下，可以考虑存在 IO 瓶颈或压力</p>
<h3 id="rs-ws"><a href="#rs-ws" class="headerlink" title="rs / ws"></a>rs / ws</h3><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p><code>iostat -x -d 1</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00    13.00    0.00    4.00     0.00    68.00    34.00     0.00    1.00    0.00    1.00   0.25   0.10</span><br><span class="line">dm-0              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00</span><br></pre></td></tr></table></figure>
<h4 id="指标-2"><a href="#指标-2" class="headerlink" title="指标"></a>指标</h4><ul>
<li>r/s: 每秒完成的读 I/O 设备次数。即 rio/s</li>
<li>w/s: 每秒完成的写 I/O 设备次数。即 wio/s</li>
<li>rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li>
<li>wkB/s: 每秒写K字节数。是 wsect/s 的一半。</li>
</ul>
<p>从这里可以确定是读或者写存在压力</p>
<h3 id="util"><a href="#util" class="headerlink" title="%util"></a>%util</h3><h4 id="指标-3"><a href="#指标-3" class="headerlink" title="指标"></a>指标</h4><p>一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</p>
<p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><h4 id="指标-4"><a href="#指标-4" class="headerlink" title="指标"></a>指标</h4><ul>
<li>await: 平均每次设备I/O操作的等待时间 (毫秒)。</li>
<li>svctm: 平均每次设备I/O操作的服务时间 (毫秒)。</li>
</ul>
<p>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化</p>
<h2 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h2><p>对于 IO 问题，其实个人遇到的比较少，因为其实现在大多都是 web 类型的服务应用和一些数据处理服务，基本上都是累垮 cpu 和内存的，但是并不代表 IO 问题就没有，当出现问题的时候就很容易被忽视。（这里暂时不讨论网络的 IO 问题，关注于磁盘）</p>
<ol>
<li>确定当前应用存在 IO 操作：有很多时候你自己都不知道你的应用存在 IO 操作，如：日志操作，临时文件…</li>
<li>确定 iowait ：这个指标很关键，虽然它高不一定 100% 有问题，但是能证明存在了大量的 IO 操作</li>
<li>使用 iostat 看：如果确定了前两项，那么就可以考虑 IO 可能存在瓶颈，就可以看一下读写大不大是否正常</li>
<li>使用 pidstat -d 看：确定是否是自己进程导致，还是别的应用或者是中间件导致</li>
<li>最后看到底是谁在操作并且操作了什么文件：strace + lsof 基本就能分析出最终的一个文件操作了</li>
</ol>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>这个是最常见的一个问题，大多数情况下，日志的打印基本都是异步的一个操作，并且日志大多数情况下也比较小。但代码是人写的，所以就会出现问题。</p>
<p>最常见的是，将返回值直接输出到日志，有的时候，一些命令的调用或者是一些请求的返回，当出现异常时错误输出可能会很大，而直接输出到日志那么势必会增加 IO 负担。而当出现错误程序员必然会将错误打印日志。而出现错误必然会导致用户重试。</p>
<p>用户重试 -&gt; 命令出错 -&gt; 打印错误日志 -&gt; 用户重试</p>
<p>一方面我见过直接日志把磁盘吃满的情况，一方面还有因为日志开启了 debug 导致其他 IO 等待的问题</p>
<h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><p>我们在执行命令或者是利用磁盘做缓存，或者是文件上传，都会产生一些临时文件，而这些临时文件的操作也有可能导致 IO 问题</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>mysql 、mongo、redis等等一下常见的组件都会对磁盘进行操作，尤其是数据库这种，存储数据量很大的情况。<strong>注意 IO 问题并不一定是写，有可能是读！</strong> 因为你数据存磁盘上，你要进行读取，磁盘的磁头也就扫那么快，要不你就 SSD，否则当读取量很大的时候，那也有可能导致瓶颈</p>
<h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>有的时候也和我们操作 IO 的方式有关，如果我们之间跳过系统缓存直接操作磁盘。还有随机写，同步异步也会直接影响 IO 的速度</p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>虽然这个很不常见，对于我们来说还是很少看到，但不得不提一下，凡是有万一嘛。</p>
<p>最直接的就是磁盘换 ssd，使用 RAID….</p>
<p>如果硬件出现问题，那么可以尝试看看 dmsg 看看是否有出现一些奇怪的报错信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就想一开始说的，I/O 往往是一个系统中跑的最慢的，如果它出现瓶颈，那么势必带来的问题就很明显。</p>
<p>同样的，也就是因为是最后一个位置，在这之前都可以通过CPU、内存、缓存等等在这之前搞定它。</p>
<p>如果你的数据最后落库，那么数据库上的 I/O 问题也是需要被考虑在内的。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>你的 CPU 还好吗</title>
    <url>/post/49d36794.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近经常在线上排查一些问题，在大多数情况下，都是代码写的业务逻辑有问题；还有一些情况是内存上导致的问题，如 OOM 或者由于数据量大导致的一些问题；但是很少会关注，但常常又会瞟一眼的，这个关注点就是 CPU。</p>
<p>在说到 CPU 的时候往往除了 <code>top</code> 看一下 CPU 使用率之外，你还会关注别的什么吗？好像也不会。</p>
<p>但是其实当真正出现问题的时候，很多 CPU 相关的指标都会反映出一些问题，经过之前的学习今天就来总结记录一下。</p>
<span id="more"></span>
<h2 id="诊断指标"><a href="#诊断指标" class="headerlink" title="诊断指标"></a>诊断指标</h2><h3 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数，也就是平均活跃进程数（单位时间内活跃进程数）</p>
<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><ul>
<li><code>uptime</code></li>
<li><code>top</code></li>
</ul>
<h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p>当平均负载高于 CPU 数量的 70% 可能就有问题了（在实际中如果你看到平均负载突然升高，也就是三个值呈现递减的趋势，就需要考虑 CPU 问题了）</p>
<h3 id="CPU-使用率"><a href="#CPU-使用率" class="headerlink" title="CPU 使用率"></a>CPU 使用率</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>除了空闲时间外的其他时间占总 CPU 时间的百分比</p>
<h4 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h4><ul>
<li><code>top</code></li>
<li><p><code>ps</code></p>
</li>
<li><p><code>mpstat -P ALL 5</code></p>
</li>
<li><code>pidstat</code></li>
</ul>
<h4 id="指标-1"><a href="#指标-1" class="headerlink" title="指标"></a>指标</h4><p>这个其实不用说你就有感觉的，如果你看到你的程序占用了 30%CPU 使用率，而别人都没得用，那就肯定奇怪了</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>将前一个任务的 CPU 上下文保存起来，然后加载别的任务的上下文并执行</p>
<h4 id="查看-2"><a href="#查看-2" class="headerlink" title="查看"></a>查看</h4><ul>
<li><code>vmstat 5</code></li>
<li><code>pidstat -w</code></li>
<li><code>cat /proc/interrupts</code></li>
</ul>
<h4 id="指标-2"><a href="#指标-2" class="headerlink" title="指标"></a>指标</h4><p>上下文切换容易被忽略，很多时候并不会看这个；一般当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，很可能就存在问题了。</p>
<p>如果是自愿上下文切换多，那么考虑 I/O 、内存等资源不够导致；如果是非自愿切换多，那么考虑 CPU 性能瓶颈</p>
<h2 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h2><p>看了那么多指标，我想你也肯定头晕，我总不能每次到服务器上想看看有没有问题，就把所有命令全部一股脑敲一遍吧。</p>
<p>首先，我们一般遇到 CPU 的问题比较少，其次我下面从一个开发的视角（运维肯定会更专业），来说下我一般的排查步骤，仅供参考。</p>
<ol start="0">
<li><p>监控告警，一般大公司或者云厂商都有服务器监控，监控项肯定包含 CPU，如果有肯定是要先看下监控数据</p>
</li>
<li><p>看服务器卡不卡，你要是敲个命令响应半天，排除你网络卡的原因，那么多半是服务器要不行了</p>
</li>
<li>确定当前压力，当前用户访问频繁（本身压力就很大）或者说当前只有几十个用户访问（平峰状态）</li>
<li>uptime，top 看平均负载和使用率，如果没问题，一般就可以先考虑别的因素了</li>
<li>如果确实在没什么用户访问的情况下使用率高，pidstat 看一眼中断，看一眼切换</li>
<li>如果认为确实有问题看一眼 ps，看一眼网络，看一眼系统调用，基本就能确定大致问题了</li>
</ol>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>那么究其根本肯定是你代码写的有问题~ 很少说服务器 CPU 坏了导致问题吧，至少我是还没见到过。</p>
<p>所以下面列出当 CPU 出现问题时可能的原因（原因有很多，这里列举我曾经见过的）</p>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>这个是最常见的，也是最容易犯的，如果那个地方偷偷给你挖个坑，CPU 立马就搜搜的上去了。</p>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>大量网络请求导致触发了很多中断，就是常说的小包问题，或者常见的 SYN FLOOD</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>很多程序中定时器的使用也会造成 CPU 使用率高，虽然可能只有 3% 这样。常见的情景有：大量的任务执行，每个任务都有一个超时的定时器去跟踪任务的超时。</p>
<h3 id="频繁的错误系统调用"><a href="#频繁的错误系统调用" class="headerlink" title="频繁的错误系统调用"></a>频繁的错误系统调用</h3><p>有时可能你看到平均负载高，但是找不到进程。可能由于你执行一个什么命令，但是命令执行失败了，然后不停的重试导致。其中触发的频繁的系统调用，导致上下文切换频繁，从而出现问题。</p>
<h3 id="过多的线程或协程"><a href="#过多的线程或协程" class="headerlink" title="过多的线程或协程"></a>过多的线程或协程</h3><p>也曾遇到过创建过多的线程或协程导致切换不过来的情况，并且前面的任务做不完，后面的任务又堆上来，越滚越大。这个容易解决的，只要搞个线程池，限制一下最大基本都能解决。</p>
<h3 id="I-O-操作"><a href="#I-O-操作" class="headerlink" title="I/O 操作"></a>I/O 操作</h3><p>绕过缓存，直接读磁盘 I/O，iowait 反映会很明显。现在很多语言都有封装库，所以并不常见。</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>进程已经结束，但是父进程没有回收描述符 pid 等资源，一直 wait 下去。现在很多语言也很少有直接操作 fork 的玩法，多数情况下是线程或协程搞定，所以 Z 状态也少见，实际中多看看 D 状态存在时间可能会找到问题关键。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，可能性比较高的 CPU 问题情况大致可以分为两种：</p>
<ul>
<li>异步任务的不正常处理（访问不频繁但 CPU 高）</li>
<li>系统调用或网络请求的不正常处理（频繁请求变得很卡）</li>
</ul>
<p>以上就是相关 CPU 问题的总结和排查方式，虽然具体情况具体分析，但很多时候遇到具体情况你应该知道怎么分析。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 图形化监控工具</title>
    <url>/post/a4957565.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近在分析线上问题，需要监控 Linux 相关指标，如果只是用命令，总是只能知道当前的值，无法记录过程。而设备不是云厂商的设备，所以没有相关监控，zabbix 有，但是没有相关权限可以看到。所以找到一些好用的监控小方案。</p>
<span id="more"></span>
<h2 id="nmon"><a href="#nmon" class="headerlink" title="nmon"></a>nmon</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>yum install nmon</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="http://blog.linkinstars.com//blog/1240.png" alt="image.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>安装方便，使用简单，最快速度能搞定，无需过多依赖，控制台展示</li>
<li>当然它还有其他内存等相关信息的展示</li>
<li>不是特别好看（毕竟是控制台要求也不能太高），精度相对低，只能有个大概峰值</li>
</ul>
<h2 id="bottom"><a href="#bottom" class="headerlink" title="bottom"></a>bottom</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>因为是 rust 搞的，所以可能有相关依赖，需要手动处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/ClementTsang/bottom/releases/download/0.4.5/bottom_x86_64-unknown-linux-gnu.tar.gz</span><br><span class="line">tar xvf bottom_x86_64-unknown-linux-gnu.tar.gz</span><br><span class="line">./btm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果出现以下错误需要安装 glibc </span></span><br><span class="line"><span class="comment"># /btm: /lib64/libc.so.6: version `GLIBC_2.18&#x27; not found (required by ./btm)</span></span><br><span class="line">curl -O http://ftp.gnu.org/gnu/glibc/glibc-2.18.tar.gz</span><br><span class="line">tar zxf glibc-2.18.tar.gz</span><br><span class="line"><span class="built_in">cd</span> glibc-2.18/</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build/</span><br><span class="line">../configure --prefix=/usr</span><br><span class="line">make -j2</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">./btm</span><br></pre></td></tr></table></figure>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><img src="http://blog.linkinstars.com//blog/1240-20200719221546178.png" alt="image.png"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>不错，也还挺好看的，因为用点绘制，所以更加好看一丢丢</li>
<li>安装可能有依赖，需要手动处理</li>
</ul>
<h2 id="netdata"><a href="#netdata" class="headerlink" title="netdata"></a>netdata</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make sure you run `bash` for your shell</span></span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># install Netdata directly from GitHub source</span></span><br><span class="line">bash &lt;(curl -Ss https://my-netdata.io/kickstart.sh)</span><br></pre></td></tr></table></figure>
<p>或者直接 docker</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d --name=netdata \</span></span><br><span class="line"><span class="bash">  -p 19999:19999 \</span></span><br><span class="line"><span class="bash">  -v netdatalib:/var/lib/netdata \</span></span><br><span class="line"><span class="bash">  -v netdatacache:/var/cache/netdata \</span></span><br><span class="line"><span class="bash">  -v /etc/passwd:/host/etc/passwd:ro \</span></span><br><span class="line"><span class="bash">  -v /etc/group:/host/etc/group:ro \</span></span><br><span class="line"><span class="bash">  -v /proc:/host/proc:ro \</span></span><br><span class="line"><span class="bash">  -v /sys:/host/sys:ro \</span></span><br><span class="line"><span class="bash">  -v /etc/os-release:/host/etc/os-release:ro \</span></span><br><span class="line"><span class="bash">  --restart unless-stopped \</span></span><br><span class="line"><span class="bash">  --cap-add SYS_PTRACE \</span></span><br><span class="line"><span class="bash">  --security-opt apparmor=unconfined \</span></span><br><span class="line"><span class="bash">  netdata/netdata</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p><img src="http://blog.linkinstars.com//blog/1240-20200719221552304.png" alt="image.png"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果手动安装的话，依赖很多，虽然官方提供了一键安装，整体安装过程还是比较长的</li>
<li>docker 直接启一个倒是很快，拉个镜像一跑起来就好了</li>
<li>好看，真的不错，各类指标都一应俱全，而且 UI 也很好看（CPU，内存，网络，中断等等都有，真的很全）</li>
<li>网上说安装后会影响服务器运行速度，这个监控指标很多，确实所以本身会占用一定服务器资源，需要注意</li>
</ul>
<h2 id="grafana-influxdb-telegraf"><a href="#grafana-influxdb-telegraf" class="headerlink" title="grafana + influxdb + telegraf"></a>grafana + influxdb + telegraf</h2><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>我这边因为线上本身就有前两个的环境，所以只需要装个 telegraf 就能搞定，如果你没有，也可以手动装个，具体步骤可以参考 <a href="https://www.jianshu.com/p/2fd3e9252a41">https://www.jianshu.com/p/2fd3e9252a41</a></p>
</li>
<li><p>其实原本想用 Prometheus + Grafana 的，但是线上暂时没有 Prometheus 之前也用过，这里就不做展示了，其实也很方便 <a href="https://www.jianshu.com/p/8d2c020313f0">https://www.jianshu.com/p/8d2c020313f0</a></p>
</li>
</ul>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p><img src="http://blog.linkinstars.com//blog/1240-20200719221557146.png" alt="image.png"></p>
<p>一个字，好看！</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>相关监控信息一应俱全，整体好看，grafana 确实有一手</li>
<li>相对环境如果用 docker 部署会容易很多，本身也不复杂，配置简单，推荐</li>
<li>相对来说还可以直接用</li>
</ul>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>当前我用最后一种在线上先跑着，看看情况。</p>
<p>上面的监控有简单的，有复杂的，你喜欢哪一种呢？或者说你还有什么更好的方案也欢迎在下面评论。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>monitor</tag>
      </tags>
  </entry>
  <entry>
    <title>你的内存还好吗</title>
    <url>/post/14f810f7.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>内存问题往往是线上环境最容易导致的问题，因为其实对于程序来说，内存总是不够用的。而大多数我们在线上遇到的问题总是一个叫 OOM 的，导致这个问题的原因也有很多，今天我们就来看看，如何在线上定位或者排查这样的问题。</p>
<span id="more"></span>
<h2 id="诊断指标"><a href="#诊断指标" class="headerlink" title="诊断指标"></a>诊断指标</h2><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><code>free -h</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@Linkin /]<span class="comment"># free -h</span></span><br><span class="line">total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.6G        326M        6.2G        480K        1.1G        7.0G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>
<h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><p>这个命令可以看到当前设备的内存总体使用情况，以及很清楚的看到交换区的内存使用情况</p>
<ul>
<li>total：总内存</li>
<li>used: 已使用内存，包含共享内存</li>
<li>free: 未使用内存</li>
<li>shared: 共享内存</li>
<li>buff/cache 缓存和缓冲区</li>
<li>available 新进程可用内存</li>
</ul>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p><code>top</code> + <code>M</code></p>
<h4 id="指标-1"><a href="#指标-1" class="headerlink" title="指标"></a>指标</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 20:29:20 up 10 min,  1 user,  load average: 0.00, 0.09, 0.10</span><br><span class="line">Tasks:  92 total,   1 running,  91 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.5 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  7.6/8009024  [||||||||                                                                                            ]</span><br><span class="line">KiB Swap:  0.0/0        [                                                                                                    ]</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 1001 influxdb  20   0  566444  81360  16180 S   0.3  1.0   0:11.26 influxd</span><br><span class="line"> 1025 root      20   0  799412  73760  27816 S   0.0  0.9   0:00.76 dockerd</span><br><span class="line"> 1023 root      20   0  509024  40648  14164 S   0.0  0.5   0:00.37 containerd</span><br><span class="line"> 1009 root      20   0  574204  17504   6128 S   0.0  0.2   0:00.32 tuned</span><br><span class="line">  746 polkitd   20   0  612344  12260   4772 S   0.0  0.2   0:00.03 polkitd</span><br></pre></td></tr></table></figure>
<p>top 总是能发现绝大多数的问题，按 M 之后会按照内存的使用情况进行排序，你可以清楚的看到内存占用最多的进程是什么。</p>
<ul>
<li>VIRT 进程虚拟内存大小</li>
<li>RES 常驻内存，就是实际使用的物理内存，但是不包含 Swap 和共享的</li>
<li>SHR 共享内存</li>
<li>%MEM 内存使用百分比</li>
</ul>
<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p><code>vmstat -a 5 5</code></p>
<h4 id="指标-2"><a href="#指标-2" class="headerlink" title="指标"></a>指标</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@Linkin ~]<span class="comment"># vmstat -a 5 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free  inact active   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 1  0      0 5970260 487444 1006228    0    0     1     3    4    8  0  0 100  0  0</span><br><span class="line"> 0  0      0 5970260 487448 1006336    0    0     0    30  588 1132  0  0 100  0  0</span><br></pre></td></tr></table></figure>
<ul>
<li><p>si: 每秒从交换区写到内存的大小</p>
</li>
<li><p>so: 每秒写入交换区的内存大小</p>
</li>
<li>inact: 非活跃内存大小</li>
<li>active: 活跃的内存大小</li>
</ul>
<p>这个命令可以清楚看到当前是否有交换区的换入和换出，并且能记录下变化过程，还有活跃和非活跃的内存使用情况；同时能看到 CPU 和 IO 的情况，顺便看看是否由其他问题导致。</p>
<h2 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h2><p>其实内存问题的排查并没有特别复杂，我们所要做的就是定位：</p>
<ol>
<li>确定是否有内存不正常使用的问题</li>
<li>确定是什么进程或应用占用了过多的内存，能否优化</li>
</ol>
<p>那下面就说说我一般在线上排查问题常用的步骤，仅供参考</p>
<ol>
<li>注意首先肯定是监控！内存问题和别的问题不一样，内存使用过多会直接导致严重的问题，应用可能会直接挂，或者影响别的同时部署的应用，所以做好监控是非常有必要的。（说白了，你不可能一直盯着屏幕看，有时候一个峰值就持续 1 分钟就过去了）<ol>
<li>监控忙时峰值和平均峰值，当应用服务被频繁访问时往往会出现问题</li>
<li>监控闲时的波峰，如果应用访问不频繁，但是突然又波峰并且很大，需要注意下</li>
<li>监控持续上涨情况，有的应用部署时间长了才会注意到有内存泄露的问题</li>
</ol>
</li>
<li>上去就是 free，如果出现问题上去第一步我就会敲这个，确定当前内存使用情况</li>
<li>然后就是 top 看是不是我自己服务导致的，或者是由于别的组件导致的</li>
<li>用 vmstat 做个30 秒看看情况，是否还有继续上涨的趋势</li>
<li>如果应用崩溃了怎么办？有的时候崩溃之后应用本身日志没有任何问题，看起来像是正常退出一样<ol>
<li>看应用本身日志是否显示 OOM</li>
<li>看 dmesg 是否显示 OOM</li>
<li>看 var/log/message 是否显示了问题</li>
<li>看崩溃前后的调用服务日志，看是否由于对应服务业务问题导致</li>
</ol>
</li>
<li>如果是自身服务导致，根据具体业务分析</li>
</ol>
<h2 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h2><p>内存的出现问题的原因有很多，大多数都和具体业务相关，这里也没有办法进行罗列，举几个最常见的案例</p>
<h3 id="突然过大"><a href="#突然过大" class="headerlink" title="突然过大"></a>突然过大</h3><p>一般是由于数据量过大，比如查询数据时没有约束最大值导致将数据库全部数据都查询出来；</p>
<p>或者是由于传递参数问题，比如传递了一个 10000000 这样的值，然后用这个长度直接去创建了数组或者别的类型，而实际并没有那么多数据，经常出现于三方调用接口时导致</p>
<h3 id="慢慢变大"><a href="#慢慢变大" class="headerlink" title="慢慢变大"></a>慢慢变大</h3><p>如果是使用 java 或者 go 这样带有 gc 的语言会好很多，你不用主动去 free 你使用的内存；但是别妄想着没问题，实际中很多时候用于指针的使用，或者是线程的不断创建，等等原因导致对象无法被 gc 从而也会产生内存泄露。</p>
<p>还有连接池没有设置最大上限，也会有可能慢慢变大。</p>
<h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>有时候应用会缓存一些数据到内存中，一般情况下不会缓存很大的数据，可能就是一些热点数据等，大多时候缓存大数据量的时候也会考虑使用 redis，但还是会出现使用内存缓存一些 map 的时候由于用户量突然上来，导致内存占用过多的情况发生。</p>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>有时候一些应用访问并不多，但是内存占用往往在一段时间之后就会变大且无法释放，有些时候就是由于内部的一些定时任务或者定时器导致内存使用后没还导致的。多见于一些需要设定超时时间，但是超时时间又没有设定默认值的情况。</p>
<h3 id="使用-swap"><a href="#使用-swap" class="headerlink" title="使用 swap"></a>使用 swap</h3><p>有时内存突然的上升会导致内核被迫开始使用 swap，那么使用 swap 其实就已经意味着你正在危险的边缘徘徊了，而且使用 swap 往往总伴随一些 IO 问题。附赠一个命令<code>swapoff -a &amp;&amp; swapon -a</code></p>
<h3 id="虚拟内存和缓存"><a href="#虚拟内存和缓存" class="headerlink" title="虚拟内存和缓存"></a>虚拟内存和缓存</h3><p>这个不是个问题，但是需要提一句，有的时候有人会看到 VIRT 占用很多，或者缓存和缓冲占用很多，其实这个问题都不大。虚拟内存你占了但是并没有实际分配，缓存和缓冲往往都是内核为了加快访问而做的，当内存不够时会主动进行释放不用担心。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内存问题一般就两种：</p>
<ul>
<li>一种你是干的（我就要需要那么多内存但其实你没有）</li>
<li>一种你无意识干的（我不用那么多但是实际用了没还）</li>
</ul>
<p>当出现内存问题时还是要多加注意，针对不同的语言也有不同的处理思路，java 看看虚拟机，go 看看 pprof 等等。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>你的网络还好吗</title>
    <url>/post/8fbd221e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前说了 CPU、内存 、IO 在排查过程中可能出现的问题以及出现问题会影响的指标，这次就来看看在 linux 中网络的问题。</p>
<p>在实际中我们遇到的最多的网络问题就是：不通！！！无论是 ping 不通，物理链路不通，还是 dns 解析有问题导致的不通，还是容器间网络访问网络隔离造成的不通，等等，这个问题总是由于部署上的环境导致的。还有一类比较烦的问题就是网络带宽本来就不高的情况下，大量的请求导致网络的拥塞，最明显的感受就是接口请求超时，各种超时，nginx 超时，请求本身超时等等。对于这些问题如何进行排查呢？</p>
<span id="more"></span>
<h2 id="诊断指标"><a href="#诊断指标" class="headerlink" title="诊断指标"></a>诊断指标</h2><h3 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><code>sar -n DEV 1</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@Linkin ~]<span class="comment"># sar -n DEV 1</span></span><br><span class="line">Linux 3.10.0-1062.9.1.el7.x86_64 (Linkin) 	07/04/2020 	_x86_64_	(2 CPU)</span><br><span class="line"></span><br><span class="line">03:03:40 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">03:03:41 PM br-22dd849a79f5      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">03:03:41 PM br-dac186ab0c70      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">03:03:41 PM veth860c89a      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">03:03:41 PM      eth0      5.00      4.00      0.30      2.43      0.00      0.00      0.00</span><br><span class="line">03:03:41 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">03:03:41 PM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><p>这个命令可以清楚的看到整体的网络吞吐情况</p>
<p>rxpck/s、 txpck/s  接收和发送的 PPS 包 / 秒</p>
<p>rxkB/s、txkB/s 接收和发送的吞吐量 KB/ 秒</p>
<h3 id="iperf3"><a href="#iperf3" class="headerlink" title="iperf3"></a>iperf3</h3><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p>用于测试网速、带宽</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -s 表示启动服务端，-i 表示汇报间隔，-p 表示监听端口</span></span><br><span class="line">$ iperf3 -s -i 1 -p 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># -c 表示启动客户端，192.168.10.30 为目标服务器的 IP</span></span><br><span class="line"><span class="comment"># -b 表示目标带宽 (单位是 bits/s)</span></span><br><span class="line"><span class="comment"># -t 表示测试时间</span></span><br><span class="line"><span class="comment"># -P 表示并发数，-p 表示目标服务器监听端口</span></span><br><span class="line">$ iperf3 -c 192.168.10.30 -b 1G -t 15 -P 2 -p 10000</span><br></pre></td></tr></table></figure>
<h3 id="nslookup-amp-dig"><a href="#nslookup-amp-dig" class="headerlink" title="nslookup &amp; dig"></a>nslookup &amp; dig</h3><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p>千万不要小看 DNS 的问题，很多时候 DNS 解析会出现很多问题，特别是有 DNS 缓存的时候</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install bind-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">nslookup www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># +trace 表示开启跟踪查询</span></span><br><span class="line"><span class="comment"># +nodnssec 表示禁止 DNS 安全扩展</span></span><br><span class="line">dig +trace +nodnssec www.baidu.com</span><br><span class="line">dig linkinstar.com @localhost</span><br></pre></td></tr></table></figure>
<h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p>这个抓包工具可太强大了，命令参数也很多，举例常用的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -i eth0 指定网卡</span></span><br><span class="line"><span class="comment"># -nn host 10.0.2.1 主机过滤</span></span><br><span class="line"><span class="comment"># -nn tcp 协议过滤</span></span><br><span class="line"><span class="comment"># -nn dst port 80 端口过滤</span></span><br></pre></td></tr></table></figure>
<h2 id="内核参数修改提及"><a href="#内核参数修改提及" class="headerlink" title="内核参数修改提及"></a>内核参数修改提及</h2><p>其实很多网络优化的参数都是可以通过修改 linux 内核参数进行调优</p>
<p><code>vi /etc/sysctl.conf</code></p>
<p>但是这里的调整可太讲究了，涉及的知识点太多，缓冲区最大值、队列长度等等，其实我的建议是，要不就直接不动，等到有问题再说，要不就直接交给有经验的运维搞定，直接复制网上的配置文件覆盖不太可取，万一出现问题不知道如何进行处理。</p>
<h2 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h2><ol>
<li>保证网络通，那肯定一上来最靠谱的就是 ping 了，网络要是都不通的话，那就没啥好说的了</li>
<li>查看网络请求情况，就是看，现在网络是否确实请求量很大，或者说请求数量很多，或者带宽资源不足等情况</li>
<li>查看网络资源状态，查看当前有多少连接数，各个 TCP\UDP 连接状态是否正常，很大程度上就能反映出问题</li>
</ol>
<h2 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h2><p>其实网络导致的问题可以分为两种：</p>
<ol>
<li>不通</li>
<li>卡了</li>
</ol>
<p>但是导致这两种情况出现的原因纷繁复杂，太多无厘头的问题出现了，导致网络一直是 linux 里面的一座大山。</p>
<p>下面举例说几种现实中出现过的情况。</p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>几乎所有的人都会被这个玩意坑过一次，长记性之后又会被坑第二次。</p>
<p>第一次玩 linux 服务器的时候就被这个玩意坑了一天，所有东西查到最后，发现防火墙没关，或者端口没开放，导致无法访问。</p>
<p>第二次是云服务器坑了一波，服务器的防火墙是关了，但是云厂商有着自己的安全策略规则，你必须手动去网页上开放进行设置。</p>
<h3 id="DNS-解析问题"><a href="#DNS-解析问题" class="headerlink" title="DNS 解析问题"></a>DNS 解析问题</h3><p>这里分为两种，一种是外网的 DNS 解析，这种要不就是 DNS 服务器没配置，要不就是 DNS 解析服务器确实有问题。</p>
<p>一种是内网的 DNS 解析，因为内网里面也会使用 DNS 进行访问和请求，这个时候很多时候就会出现问题，一般就是 ping 不通，然后就用 dig 进行查。</p>
<p>还有就是前面的 LB 层，也就是如 NGINX 这样的负载均衡上缓存了 DNS 解析，当后面的 IP 更换导致负载出现问题。</p>
<h3 id="大量-TIME-WAIT"><a href="#大量-TIME-WAIT" class="headerlink" title="大量 TIME_WAIT"></a>大量 TIME_WAIT</h3><p>出现原因是程序 bug，大量客户端请求后异常关闭，说 TCP 的时候这个状态之前说过，这里就不再详述了。</p>
<h3 id="大量-SYN-RECV"><a href="#大量-SYN-RECV" class="headerlink" title="大量 SYN_RECV"></a>大量 SYN_RECV</h3><p>可能由于 SYN FLOOD 攻击导致，那这个调内核参数可以缓解，但是如果真的是外网部署遇到这样的情况，如果出现频繁，优先考虑封 IP，云厂商的服务或者 CDN</p>
<h3 id="容器间网络不通"><a href="#容器间网络不通" class="headerlink" title="容器间网络不通"></a>容器间网络不通</h3><p>虽然现在又 K8S 这样的容器编排，但在这之前容器间的网络总是有着各种问题，无论是使用 host 网络，还是网桥，总之网络不通服务无法访问，总是存在，这个时候抓包往往就成了最靠谱的解决方案。ping，然后直接抓 icmp 包，一个个抓过来，eth0，docker0，flannel0…</p>
<h3 id="请求过多"><a href="#请求过多" class="headerlink" title="请求过多"></a>请求过多</h3><p>其实很多时候，网络上的问题就是请求发过去相应时间过长了，导致用户感受就是卡，而卡在网络情况不好的时候反映尤为明显，需要注意的是，有的时候带宽资源占满，你可能连服务器都无法进行登录了。</p>
<p>这个时候你需要做的就是分析出现这样情况的原因，多数情况下都是由于最底层的数据查询有问题，导致 IO 瓶颈等，一般来说，优化数据库查询时间往往成为了解决问题的关键。其次就是缓存，这个往往马上就能瞬间提升性能。最后就是，要做好安全和限流工作，再怎么说服务器总是有瓶颈的，如果用户之间压你的服务，就是想把你带宽占满，如果没有做好合理的安全策略和限流工作，恐怕很快就凉了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网络就是制定了各种协议，将数据封装成各种样子，以便能稳定的在网络中传输。我们学习网络协议和原理的目的是为了在出现问题的时候尽快能定位到问题，避免问题的发生。</p>
<p>上学的时候，老师曾经就和我们说过，一个网络工程师去现场，就是原来是 ping 不通的，但是搞一搞，最后通了，工作就完成了。但看似简单的背后，其实藏着各种各样的复杂问题，端口，协议，dns其中的任何一个步骤都会导致问题。</p>
<p>所以在遇到网络问题的时候也不要慌张，一步步来，从头走到尾，总能发现最后的问题。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang用300行代码实现内网穿透</title>
    <url>/post/34237eb6.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我们经常会遇到一个问题，如何将本机的服务暴露到公网上，让别人也可以访问。我们知道，在家上网的时候我们有一个 IP 地址，但是这个 IP 地址并不是一个公网的 IP 地址，别人无法通过一个 IP 地址访问到你的服务，所以在例如：微信接口调试、三方对接的时候，你必须将你的服务部署到一个公网的系统中去，这样太累了。</p>
<p>这个时候，内网穿透就出现了，它的作用就是即使你在家的服务，也能被其人访问到。</p>
<p>今天让我们来用一个最简单的案例学习一下如何用 go 来做一个最简单的内网穿透工具。</p>
</blockquote>
<span id="more"></span>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>首先我们用几张图来说明一下我们是如何实现的，说清楚之后再来用代码实现一下。</p>
<h3 id="当前网络情况"><a href="#当前网络情况" class="headerlink" title="当前网络情况"></a>当前网络情况</h3><p><img src="http://blog.linkinstars.com//blog/image-20200408225714549.png" alt="当前网络情况"></p>
<p>我们可以看到，画实线的是我们当前可以访问的，画虚线的是我们当前无法进行直接访问的。</p>
<p>我们现在有的路是：</p>
<ol>
<li>用户主动访问公网服务器是可以的</li>
<li>内网主动访问公网服务也是可以的</li>
</ol>
<p>当前我们要做的是想办法能让用户访问到内网服务，所以如果能做到公网服务访问到内网服务，那么用户就能间接访问到内网服务了。</p>
<p>想是这么想的，但是实际怎么做呢？用户访问不到内网服务，那我公网服务器同样访问不到吧。所以我们就需要利用现有的链路来完成这件事。</p>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p><img src="http://blog.linkinstars.com//blog/image-20200408232311358.png" alt="image-20200408232311358"></p>
<ul>
<li>内网，客户端（我们要搞一个）</li>
<li>外网，服务端（我们也要搞一个）</li>
<li>访问者，用户</li>
</ul>
<ol>
<li>首先我们需要一个控制通道来传递消息，因为只有内网可以访问公网，公网不知道内网在哪里，所以第一次肯定需要客户端主动告诉服务端我在哪</li>
<li>服务端通过 8007 端口监听用户来的请求</li>
<li>当用户发来请求时，服务端需要通过控制信道告诉客户端，有用户来了</li>
<li>客户端收到消息之后建立隧道通道，主动访问服务端的 8008 来建立 TCP 连接</li>
<li>此时客户端需要同时与本地需要暴露的服务 127.0.0.1:8080 建立连接</li>
<li>连接完成后，服务端需要将 8007 的请求转发到隧道端口 8008 中</li>
<li>客户端从隧道中获得用户请求，转发给内网服务，同时将内网服务的返回信息放入隧道</li>
</ol>
<p>最终请求流向是，如图中的紫色箭头走向，请求返回是如图中红色箭头走向。</p>
<p>需要理解的是，TCP 一旦建立了连接，双方就都可以向对方发送信息了，所以其实原理很简单，就是利用已有的单向路建立 TCP 连接，从而知道对方的位置信息，然后将请求进行转发即可。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h3><p>首先我们先定义三个需要使用的工具方法，还需要定义两个消息编码常量，后面会用到</p>
<ol>
<li>监听一个地址对应的 TCP 请求 <code>CreateTCPListener</code></li>
<li>连接一个 TCP 地址 <code>CreateTCPConn</code> </li>
<li>将一个 TCP-A 连接的数据写入另一个 TCP-B 连接，将 TCP-B 连接返回的数据写入 TCP-A 的连接中 <code>Join2Conn</code> （别看这短短 10 几行代码，这就是核心了）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> network</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;io&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   KeepAlive     = <span class="string">&quot;KEEP_ALIVE&quot;</span></span><br><span class="line">   NewConnection = <span class="string">&quot;NEW_CONNECTION&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTCPListener</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="params">(*net.TCPListener, error)</span></span> &#123;</span><br><span class="line">   tcpAddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   tcpListener, err := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, tcpAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tcpListener, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTCPConn</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="params">(*net.TCPConn, error)</span></span> &#123;</span><br><span class="line">   tcpAddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   tcpListener, err := net.DialTCP(<span class="string">&quot;tcp&quot;</span>,<span class="literal">nil</span>, tcpAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tcpListener, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join2Conn</span><span class="params">(local *net.TCPConn, remote *net.TCPConn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> joinConn(local, remote)</span><br><span class="line">   <span class="keyword">go</span> joinConn(remote, local)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joinConn</span><span class="params">(local *net.TCPConn, remote *net.TCPConn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> local.Close()</span><br><span class="line">   <span class="keyword">defer</span> remote.Close()</span><br><span class="line">   _, err := io.Copy(local, remote)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">&quot;copy failed &quot;</span>, err.Error())</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>我们先来实现相对简单的客户端，客户端主要做的事情是 3 件：</p>
<ol>
<li>连接服务端的控制通道</li>
<li>等待服务端从控制通道中发来建立连接的消息</li>
<li>收到建立连接的消息时，将本地服务和远端隧道建立连接（这里就要用到我们的工具方法了）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bufio&quot;</span></span><br><span class="line">   <span class="string">&quot;io&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;nat-proxy/cmd/network&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   <span class="comment">// 本地需要暴露的服务端口</span></span><br><span class="line">   localServerAddr = <span class="string">&quot;127.0.0.1:32768&quot;</span></span><br><span class="line"></span><br><span class="line">   remoteIP = <span class="string">&quot;111.111.111.111&quot;</span></span><br><span class="line">   <span class="comment">// 远端的服务控制通道，用来传递控制信息，如出现新连接和心跳</span></span><br><span class="line">   remoteControlAddr = remoteIP + <span class="string">&quot;:8009&quot;</span></span><br><span class="line">   <span class="comment">// 远端服务端口，用来建立隧道</span></span><br><span class="line">   remoteServerAddr  = remoteIP + <span class="string">&quot;:8008&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   tcpConn, err := network.CreateTCPConn(remoteControlAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">&quot;[连接失败]&quot;</span> + remoteControlAddr + err.Error())</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   log.Println(<span class="string">&quot;[已连接]&quot;</span> + remoteControlAddr)</span><br><span class="line"></span><br><span class="line">   reader := bufio.NewReader(tcpConn)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      s, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> || err == io.EOF &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当有新连接信号出现时，新建一个tcp连接</span></span><br><span class="line">      <span class="keyword">if</span> s == network.NewConnection+<span class="string">&quot;\n&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">go</span> connectLocalAndRemote()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Println(<span class="string">&quot;[已断开]&quot;</span> + remoteControlAddr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectLocalAndRemote</span><span class="params">()</span></span> &#123;</span><br><span class="line">   local := connectLocal()</span><br><span class="line">   remote := connectRemote()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> local != <span class="literal">nil</span> &amp;&amp; remote != <span class="literal">nil</span> &#123;</span><br><span class="line">      network.Join2Conn(local, remote)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> local != <span class="literal">nil</span> &#123;</span><br><span class="line">         _ = local.Close()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> remote != <span class="literal">nil</span> &#123;</span><br><span class="line">         _ = remote.Close()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectLocal</span><span class="params">()</span> *<span class="title">net</span>.<span class="title">TCPConn</span></span> &#123;</span><br><span class="line">   conn, err := network.CreateTCPConn(localServerAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">&quot;[连接本地服务失败]&quot;</span> + err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectRemote</span><span class="params">()</span> *<span class="title">net</span>.<span class="title">TCPConn</span></span> &#123;</span><br><span class="line">   conn, err := network.CreateTCPConn(remoteServerAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">&quot;[连接远端服务失败]&quot;</span> + err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> conn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端的实现就相对复杂一些了：</p>
<ol>
<li>监听控制通道，接收客户端的连接请求</li>
<li>监听访问端口，接收来自用户的 http 请求</li>
<li>第二步接收到请求之后需要存放一下这个连接并同时发消息给客户端，告诉客户端有用户访问了，赶紧建立隧道进行通信</li>
<li>监听隧道通道，接收来自客户端的连接请求，将客户端的连接与用户的连接建立起来（也是用工具方法）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;nat-proxy/cmd/network&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   controlAddr = <span class="string">&quot;0.0.0.0:8009&quot;</span></span><br><span class="line">   tunnelAddr  = <span class="string">&quot;0.0.0.0:8008&quot;</span></span><br><span class="line">   visitAddr   = <span class="string">&quot;0.0.0.0:8007&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   clientConn         *net.TCPConn</span><br><span class="line">   connectionPool     <span class="keyword">map</span>[<span class="keyword">string</span>]*ConnMatch</span><br><span class="line">   connectionPoolLock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConnMatch <span class="keyword">struct</span> &#123;</span><br><span class="line">   addTime time.Time</span><br><span class="line">   accept  *net.TCPConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   connectionPool = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*ConnMatch, <span class="number">32</span>)</span><br><span class="line">   <span class="keyword">go</span> createControlChannel()</span><br><span class="line">   <span class="keyword">go</span> acceptUserRequest()</span><br><span class="line">   <span class="keyword">go</span> acceptClientRequest()</span><br><span class="line">   cleanConnectionPool()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个控制通道，用于传递控制消息，如：心跳，创建新连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createControlChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">   tcpListener, err := network.CreateTCPListener(controlAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Println(<span class="string">&quot;[已监听]&quot;</span> + controlAddr)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      tcpConn, err := tcpListener.AcceptTCP()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Println(err)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log.Println(<span class="string">&quot;[新连接]&quot;</span> + tcpConn.RemoteAddr().String())</span><br><span class="line">      <span class="comment">// 如果当前已经有一个客户端存在，则丢弃这个链接</span></span><br><span class="line">      <span class="keyword">if</span> clientConn != <span class="literal">nil</span> &#123;</span><br><span class="line">         _ = tcpConn.Close()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         clientConn = tcpConn</span><br><span class="line">         <span class="keyword">go</span> keepAlive()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和客户端保持一个心跳链接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepAlive</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> clientConn == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         _, err := clientConn.Write(([]<span class="keyword">byte</span>)(network.KeepAlive + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;[已断开客户端连接]&quot;</span>, clientConn.RemoteAddr())</span><br><span class="line">            clientConn = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听来自用户的请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acceptUserRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">   tcpListener, err := network.CreateTCPListener(visitAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> tcpListener.Close()</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      tcpConn, err := tcpListener.AcceptTCP()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      addConn2Pool(tcpConn)</span><br><span class="line">      sendMessage(network.NewConnection + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将用户来的连接放入连接池中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addConn2Pool</span><span class="params">(accept *net.TCPConn)</span></span> &#123;</span><br><span class="line">   connectionPoolLock.Lock()</span><br><span class="line">   <span class="keyword">defer</span> connectionPoolLock.Unlock()</span><br><span class="line"></span><br><span class="line">   now := time.Now()</span><br><span class="line">   connectionPool[strconv.FormatInt(now.UnixNano(), <span class="number">10</span>)] = &amp;ConnMatch&#123;now, accept,&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给客户端新消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> clientConn == <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">&quot;[无已连接的客户端]&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   _, err := clientConn.Write([]<span class="keyword">byte</span>(message))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">&quot;[发送消息异常]: message: &quot;</span>, message)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收客户端来的请求并建立隧道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acceptClientRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">   tcpListener, err := network.CreateTCPListener(tunnelAddr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> tcpListener.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      tcpConn, err := tcpListener.AcceptTCP()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">go</span> establishTunnel(tcpConn)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">establishTunnel</span><span class="params">(tunnel *net.TCPConn)</span></span> &#123;</span><br><span class="line">   connectionPoolLock.Lock()</span><br><span class="line">   <span class="keyword">defer</span> connectionPoolLock.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> key, connMatch := <span class="keyword">range</span> connectionPool &#123;</span><br><span class="line">      <span class="keyword">if</span> connMatch.accept != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">go</span> network.Join2Conn(connMatch.accept, tunnel)</span><br><span class="line">         <span class="built_in">delete</span>(connectionPool, key)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   _ = tunnel.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanConnectionPool</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      connectionPoolLock.Lock()</span><br><span class="line">      <span class="keyword">for</span> key, connMatch := <span class="keyword">range</span> connectionPool &#123;</span><br><span class="line">         <span class="keyword">if</span> time.Now().Sub(connMatch.addTime) &gt; time.Second*<span class="number">10</span> &#123;</span><br><span class="line">            _ = connMatch.accept.Close()</span><br><span class="line">            <span class="built_in">delete</span>(connectionPool, key)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      connectionPoolLock.Unlock()</span><br><span class="line">      time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>其中我加入了 keepalive 的消息，用于保持客户端与服务端的一直正常连接</li>
<li>我们还需要定期清理一下服务端 map 中没有建立成功的连接</li>
</ul>
<h2 id="实验一下"><a href="#实验一下" class="headerlink" title="实验一下"></a>实验一下</h2><p>首先在本机用 dokcer 部署一个 nginx 服务（你可以启动一个 tomcat 都可以的），并修改客户监听端口localServerAddr为127.0.0.1:32768，并修改remoteIP 为服务端 IP 地址。然后访问以下，看到是可以正常访问的。</p>
<p><img src="http://blog.linkinstars.com//blog/image-20200408223531645.png" alt="image-20200408223531645"></p>
<p>然后编译打包服务端扔到服务器上启动、客户端本地启动，如果控制台输出连接成功，就完成准备了</p>
<p>现在通过访问服务端的 8007 端口就可以访问我们内网的服务了。</p>
<p><img src="http://blog.linkinstars.com//blog/image-20200408223550812.png" alt="image-20200408223550812"></p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>上述的实现是一个最小的实现，也只是为了完成基本功能，还有一些遗留的问题等待你的处理：</p>
<ul>
<li>现在一个客户端连接上了就不能连接第二个了，那怎么做多个客户端的连接呢？</li>
<li>当前这个 map 的使用其实是有风险的，如何做好连接池的管理？</li>
<li>TCP 连接的开销是很大的，如何做好连接的复用？</li>
<li>当前是 TCP 的连接，那么如果是 UDP 如何实现呢？</li>
<li>当前连接都是不加密的，如何进行加密呢？</li>
<li>当前的 keepalive 实现很简单，有没有更优雅的实现方式呢？</li>
</ul>
<p>这些就交给聪明的你来完成了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实最后回头看看实现起来并不复杂，用 go 来实现已经是非常简单了，所以 github 上面有很多利用 go 来实现代理或者穿透的工具，我也是参考它们抽离了其中的核心，最重要的就是工具方法中的第三个 copy 了，不过其实还有很多细节点需要考虑的。你可以参考下面的源码继续深入探索一下。</p>
<p><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<p><a href="https://github.com/snail007/goproxy">https://github.com/snail007/goproxy</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>nat</tag>
      </tags>
  </entry>
  <entry>
    <title>回首网络知识之 UDP 协议</title>
    <url>/post/d7b70ffe.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>最近开始在恶补网络知识，算是一个复习，在学习了很多上层建筑之后回来看看之前的基础确实又有一个新的认识。一开始准备看完之后做一个整体的总结，但是发现知识点太多所以分了几期来写，每期都会短一点，这期我们先来简单了解一下 UDP</p>
</blockquote>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传输层中重要的两个协议 UDP 和 TCP ，在平时的时候，你虽然一直用着他们，但是往往感受不到他们的存在，他们两个往往经常会在面试的时候出现，打你一个措手不及。</p>
<p>在学习它之前，你首先要有一个概念，为什么我们需要 UDP 或者 TCP 这样的协议，它到底是在什么时候，什么地方，帮我们完成了什么样的事情？</p>
<ul>
<li>在网络，我们研究的往往都是如何以一种合理的方式传递数据</li>
</ul>
<p>而且协议则指定了这样的规定，当双方都遵守这样的规定，才能看懂互相说的话，才能达到合理传递数据的目的。</p>
<h2 id="UDP-怎么样"><a href="#UDP-怎么样" class="headerlink" title="UDP 怎么样"></a>UDP 怎么样</h2><ul>
<li>UDP 格式简单，没有花里胡哨的东西</li>
<li>UDP 不会先探路，而是直接就发上了</li>
<li>UDP 不会管你卡不卡，发给你我就不管了</li>
</ul>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><table>
<thead>
<tr>
<th style="text-align:center">源端口号（16 位，2 字节）</th>
<th style="text-align:center">目的端口（16 位，2 字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UDP 长度（16 位，2 字节）</td>
<td style="text-align:center">UDP 校验和（16 位，2 字节）</td>
</tr>
<tr>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
</tr>
</tbody>
</table>
<p>我们可以看到，UDP 的报文真的是很简单，除了简单的对于数据做了校验，就是必要的端口号，没了。</p>
<h2 id="UDP-对比-TCP"><a href="#UDP-对比-TCP" class="headerlink" title="UDP 对比 TCP"></a>UDP 对比 TCP</h2><p>其实这两者区别巨大，但是你要明白的是为什么会有这样的区别。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>如果有人问，<code>TCP 和 UDP 的区别？</code> 很多时候会得到的第一个答案就是告诉你，TCP 是面向连接的，而 UDP 是面向无连接的。那么问题来了，是说 UDP 不需要网络连接吗？那 UDP 的包不通过网络连接怎么发送的呢？</p>
<p>其实，这里所谓的连接是指，<strong> 客户端和服务端是否有在维护双方通信的状态 </strong>，如果维护了这样的状态，那么对于服务端来说我很清楚现在的局势状况，客户端发了多少数据了，是否需要断开了，是否有丢数据了等等。</p>
<h3 id="可靠"><a href="#可靠" class="headerlink" title="可靠"></a>可靠</h3><p>TCP 为什么说它可靠，而 UDP 不可靠呢？</p>
<p>也很简单，你看报文格式就很清楚，UDP 没有做过多的校验，对于 UDP 的包来说，重复了，没收到都是这样的事情出现都是完全不清楚的。</p>
<p>而 TCP 就可靠很多了，它的报文格式恐怕要你背，你可能就要想想了吧，它需要很多东西去控制，去保证有序、无差错、不丢失、不重复。</p>
<h3 id="字节流-和-数据报"><a href="#字节流-和-数据报" class="headerlink" title="字节流 和 数据报"></a>字节流 和 数据报</h3><p>TCP 是面向字节流的，发送的时候一个流就过来了，而 UDP 是数据报的，一个个来的</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>这个也很好理解，TCP 因为他知道的多，他很清楚当前局势，网络状况，从而会主动控制发送的频率，而 UDP 它啥也不知道，没办法控制发送频率，它都不知道别人收到了没有，只管发就完事了。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>那么 UDP 那么不靠谱，那什么情况下会用到这个协议呢？之前都一直在说 UDP 和 TCP 比有什么不好的地方，但是它有着别人无法相比的优点，那就是快。</p>
<h3 id="内网环境"><a href="#内网环境" class="headerlink" title="内网环境"></a>内网环境</h3><p>很多时候在内网环境，网络条件是很好的，又能两个设备之间就经过了一个路由器而已，相比于互联网中纷繁复杂的世界，这个时候丢包的可能性就很小了。那么这个时候为了速度，使用 UDP 就是很好的选择</p>
<ul>
<li>DHCP 动态主机配置协议，在分配 IP 地址的时候显然肯定是内网，用 UDP 再好不过了</li>
<li>TFTP 简单文件传输协议，当使用 PXE 方式安装操作系统时，当 DHCP 返回 PXE 服务器地址，然后要做的就是下载镜像了，而镜像一般都挺大的，而这个时候使用 UDP 很合适</li>
<li>SNMP 简单网络管理协议，用它可以管理网络中的很多设备，获取这些设备的状态，当然这些网络设备都是在内网的一个安全环境下</li>
</ul>
<h3 id="速度-amp-实时性"><a href="#速度-amp-实时性" class="headerlink" title="速度 &amp; 实时性"></a>速度 &amp; 实时性</h3><p>很多时候我们对于速度和实时性有要求，而又对丢失一两个数据并不在意的时候就会用到 UDP，你可能会好奇有这样的场景吗？有的</p>
<ul>
<li>直播，如果丢了其中某一帧的画面并不影响用户整体观看，而如果我非要等到这一帧的数据重传给我，那肯定就卡了。</li>
<li>FPS 游戏，对于实时性要求要的游戏，很多时候都会在协议上好好的做文章，因为会非常影响用户体验，同样的，如果中间有数据丢了，不能等着这个数据重发给我，否则等数据回来早就被别人打死了。</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>因为 UDP 几乎什么都没有，所以它就能被改成你想要的样子，如果你觉得当前可靠性不够，你可以自己在上层继续实现如：重传、拥塞控制等功能来扩展。</p>
<ul>
<li><code>QUIC</code> 快速 UDP 互联网连接，google 提出的使用 UDP 进行多路并发传输的协议，基于 UDP 的一个协议，有 TLS，有 HTTP2，利用缓存减少连接时间等等</li>
</ul>
<h2 id="不只是-UDP"><a href="#不只是-UDP" class="headerlink" title="不只是 UDP"></a>不只是 UDP</h2><p>当然应用层的其实有的协议并不只是使用简单的一个 UDP 或者 TCP 来实现，有的时候两者都会使用</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>这个是我们最常见的在应用层的一个协议了，我们知道在使用的时候可以通过指定参数来确实使用 UDP 或者 TCP 都可以。</p>
<p><code>int socket (int domain, int type, int protocol);</code></p>
<ul>
<li><p>其中 domain 表示 IP 层使用什么协议是 IPv4 还是 IPv6</p>
</li>
<li><p>type 表示 socket 类型，SOCK_STREAM 表示 TCP 面向流，SOCK_DGRAM 就是 UDP 面向数据报的，SOCK_RAW 直接操作 IP 层或者其他协议如 ICMP</p>
</li>
<li>protocol 表示的协议，IPPROTO_TCP 或者 IPPTOTO_UDP</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>当我们想通过一个域名访问一个网站时，第一步操作就是去找这个域名所对应的 IP 地址，而 DNS 就是这个功能。</p>
<p>绝大多数情况下，DNS 服务都是用的 UDP 来做的，因为快嘛，而且本身传递的消息也不多。</p>
<p>但是，因为 DNS 服务器之间是需要进行数据的一个同步或者迁移操作的，辅助 DNS 服务器会定时向主域名服务器同步变动，叫做区域传送，而这个时候数据量是有可能很大的，而且为了确保信息不丢失，使用 TCP 来保证才是一个不错的选择。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，UDP 还是非常简单的一个协议，没有过多的约束，从而在一些特定的情况下满足用户的需求。这里也体现了 trade-off ，速度还是可靠，要安全还是要性能，往往都是在权衡，也往往需要针对场景去选择。</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>回首网络知识之 TCP 协议</title>
    <url>/post/5c140909.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>之前我们说了 UDP 协议，也说到了 UDP 协议和 TCP 协议的对比，知道了 TCP 协议有那么一些复杂，所以这次就来仔细说说这个复杂的 TCP</p>
</blockquote>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提到 TCP 你第一想到的应该就是两个字 “靠谱”~ 因为它的所有设计都是围绕着这个任务展开的。</p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p><img src="http://blog.linkinstars.com//blog/image-20200321191551447.png" alt="TCP 报文格式"></p>
<p>很多人一看到这个就头疼了，因为格式好复杂啊，和 UDP 对比起来，怎么多了那么多东西呢？</p>
<p>别急，其实并不是很多，而且只要你想着为什么，你就知道会有什么。</p>
<ul>
<li>首先是两个端口，这个和 UDP 一样，肯定需要端口，不然的话不知道是发给谁的</li>
<li>然后是序号和确认序号，序号是为了解决乱序的问题，如果没有序号，那么我是不知道那个先那个后，同时我还要告诉对方我收到了这个序号的信息，所以需要一个确认序号，确认的方式是告诉你我要的下一个序号是多少</li>
<li>首部长度也很好理解，告诉你首部有多长，你就知道前面有多长，你才知道数据从哪里开始</li>
<li>中间那几个标识位需要知道的是：<ul>
<li>SYN：建立连接时用的，建立连接会标识为 1</li>
<li>ACK：回复你建立连接，建立连接之后标识为 1</li>
<li>RST：重新连接</li>
<li>FIN：结束连接</li>
</ul>
</li>
<li>窗口大小，接收方告诉发送方别发太快了或者太慢了，用于流量控制</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>这个问题已经在面试的时候被问烂了，总是有面试官喜欢问网络，而作为第一个开头炮，三次握手总是被提及。</p>
<p><img src="http://blog.linkinstars.com//blog/image-20200321201952258.png" alt="三次握手"></p>
<p>中间的标识位，可能就有人从来就没弄懂，可能即使懂了，也是靠死记硬背的，不复习肯定忘记。</p>
<p>其实没有那么玄乎啦。分两个部分来看：</p>
<ol>
<li>大写的 SYN 和 ACK 其实上面都已经说了，就是建立连接的时候，第一个给你的报文里面 SYN 标识位为 1 告诉你开始建立连接了，否则你怎么知道这次是建立连接呢？而 ACK 就是告诉你我收到了，可以建立连接了</li>
<li>而小写的 seq 和 ack 就更简单了，他们表示的就是上面说的序号，确认号 ack 为收到的 seq 序号 + 1</li>
</ol>
<p>需要注意的是，序号每次都是不一样的，它是一个 32 位的每 4ms 递增的一个值，为什么这样设计呢？是因为如果每次序号都从 1 开始，那么势必在多次发送或者重连之后导致序号重复，误以为收到的新的数据，其实是旧数据，只不过序号相同。</p>
<h3 id="为什么要三次"><a href="#为什么要三次" class="headerlink" title="为什么要三次"></a>为什么要三次</h3><p>等你描述的不清不楚的时候，面试官下一个问题就来了，为什么要做三次握手呢？</p>
<p>其实这个问题也不复杂，你时刻要记住网络其实很不稳定的，不是两根网线连接两边就好了，中间可能隔了一个太平洋。所以丢包太常见了。</p>
<p>而作为可靠的 TCP，<strong>三次握手能保证每个人都能有至少一次正反馈</strong>，对于发送方来说肯定有一问一答，对于接收方来说也有一问一答，否则都属于发了没反馈。</p>
<p>还有一个重要原因就是重试，如果由于网络原因，第一次建立连接迟迟收不到反馈，就会发第二个，而对于接收方来说，很有可能就会收到多个一模一样的建立连接的请求，如果只是一次或者两次，那么 <strong>就会建立很多无用的连接</strong> 占用资源。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p><img src="http://blog.linkinstars.com//blog/image-20200321204640147.png" alt="四次挥手"></p>
<p>其实当你把三次握手想清楚了，四次挥手也就不足为奇。对于四次挥手来说，其实就是从 SYN 表示位改到了 FIN 标识位，对于数据的序号还是一样的规则。只不过确实有几个要点需要注意。</p>
<ul>
<li>B 收到 FIN=1 的时候，此时 TCP 属于并关闭状态了，但是很有可能 B 还有数据需要发送，但是 A 收不收就是 A 自己决定了。</li>
<li>A 收到 FIN=1 回复了之后，还有一个 2MSL（最大报文存活时间）的 TIME-WAIT 状态</li>
</ul>
<h3 id="为什么要四次"><a href="#为什么要四次" class="headerlink" title="为什么要四次"></a>为什么要四次</h3><p>其实和建立连接时的原因一样：<strong>每个人都收到了一问一答</strong>，而建立连接时还没有正在发送的数据，所以中间那次可以复用，所以就三次了，而断开连接显然是一方主动发起的，而另一方是毫无准备的，就如同你关闭显示器，服务器是毫无准备的。</p>
<p>还有原因就是如果 A 告诉 B 之后直接走了，不管了，那么 B 就懵逼了，这个时候可能 B 还在发数据，B 就算发起结束，也没人回应了，B 就只能傻等着；如果 A 告诉 B，B 不管了，那么也有问题了，A 不知道 B 收到没有，B 如果没收到 A 还要继续发…</p>
<h3 id="为什么需要-TIME-WAIT"><a href="#为什么需要-TIME-WAIT" class="headerlink" title="为什么需要 TIME-WAIT"></a>为什么需要 TIME-WAIT</h3><p>这也是一个很奇怪的问题，明明都已经断开连接了，一直保持这个状态等着干啥？</p>
<ul>
<li>原因 1：如果这个时候不等了，直接断开连接，那最后一个挥手可能就到不了了</li>
<li>原因 2：如果等的时间短，直接关闭，因为关闭了，那么就可以和别人建立新的连接，那么很有可能还在网络上的老数据会跑到新的连接里面捣乱了</li>
</ul>
<h2 id="为了可靠你究竟做了什么"><a href="#为了可靠你究竟做了什么" class="headerlink" title="为了可靠你究竟做了什么"></a>为了可靠你究竟做了什么</h2><p>TCP 为了做一个可靠的人，付出了很多你看不见的努力</p>
<h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><ol>
<li><p>如果一个发送的报文在超时时间内没有收到确认，那么就会重新发送，<strong>超时时间并不是固定的</strong>，因为网络的环境不同，所以利用了一个 <strong>自适应重传算法</strong>，会根据当前的往返时间进行加权平均进行计算。</p>
</li>
<li><p>当然这样还是不够的，因为触发的周期还是太长，于是还有一个机制叫 <strong>快速重传</strong>，当接收方收到序号 5，但是现在还是要序号 3 的时候，那么会发送几个冗余的请求来要中间丢的报文。</p>
</li>
</ol>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>窗口在很多网络协议中都有被设计来控制流量，我们知道如果发的太猛不管客户端死活，或者发的太慢，让客户端饿死都是不好的。所以窗口的存在，就是维持一个返回，让你知道后面该不该往下发了，只有一家发送并得到一个确认，窗口才会移动或改变大小。</p>
<p>最重要的是，当窗口被设置为 0 时，则发送端就不能再发送数据了。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>流量控制是为了控制客户端和服务端的处理和发送速度，不至于压垮对方。而拥塞控制则是避免去压垮网络。说白了，可能你客户端处理能力很强，一收到处理，你怎么发都可以，但是网络带宽不允许你这么干。</p>
<p><img src="http://blog.linkinstars.com//blog/image-20200322213339816.png" alt="拥塞控制"></p>
<p>这个图是不是很熟悉？没错，只要你大学里面学过计算机网络，这个图太经典了，可能当时你都不理解它为什么要这么设计，一开始慢慢发，然后越来越快，然后进行拥塞控制，然后到超时，再慢开始。</p>
<p>慢开始、拥塞避免、快重传、快恢复就是拥塞控制所做的事情了。</p>
<p>注意的是，图中的第 4 个点就是上面说的快速重传 3 个冗余 ACK 来找到丢的报文，并且是从 5 开始的，并不是再慢开始。</p>
<blockquote>
<p>有个比喻很形象这里的控制，就像往一个管子里面倒水，你不知道管子中间多粗，总是先倒的很快；等水满出来了，哦，知道了，倒太快了，就慢一点，等水下去一点然后再开始倒。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实回头看看，是不是 TCP 并没有想象中的那么复杂。所以它的负责，它的所作所为都是为了成为一个可靠的人，面对现在复杂的社会网络环境，它不得不做一个可靠的人，如果没有它可靠的负责，可能我们聊天聊到一半消息不见了，也不是不可能的。</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个 nginx？caddy 自动 https 真香</title>
    <url>/post/51c3059c.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们通常在部署 web 服务的时候往往会选择 nginx 作为最前面的一个狠角色，它的性能和能力大家也是有目共睹的，反向代理负载均衡等等。而作为后起之秀 caddy 却不被人所熟知，不过渐渐的也开始展露头角。<br>今天我就来介绍这个 caddy ，为什么我会称它有可能成为下一个 nginx。</p>
<span id="more"></span>
<p>我先列举几个痛点你看下：</p>
<ol>
<li>nginx 的配置文件你是否感觉有时候有点臃肿</li>
<li>https 需要购买或者申请证书，然后配置是否觉得麻烦？</li>
<li>linux 下安装 nginx 需要部分依赖</li>
</ol>
<p>而 caddy 确实给我了一种眼前一亮的感觉。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>官网：<a href="https://caddyserver.com/">https://caddyserver.com/</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://caddyserver.com/docs/download">https://caddyserver.com/docs/download</a><br>安装很简单，直接下载对应的二进制文件即可，或者按照对应到操作系统去安装也可以。没有其他依赖。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><a href="https://caddyserver.com/docs/getting-started">https://caddyserver.com/docs/getting-started</a><br>一个命令就可以启动，caddy，默认会去当前目录下寻找 <code>Caddyfile</code> 配置文件，也可以通过 –config 去指定文件位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">caddy start</span><br><span class="line">caddy stop</span><br><span class="line">caddy reload</span><br></pre></td></tr></table></figure>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p><a href="https://caddyserver.com/docs/caddyfile/directives/reverse_proxy">https://caddyserver.com/docs/caddyfile/directives/reverse_proxy</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.xxxx.com &#123;</span><br><span class="line">  reverse_proxy /api/user* &#123;</span><br><span class="line">    to 192.168.1.101:9000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.xxxx.com &#123;</span><br><span class="line">  root * /home/linkinstar/www</span><br><span class="line">  file_server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="外网服务使用-https"><a href="#外网服务使用-https" class="headerlink" title="外网服务使用 https"></a>外网服务使用 https</h2><p><a href="https://caddyserver.com/docs/quick-starts/https">https://caddyserver.com/docs/quick-starts/https</a></p>
<p><a href="https://caddyserver.com/docs/automatic-https">https://caddyserver.com/docs/automatic-https</a></p>
<p>caddy 最让我惊讶的是自动的 https 功能，只要你有一个可以正常访问的域名，将域名指向你外网服务器对应的 ip，然后向上面一样配置好 Caddyfile，只要域名一致，https 就完成了，不需要你额外申请证书，不需要做其他任何的操作，真的很棒👍，可谓是懒人必备</p>
<p>原理是，它会去 <a href="https://letsencrypt.org/">https://letsencrypt.org/</a> 调用对应的接口去申请证书，这是一个免费证书的申请网站，</p>
<h2 id="本地使用-https-证书"><a href="#本地使用-https-证书" class="headerlink" title="本地使用 https 证书"></a>本地使用 https 证书</h2><p>当我们的一些内网服务器需要使用 https 证书的时候，怎么办呢？因为内网的服务器没有公网 IP，caddy 去 letsencrypt 申请证书的时候无法验证，所以需要曲线救国。前提你需要一个域名。<a href="https://zhuanlan.zhihu.com/p/63412372">https://zhuanlan.zhihu.com/p/63412372</a></p>
<h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><p>wget <a href="https://dl.eff.org/certbot-auto">https://dl.eff.org/certbot-auto</a><br>chmod a+x certbot-auto</p>
<p>certbot-auto –manual –preferred-challenges dns certonly</p>
<p>接下来根据提示依次输入域名,和一些提示，一般输入y表示同意即可，知道让你去添加一条 txt 解析记录并验证的时候</p>
<h3 id="将证书输出验证内容进行-dns-解析配置"><a href="#将证书输出验证内容进行-dns-解析配置" class="headerlink" title="将证书输出验证内容进行 dns 解析配置"></a>将证书输出验证内容进行 dns 解析配置</h3><p><img src="http://blog.linkinstars.com//blog/image-20210510233258107.png" alt="image-20210510233258107"></p>
<p>配置完成之后会在 /etc/letsencrypt/live/xxx.com 目录下生成对应的公钥私钥</p>
<h3 id="配置Caddyfile"><a href="#配置Caddyfile" class="headerlink" title="配置Caddyfile"></a>配置Caddyfile</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">xxx.com:<span class="number">443</span> &#123;</span><br><span class="line">  tls /etc/letsencrypt/live/xxx.com/cert.pem /etc/letsencrypt/live/xxx.com/privkey.pem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p><a href="https://caddy.community/t/siege-benchmarks-nginx-vs-caddy-identical-systems/2962">https://caddy.community/t/siege-benchmarks-nginx-vs-caddy-identical-systems/2962</a></p>
<p>从性能上来说，确实 nginx 要更胜一筹，而且官方也承认（毕竟 nginx 的设计就是干这个的）</p>
<p>不过从比较的数据上来说，能让普通用户使用很满意了，并没有一定需要追求极致的性能体验，毕竟免费的 https 已经有点香了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>caddy 发挥了 go 传统的优势安装没有依赖，使用方便</li>
<li>自动化的 https 证书的申请，很让人舒服</li>
<li>配置项更加清晰和简单，一目了然</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>性能比 nginx 略逊一筹</li>
<li>重启的时候 https 会重新申请，会有短暂的停顿</li>
<li>使用案例少了一些</li>
</ol>
<p>总的来说，如果你正需要一个免费方便的 https 的网关，那就试试 caddy 吧，一定不会让你失望的，而 caddy 也慢慢在发展，虽然从设计角度讲模型可能不如 nginx，但是从使用角度讲，可能我后续更偏爱 caddy 一些</p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://segmentfault.com/a/1190000022733237">https://segmentfault.com/a/1190000022733237</a></p>
]]></content>
      <categories>
        <category>caddy</category>
      </categories>
      <tags>
        <tag>caddy</tag>
      </tags>
  </entry>
  <entry>
    <title>细说docker - 容器技术</title>
    <url>/post/efc4bc95.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>docker对于现在的我们来说，已经是一个非常熟悉的东西了，docker无论是在部署打包，自动化，等方方面面都起着重要的作用，但是你是否有疑问，docker究竟是如何帮我们创建一个个隔离的环境的呢？今天我们就来看看，仔细说说docker</p>
<p>PS: 以下的讨论都限定在linux环境下，在windows和macos下容器技术实现不相同，不在讨论范围内。</p>
<span id="more"></span>
<h2 id="大方向"><a href="#大方向" class="headerlink" title="大方向"></a>大方向</h2><p>为什么先要提到这个词呢？因为所有在操作系统上运行的程序都叫做进程。docker也不例外，从大的方向来讲，<strong>docker就是帮你创建了一个进程而已</strong>。而不一样的是，docker通过限制了各种环境，就像给这个进程画了一个圈，所以在这个进程本身看来，它自己好像被隔离了一般。</p>
<ul>
<li>docker容器技术的核心，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”</li>
</ul>
<h2 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h2><p>那么我们有了大方向，那么来细细看看，首先的第一个问题就来了，docker是通过什么方法对这个进程进行限制的呢？</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>命名空间，没错就是它，是它限制了docker容器的环境。其实这是linux的一个功能而已，只不过没人想到docker会那它来做这个事情。下面看个例子，一下是我在一个nginx容器中利用ps命令查看的进程样子<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # ps -ef</span><br><span class="line">PID   USER     COMMAND</span><br><span class="line">    1 root     sh /start.sh</span><br><span class="line">    8 root     nginx: master process /usr/sbin/nginx</span><br><span class="line">    9 nobody   nginx: worker process</span><br><span class="line">   18 root     /bin/sh</span><br><span class="line">   25 root     ps -ef</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，PID是从1开始的，当前宿主机肯定也有PID为1的进程，这说明容器中所有的进程看起来好像和宿主机隔离了。其实这就是利用了 CLONE_NEWPID</p>
<p>我们知道，在linux下可以利用<br><code>clone(main_function, stack_size, SIGCHLD, NULL);</code><br>方法创建进程，如果同时你再参数中设定参数CLONE_NEWPID<br><code>clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</code> </p>
<p>那么新创建的进程就会在一个新的空间下，在这个空间中它自己的pid就是1；而其实在主机本身看来这个进程的pid还是一个别的数字。<br>由于新的进程在它自己的空间中认为自己是1号进程，所以看起来好像就和主机本身进程隔离的一样， 而其实只是它看不到别人罢了。这就是Namespace的作用。</p>
<p>同样的 CLONE_NEWCGROUP、CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER 和 CLONE_NEWUTS，通过这些选项我们就能创建出一些隔离于宿主机的网络，挂载点等等，从而实现了环境上的限制。</p>
<h3 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h3><p>当我们利用Namespace搞了一个相对隔离的环境，但是有些东西Namespace没有办法搞，比如CPU和内存。</p>
<p>我们知道如果使用vm等一些虚拟化软件进行虚拟机的创建你是可以给虚拟机设定cpu使用的核心数还有内存的使用量，来保证虚拟机不会超过使用的量而导致别的虚拟机无法使用。</p>
<p>而在docker容器中好像我们看似没有什么限制条件来约束一个容器的cpu和内存，如果没有约束那么很容易出现的问题就是，一个容器的运行吃掉了全部的cpu资源或者是一个容易的内存泄漏导致吃掉了整个服务器的内存资源，这是我们不希望看到的。</p>
<p>于是CGroups技术就是干这个事情的。CGroups其实叫做Linux Control Group，就是用来限制一个进程的使用个资源上限的，包括 CPU、内存、磁盘、网络带宽等等。</p>
<p>我们可以进入<code>/sys/fs/cgroup</code>这个目录下就能看到CGroups所有的限制都在里面了。</p>
<p>每一个 CGroup 下面都有一个 tasks 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，cpu.cfs_quota_us 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。</p>
<p>这里对于CGroups就不细说了，只要知道它能帮助我们限制这些就足够了。</p>
<h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>在namespace和cgroup的隔离之后，docker还有一个步骤需要做的是，如何去隔离文件系统。</p>
<p>因为即使开启了Mount Namespace 但是容器进程也能看到宿主机的文件系统，因为Mount Namespace修改的是容器进程对文件系统挂载点的认知，但是如果没有执行mount命令，那么当前还是使用的宿主机的文件系统，但这肯定不是我们想要的。</p>
<p>而在linux下有一个命令很好的解决了这个问题，那就是chroot。这个命令是 change root directory 的缩写，意思就是切换当前系统的root目录。我们知道在linux系统中根路径就是“/”，使用这个命令就可以切换我们的根路径变成别的路径。</p>
<p>docker就是使用chroot来实现说让docker容器所有在的目录的根目录进行修改，从而在容器角度看来是看不到宿主机的目录，因为它会认为自己这里就是根目录了。</p>
<p>对于chroot详细的介绍这里就不展开了，感兴趣可以查看：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/index.html">https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/index.html</a></p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>从上面我们已经可以知道，docker通过 namespace、cgroup、chroot 技术帮我们创建了一个拥有限制条件和隔离环境的进程，从而实现了一个容器，但是还有一个重要的技术在docker中也是至关重要的，那就是镜像。<br>在使用docker的时候，最方便的莫过于你可以通过docker build命令进行镜像的制作，然后将镜像推送到远端的仓库中去，任何机器只需要连接仓库拉取镜像就可以构建出一模一样的容器，那么镜像里面究竟放了什么东西呢？</p>
<h3 id="镜像的本质"><a href="#镜像的本质" class="headerlink" title="镜像的本质"></a>镜像的本质</h3><p>其实 docker 镜像本身就是一个压缩包，它将我们制作好的文件系统打包好了。<br>我们可以用 <code>docker export</code> 对镜像文件进行导出。我们会发现其实镜像中的目录结构和linux一样，其实就是一个文件系统。</p>
<h3 id="镜像分层技术"><a href="#镜像分层技术" class="headerlink" title="镜像分层技术"></a>镜像分层技术</h3><p>但是如果仅仅是做一个简单的文件打包的工作，那么你就太小看docker镜像本身了。</p>
<p>那说到实现，首先要说说 UnionFS（Union File System）它的功能非常简单，就是将多个不同位置的目录联合挂载到同一个目录下，并且如果目录下具有相同的文件会被合并。就是这个功能让docker实现了镜像这个东西。</p>
<p>当前我们在制作镜像的时候，在 docker-file 中每一条 docker 指令都会构建一个 lay，每个 lay 其实都是对已有的文件系统做一个操作，最终docker会把所有的 lay 通过 UnionFS 挂载到同一个目录下面，从而就实现了镜像分层后最终还是一个完整的文件系统的操作。<br><img src="http://blog.linkinstars.com/mweb/15781264508223.jpg" alt="-w834"></p>
<p>需要注意的是，当前我们在使用镜像的时候，我们在 run 一个 docker 之后里面的一些应用往往会对新创建的文件系统做出修改，如：创建日志文件。但是当我们删除这个容器的时候会发现，其实这个些创建的文件是不会被写入到镜像中去的。<br>这是因为，docker中的层是不一样的，有只读层，可读写层，init层。当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可读写层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。容器和镜像的区别就在于，所有的镜像都是只读层的，而每一个容器其实等于镜像加上一个可读写的层。<br><img src="http://blog.linkinstars.com/mweb/15781265788714.jpg" alt="-w1660"><br>这是我通过 dive 工具查看java这个docker镜像所示的东西，可以清楚的看到它的分层情况，是通过一层层叠加而来，而右边就是它的文件系统里面的样子了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Docker 使用namespace、cgroups、chroot画了一个圈，圈出了一个近乎独立的环境，而其本质还是一个进程。使用UnionFS来实现了镜像分层的整合，从而让docker镜像实现了分层构建。<br>总的来说，其实docker看起来非常厉害，启动一个容器飞快比传统的虚拟机好用了太多，在不知道实现原理的情况下，感觉很神奇。但是了解之后你会发现，其实docker运用的技术并不复杂，它只是将一些已有的技术做了一个整合，这些技术也并非docker去创造的，namespace、cgroups都是linux提供的功能罢了。但是在docker出现以前，谁能想到这些东西组合在一起就能碰撞出不一样的火花呢？</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手 dubbo-go</title>
    <url>/post/81d69338.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>每次技术调研总会发现自己学不动了怎么办？用已有的知识来拓展要学习的新知识就好了~ by LinkinStar<br>最近需要调研使用 dubbo，之前完全是 0 基础，对于 dubbo 只存在于听说，今天上手实战一把，告诉你如何快速用 go 上手 dubbo<br>PS：以下的学习方式适用于很多新技术  </p>
<span id="more"></span>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>首先学习一个技术首先要看看它的整体架构和基本概念</strong>，每个技术都有着自己的名词解释和实现方式，如果文档齐全就简单很多。</p>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/preface/background.html">http://dubbo.apache.org/zh-cn/docs/user/preface/background.html</a></p>
<p>大致浏览了背景、需求、架构之后基本上有一个大致概念</p>
<p><img src="http://blog.linkinstars.com//blog/1240-20200719222110766.png" alt="image.png"></p>
<p>其实整体架构和很多微服务的架构都是类似的，就是有一个注册中心管理所有的服务列表，服务提供方先向注册中心注册，而消费方向注册中心请求服务列表，通过服务列表调用最终的服务。总的来说 dubbo 将整个过程封装在了里面，而作为使用者的我们来说更加关心业务实现，它帮我们做好了治理的工作。</p>
<p>然后我抓住了几个我想要知道的重点：</p>
<ul>
<li>注册中心可替换，官方推荐的是 zk</li>
<li>如果有变更，注册中心将基于长连接推送变更数据给消费者，注册中心，服务提供者，服务消费者三者之间均为长连接</li>
<li>基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用</li>
<li>消费者在本地缓存了提供者列表</li>
</ul>
<h2 id="实际上手"><a href="#实际上手" class="headerlink" title="实际上手"></a>实际上手</h2><p>官网文档中也给出如果使用 golang 开发，那么有 <a href="https://github.com/apache/dubbo-go">https://github.com/apache/dubbo-go</a> 可以用，那么废话不多说，上手实践一把先。因为你看再多，都比不上实践一把来学的快。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>大多数教程就会跟你说，一个 helloWorld 需要 zookeeper 环境，但是不告诉你如何搭建，因为这对于他们来说太简单了，而我不一样，我是 0 基础，那如何快速搭建一个需要调研项目的环境呢？最好的方式就是 docker。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">  <span class="attr">admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/dubbo-admin</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://zookeeper:2181</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">  <span class="attr">admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">chenchuxin/dubbo-admin</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.registry.address=zookeeper://zookeeper:2181</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.admin.root.password=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dubbo.admin.guest.password=guest</span></span><br></pre></td></tr></table></figure>
<p>上面两个 docker-compose 文件一个是官方提供的管理工具，一个包含的是个人修改之后的管理工具，记住这里有个用户名密码是 root-root，看你喜欢</p>
<p>废话不多说，直接创建 docker-compose.yaml 然后 <code>docker-compose up</code> 你就得到了一个环境，棒👍</p>
<h3 id="样例下载"><a href="#样例下载" class="headerlink" title="样例下载"></a>样例下载</h3><p>有的技术会给出官方的实验样例，dubbo-go 也不例外</p>
<p><a href="https://github.com/apache/dubbo-samples">https://github.com/apache/dubbo-samples</a></p>
<p>里面包含了 go 和 java 的样例，有了它你就能快速上手了，把它下载到本地</p>
<h3 id="样例运行"><a href="#样例运行" class="headerlink" title="样例运行"></a>样例运行</h3><p>首先要做的第一步就是把 helloworld 给跑起来，进入 golang 目录，里面有个 README.md 看一下。然后开搞。</p>
<p>打开一个终端运行服务方</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=mac</span><br><span class="line"><span class="built_in">export</span> ENV=dev</span><br><span class="line"><span class="built_in">cd</span> helloworld/dubbo/go-server</span><br><span class="line">sh ./assembly/<span class="variable">$ARCH</span>/<span class="variable">$ENV</span>.sh</span><br><span class="line"><span class="built_in">cd</span> ./target/linux/user_info_server-0.3.1-20190517-0930-release</span><br><span class="line">sh ./bin/load.sh start</span><br></pre></td></tr></table></figure>
<p>打开另一个终端运行客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=mac</span><br><span class="line"><span class="built_in">export</span> ENV=dev</span><br><span class="line"><span class="built_in">cd</span> helloworld/dubbo/go-client</span><br><span class="line">sh ./assembly/<span class="variable">$ARCH</span>/<span class="variable">$ENV</span>.sh</span><br><span class="line"><span class="built_in">cd</span> ./target/linux/user_info_client-0.3.1-20190517-0921-release</span><br><span class="line">sh ./bin/load_user_info_client.sh start</span><br></pre></td></tr></table></figure>
<p>启动过程中会出现一些警告，问题不大，如果成功，那么客户端会有一个调用服务端的请求，并在控制台中以白色底色进行打印</p>
<p><img src="http://blog.linkinstars.com//blog/1240-20200719222118263.png" alt="image.png"></p>
<p>java 的服务也有相对应的启动方式，按照 README 中所说明的也可以进行注册和调用，并且 java 和 go 之间是可以互相调用的</p>
<h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><p>因为我们部署的时候有一个 dubbo-admin 用于管理 zk 上注册的服务，我们可以访问本地的 8080 端口看到对应的服务情况</p>
<p><img src="http://blog.linkinstars.com//blog/1240-20200719222122876.png" alt="image.png"></p>
<p>至此你应该已经对于整体的链路调用有一个大致的认识，结合之前官网文档的中的架构图，应该也清晰了。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>那么现在你已经运行起来了，那么势必就要来看看具体是如何进行使用的了。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端，也就是服务提供者；</p>
<p>位置在：<code>dubbo-samples/golang/helloworld/dubbo/go-server/app</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将服务进行注册</span></span><br><span class="line">config.SetProviderService(<span class="built_in">new</span>(UserProvider))</span><br><span class="line"><span class="comment">// 注册对象的hessian序列化</span></span><br><span class="line">hessian.RegisterPOJO(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>是不是看起来其实很简单，其实重点就是上面两句代码了</p>
<p>对于服务本身来说</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserProvider <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserProvider)</span> <span class="title">GetUser</span><span class="params">(ctx context.Context, req []<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*User, error)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;req:%#v&quot;</span>, req)</span><br><span class="line">	rsp := User&#123;<span class="string">&quot;A001&quot;</span>, <span class="string">&quot;Alex Stocks&quot;</span>, <span class="number">18</span>, time.Now()&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;rsp:%#v&quot;</span>, rsp)</span><br><span class="line">	<span class="keyword">return</span> &amp;rsp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserProvider)</span> <span class="title">Reference</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;UserProvider&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是需要实现下面那个接口就可以了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rpc service interface</span></span><br><span class="line"><span class="keyword">type</span> RPCService <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reference() <span class="keyword">string</span> <span class="comment">// rpc service id or reference id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一步骤不要忘记了是config.Load()，会加载配置文件的相关配置，不然你以为注册中心的地址等等是在哪里配置的呢？</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>看了服务端，其实客户端也就很简单了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">config.SetConsumerService(userProvider)</span><br><span class="line">hessian.RegisterPOJO(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>其实也是差不多的，也需要注册一个消费服务，并将序列化方式给注册上去</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := &amp;User&#123;&#125;</span><br><span class="line">err := userProvider.GetUser(context.TODO(), []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;A001&quot;</span>&#125;, user)</span><br></pre></td></tr></table></figure>
<p>使用也就很简单了，同样的也需要实现 Reference 接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserProvider <span class="keyword">struct</span> &#123;</span><br><span class="line">	GetUser <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req []<span class="keyword">interface</span>&#123;&#125;, rsp *User)</span> <span class="title">error</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserProvider)</span> <span class="title">Reference</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;UserProvider&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回头想想"><a href="#回头想想" class="headerlink" title="回头想想"></a>回头想想</h3><p>当我们看完了代码的上的使用，再回头想想 dubbo 的作用，你就会发现其实 dubbo 帮你做的事情真的屏蔽了很多。</p>
<ul>
<li>你不需要关心服务是怎么注册的</li>
<li>你不需要关心服务是怎么获取的</li>
<li>你不需要关系服务是怎么调用的</li>
<li>甚至序列化的过程都是基本透明的</li>
</ul>
<p>想对比来说，如果让你自己去是实现微服务，那是不是说，你需要实现服务的拉取，服务的负载均衡，服务的发现，序列化…..</p>
<p>这下你应该明白了 dubbo 是做什么的也就明白了它为什么会出现了</p>
<h2 id="其他能力"><a href="#其他能力" class="headerlink" title="其他能力"></a>其他能力</h2><p>当你学习了一个技术的基本使用之后，要学习其他的能力，以便在使用的过程中不会出现自己重复造轮子或者说有轮子没用到的情况，<a href="https://github.com/apache/dubbo-samples">https://github.com/apache/dubbo-samples</a> 不止有 helloworld 还要很多别的案例供你参考，你可以继续看看并进行试验。</p>
<h3 id="支持扩展"><a href="#支持扩展" class="headerlink" title="支持扩展"></a>支持扩展</h3><p><a href="https://github.com/apache/dubbo-go">https://github.com/apache/dubbo-go</a></p>
<p>在 Feature list 中列举了 dubbo-go 所支持的相关功能，比如序列化，比如注册中心，在比如过滤器。</p>
<p>也就是说，在使用 dubbo-go 的时候相关功能都是插件化的，想用什么就看你自己了，比如注册中心我想用 etcd，比如调用的协议我想换成 grpc 都可以。</p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p><strong>对于一个技术调研，那么肯定会有相关问题等着你去发现去考虑。</strong></p>
<p>下面是我能想到的一些问题：</p>
<ul>
<li>当前 dubbo-go 的版本最高在 1.4，所对应的 dubbo 版本应该是 2.6.x，如果调用更高版本的服务是否会有问题</li>
<li>java 和 go 之间互相调用，各种类型转换之间是否存在问题，是否容易出现无法正确反序列化的问题</li>
<li>….</li>
</ul>
<h2 id="后续学习"><a href="#后续学习" class="headerlink" title="后续学习"></a>后续学习</h2><p>那么上面只是说能让你上手 dubbo-go，但是实际使用可能存在距离。为什么这么说呢？如果你在不动里面任何的原理情况下，那么如果遇到问题，你很可能就束手无策了。比如如果线上服务无法正常发现，你应该如何排查？调用过程中出现问题如何定位？</p>
<p>所以后续你需要做的是：</p>
<ul>
<li>看看整体设计架构和思路，明白整条链路调用过程和规则</li>
<li>学习它的接口设计，为什么别人设计的接口能兼容那么多的注册中心？如果让你来设计你怎么设计呢？</li>
<li>性能也很重要，网上说性能很不错，为什么呢？什么地方做了优化，负载均衡的算法是怎么样的，你能自定义吗？</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，对于 dubbo-go 整体的使用上还是非常好上手的，自己想了一下，如果当前项目想要接入的话，主要是服务的暴露、序列化方式、鉴权调整等存在开发工作。</p>
<p>上面砖头也抛的差不多了，对于你快速上手应该没有问题了，剩下的就要靠你自己了。</p>
]]></content>
      <categories>
        <category>dubbo-go</category>
      </categories>
      <tags>
        <tag>dubbo-go</tag>
      </tags>
  </entry>
  <entry>
    <title>浅入深出ETCD之【简介与命令行使用】</title>
    <url>/post/b8206bb3.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>你知道etcd吗？随着k8s的使用广泛之后，etcd被非常多的人所知道，同时又因为它可靠的分布式特性被很多人喜欢。所以，我准备有几篇博文来记录一下，从基本使用到线上部署再到原理分析，做一个系列。那么，今天先来说说它的简介与命令行的使用。</p>
<span id="more"></span>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="ETCD是什么"><a href="#ETCD是什么" class="headerlink" title="ETCD是什么"></a>ETCD是什么</h3><p>我个人总结为下面用几个要点：</p>
<ul>
<li>高可用K-V存储，就类似于redis一样的键值对存储。</li>
<li>允许应用实时监听存储中的K-V变化。</li>
<li>能够容忍单点故障，能够应对网络分区。</li>
<li>etcd利用raft在集群中同步K-V信息，raft是强一致的集群日志同步算法。</li>
</ul>
<p>总结：etcd是一个分布式高可用k-v存储，通过复制达到每个节点存储的信息一致，从而保证高可用。</p>
<h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>这里简单说一下复制的具体流程：</p>
<p><img src="http://blog.linkinstars.com/mweb/15601472125417.jpg" alt></p>
<p>（client为我们的客户端，用来发出存储请求，leader和follower都是etcd的节点）<br>就如图上所看到的，我叫它两段式提交：</p>
<ol>
<li>客户端请求leader发送存储的数据，然后leader节点要将信息通过日志复制给大多数的follower节点，如上图所示，只需要复制给两个（加上它自己是三个）那么就是大多数节点。</li>
<li>leader当复制完成之后才会本地提交，然后返回给客户端成功，（如果没有或者不能复制给大多数节点，那么则存储失败）此时再同时其他follower去他们自己本地提交。<br>是不是有一种分布式事务的感觉？分布式的解决通常都是这种感觉。</li>
</ol>
<p>我们也可以看到，etcd通过先将数据存放在大多数节点上面从而保证数据不会出错并且效率较高，最终所有节点数据还是会同步一致的。</p>
<ul>
<li>官方给出写入的性能：1000/s</li>
</ul>
<p>PS:这里因为是简介，所以就简单提一下，有关如何选举出leader还有raft协议的一些具体细节，以及当出现网络分区或者节点异常问题的恢复会在之后的博客中给出。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>底层存储key是有序排列的<br>‘key’ -&gt; ‘value’</p>
<p>aaa/bbb -&gt; 111<br>aaa/bbc -&gt; 3333<br>bbb/aaa -&gt; 1321<br>ccc -&gt; 24<br>就是按照key的顺序依次排列，相同前缀的key会被放在一起，这样到存储结构，当查询时<strong>可以通过key的前缀将一系列的value都取出来</strong></p>
<h3 id="watch机制和lease租约"><a href="#watch机制和lease租约" class="headerlink" title="watch机制和lease租约"></a>watch机制和lease租约</h3><p>etcd有一个很棒的机制要单独提一句，就是watch，它允许你去监控一个key的变化。当你监控了之后，这个key的添加修改删除都会被监控到。<br>lease租约，这个机制和redis中的key过期机制一样，可以申请一个租约，这个租约有一个时间限制，比如60秒，你可以将这个租约设置到一个key上，那么这个key过60秒就会被自动删除。当然也可以进行续租。</p>
<p>具体使用情况，可以从后面的命令行操作中看到。</p>
<h3 id="还有一些小点"><a href="#还有一些小点" class="headerlink" title="还有一些小点"></a>还有一些小点</h3><ul>
<li>etcd使用grpc，所以网络性能会高</li>
<li>部署节点数量要求是2N+1个</li>
<li>选举leader需要半数以上的节点参与</li>
<li>etcd是支持事务操作的，可以if第一次a提交正常，then提交b，else不提交b</li>
</ul>
<h2 id="本地单节点部署"><a href="#本地单节点部署" class="headerlink" title="本地单节点部署"></a>本地单节点部署</h2><p>我们一开始学习和测试的时候只需要在本地部署一个单节点就可以了，单节点的部署比较方便这边简单说明一下。<br>首先下载对应的版本：<a href="https://github.com/etcd-io/etcd/releases">https://github.com/etcd-io/etcd/releases</a><br>我这边使用的mac对应的darwin-amd64的版本，其他版本应该类似。<br>下载解压之后有两个文件比较重要：</p>
<ul>
<li>etcd 这个是节点</li>
<li>etcdctl 这个是客户端<br>进入所在目录使用命令进行启动和使用</li>
</ul>
<p>使用节点命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ./etcd</span><br></pre></td></tr></table></figure></p>
<p>使用客户端命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl</span><br><span class="line">NAME:</span><br><span class="line">   etcdctl - A simple <span class="built_in">command</span> line client <span class="keyword">for</span> etcd.</span><br><span class="line"></span><br><span class="line">WARNING:</span><br><span class="line">   Environment variable ETCDCTL_API is not <span class="built_in">set</span>; defaults to etcdctl v2.</span><br><span class="line">   Set environment variable ETCDCTL_API=3 to use v3 API or ETCDCTL_API=2 to use v2 API.</span><br></pre></td></tr></table></figure></p>
<p>之后会出现上述类似警告，告诉你，默认使用的是v2版本的API，你需要设置环境变量ETCDCTL_API=3就能使用v3版本的API了，这里我们使用命令export ETCDCTL_API=3</p>
<p>或者你可以手动修改环境变量添加export ETCDCTL_API=3就可以了，当不出现警告的时候证明环境变量设置正确。</p>
<h2 id="简单命令行操作"><a href="#简单命令行操作" class="headerlink" title="简单命令行操作"></a>简单命令行操作</h2><p>下面介绍几个最基本的etcd的操作，其实非常简单。主要与redis不同的是拥有独特的watch机制，这个机制非常棒。</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl put /aaa/a 1</span><br><span class="line">OK</span><br><span class="line">➜ ./etcdctl put /aaa/b 2</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl get /aaa/a</span><br><span class="line">/aaa/a</span><br><span class="line">1</span><br><span class="line">➜ ./etcdctl get --prefix /aaa</span><br><span class="line">/aaa/a</span><br><span class="line">1</span><br><span class="line">/aaa/b</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–prefix意思是取出所有前缀为/aaa的key</p>
</blockquote>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>新开一个窗口使用命令watch进行监听<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl watch /aaa/a</span><br></pre></td></tr></table></figure></p>
<p>然后对/aaa/a这个key的操作全部都会被监听到<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl put /aaa/a 123</span><br><span class="line">OK</span><br><span class="line">➜ ./etcdctl del /aaa/a</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl watch /aaa/a</span><br><span class="line">PUT</span><br><span class="line">/aaa/a</span><br><span class="line">123</span><br><span class="line">DELETE</span><br><span class="line">/aaa/a</span><br></pre></td></tr></table></figure></p>
<h3 id="lease"><a href="#lease" class="headerlink" title="lease"></a>lease</h3><p>创建一个60s的租约<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl lease grant 60</span><br><span class="line">lease 694d6b2b7d7e6a0c granted with TTL(60s)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl put /aaa/a 123 --lease=694d6b2b7d7e6a0c</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>put的时候使用租约注意，这里需要输入上面租约的16进制标识符<br>然后监听的地方会发现，60秒后，/aaa/a这个key被自动删除了</p>
<p>当然你可以使用keep-alive进行续租，如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ./etcdctl lease keep-alive 694d6b2ac4a35625</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上简单说明了etcd的一些基本信息，单节点部署，以及一些基本用法，从上述信息我们总结可知：</p>
<ol>
<li>etcd是分布式的，能保证在单点故障下也能正常使用</li>
<li>分布式也会导致问题，etcd写入性能相较redis肯定有所不及</li>
<li>etcd独特的watch机制可以用于很多场景，如配置更新分发等</li>
</ol>
<p>那这里就说这么多，看完你就应该大致知道etcd是个啥玩意了，从现在看来你可能还没有感觉它有什么厉害的地方，后面我们结合实际的场景使用就能更加明白了。</p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>浅入深出ETCD之【集群部署与golang客户端使用】</title>
    <url>/post/e0b92017.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前说了etcd的简介，命令行使用，一些基本原理。这次来说说现实一点的集群部署和golang版本的客户端使用。因为在实际使用过程中，etcd的节点肯定是需要2N+1个进行部署的，所以有必要说明一下集群的部署。</p>
<span id="more"></span>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>网上有很多集群部署的教程，有的很复杂，其实对于我们实际使用来说，其实配置并不复杂，下面举例一种最简单的集群配置。（简单到你想不到~）</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://github.com/etcd-io/etcd/releases">https://github.com/etcd-io/etcd/releases</a><br>还是在github上面找到需要下载的版本<br>我使用的是etcd-v3.3.13-linux-amd64.tar.gz<br>使用wget下载到linux你喜欢的目录，或者本地下载完成之后上传均可。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>首先我找了三台机器，对应ip为<br>192.168.4.224<br>192.168.4.225<br>192.168.4.226<br><strong>PS：提醒一下记得开发对应防火墙的端口</strong></p>
<p>然后将下载的文件解压，之后进入解压后的目录，分别使用下面的命令启动。(注意下面的命令对应的是三台不同的机器，你需要修改对应为你自己的ip)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcd --name infra0 --initial-advertise-peer-urls http://192.168.4.224:2380 \</span><br><span class="line">--listen-peer-urls http://192.168.4.224:2380 \</span><br><span class="line">--listen-client-urls http://192.168.4.224:2379,http://127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls http://192.168.4.224:2379 \</span><br><span class="line">--initial-cluster-token etcd-cluster-1 \</span><br><span class="line">--initial-cluster infra0=http://192.168.4.224:2380,infra1=http://192.168.4.225:2380,infra2=http://192.168.4.226:2380 \</span><br><span class="line">--initial-cluster-state new</span><br><span class="line"></span><br><span class="line">$ ./etcd --name infra1 --initial-advertise-peer-urls http://192.168.4.225:2380 \</span><br><span class="line">--listen-peer-urls http://192.168.4.225:2380 \</span><br><span class="line">--listen-client-urls http://192.168.4.225:2379,http://127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls http://192.168.4.225:2379 \</span><br><span class="line">--initial-cluster-token etcd-cluster-1 \</span><br><span class="line">--initial-cluster infra0=http://192.168.4.224:2380,infra1=http://192.168.4.225:2380,infra2=http://192.168.4.226:2380 \</span><br><span class="line">--initial-cluster-state new</span><br><span class="line"></span><br><span class="line">$ ./etcd --name infra2 --initial-advertise-peer-urls http://192.168.4.226:2380 \</span><br><span class="line">--listen-peer-urls http://192.168.4.226:2380 \</span><br><span class="line">--listen-client-urls http://192.168.4.226:2379,http://127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls http://192.168.4.226:2379 \</span><br><span class="line">--initial-cluster-token etcd-cluster-1 \</span><br><span class="line">--initial-cluster infra0=http://192.168.4.224:2380,infra1=http://192.168.4.225:2380,infra2=http://192.168.4.226:2380 \</span><br><span class="line">--initial-cluster-state new</span><br></pre></td></tr></table></figure>
<p>至此，三个节点的集群部署完成。😂😂😂没错就是这么easy，没有网上说的那么复杂。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如果你嫌弃每次使用这么长的命令进行启动，你可以将它写为配置文件：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前节点名称</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">infra1</span></span><br><span class="line"><span class="comment"># etcd数据保存目录</span></span><br><span class="line"><span class="attr">data-dir:</span> <span class="string">/usr/local/etcd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 供外部客户端使用的url</span></span><br><span class="line"><span class="attr">listen-client-urls:</span> <span class="string">http://192.168.4.225:2379,http://127.0.0.1:2379</span></span><br><span class="line"><span class="comment"># 广播给外部客户端使用的url</span></span><br><span class="line"><span class="attr">advertise-client-urls:</span> <span class="string">http://192.168.4.225:2379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群内部通信使用的URL</span></span><br><span class="line"><span class="attr">listen-peer-urls:</span> <span class="string">http://192.168.4.225:2380</span></span><br><span class="line"><span class="comment"># 广播给集群内其他成员访问的URL</span></span><br><span class="line"><span class="attr">initial-advertise-peer-urls:</span> <span class="string">http://192.168.4.225:2380</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群的名称</span></span><br><span class="line"><span class="attr">initial-cluster-token:</span> <span class="string">etcd-cluster-1</span></span><br><span class="line"><span class="comment"># 初始集群成员列表</span></span><br><span class="line"><span class="attr">initial-cluster:</span> <span class="string">infra0=http://192.168.4.224:2380,infra1=http://192.168.4.225:2380,infra2=http://192.168.4.226:2380</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始集群状态</span></span><br><span class="line"><span class="attr">initial-cluster-state:</span> <span class="string">new</span></span><br></pre></td></tr></table></figure></p>
<p>然后指定配置文件的路径进行启动就可以了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./etcd --config-file=conf.yml</span><br></pre></td></tr></table></figure></p>
<h2 id="其他部署策略"><a href="#其他部署策略" class="headerlink" title="其他部署策略"></a>其他部署策略</h2><p>以上的部署一方面，我个人部署时使用的最简单方式，更简单的可能是使用yum进行etcd的下载。<br>当然上述方式也存在一些问题，现在的etcd相当于裸奔的情况：</p>
<ul>
<li>没有鉴权就想到于任何人知道ip和端口就可以连接上你的etcd，所以当前可能只适用于内网使用，服务通过内网ip进行访问（这个可以通过添加权限和用户来完成）</li>
<li>当前通信是没有加密的</li>
<li>当前etcd是利用静态ip来进行配置的，我认为这也是实际中用到最普通的情况，但是etcd还提供发现机制来进行部署和配置，更加灵活</li>
</ul>
<p>等等，这些部署策略更多针对于线上，因为官方写的非常详细了，我感觉再写也就班门弄斧了。<br><a href="https://doczhcn.gitbook.io/etcd/index/index-1/clustering">https://doczhcn.gitbook.io/etcd/index/index-1/clustering</a></p>
<h2 id="Golang客户端使用"><a href="#Golang客户端使用" class="headerlink" title="Golang客户端使用"></a>Golang客户端使用</h2><p>这里来实际用代码操作一下etcd，还是和之前使用命令行一样，get/put/del/watch/lease用一下这些操作，其他操作请查看doc<br><a href="https://godoc.org/github.com/coreos/etcd/clientv3">https://godoc.org/github.com/coreos/etcd/clientv3</a></p>
<h3 id="客户端下载"><a href="#客户端下载" class="headerlink" title="客户端下载"></a>客户端下载</h3><p>这里不建议使用go get进行下载，真的太慢了，可以直接从github上面下载之后放到对应目录快一些。<a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a><br>下载解压之后放到gopath下对应：go/src/go.etcd.io/etcd</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;go.etcd.io/etcd/clientv3&quot;</span></span><br><span class="line">    <span class="string">&quot;go.etcd.io/etcd/mvcc/mvccpb&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 配置客户端连接</span></span><br><span class="line">    client, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">        <span class="comment">// Endpoints:   []string&#123;&quot;127.0.0.1:2379&quot;&#125;,</span></span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">&quot;192.168.4.224:2379&quot;</span>, <span class="string">&quot;192.168.4.225:2379&quot;</span>, <span class="string">&quot;192.168.4.226:2379&quot;</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动watch监听</span></span><br><span class="line">    watch := client.Watch(context.TODO(), <span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            watchResponse := &lt;- watch</span><br><span class="line">            <span class="keyword">for</span> _, ev := <span class="keyword">range</span> watchResponse.Events &#123;</span><br><span class="line">                <span class="keyword">switch</span> ev.Type &#123;</span><br><span class="line">                <span class="keyword">case</span> mvccpb.DELETE:</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;监听到del：%s\n&quot;</span>, ev.Kv.Key)</span><br><span class="line">                <span class="keyword">case</span> mvccpb.PUT:</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;监听到put：%s, %s\n&quot;</span>, ev.Kv.Key, ev.Kv.Value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    putResponse, err := client.Put(context.TODO(), <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(putResponse.Header.String())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    getResponse, err := client.Get(context.TODO(), <span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(getResponse.Kvs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    deleteResponse, err := client.Delete(context.TODO(), <span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(deleteResponse.Header.String())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请租约</span></span><br><span class="line">    grantResponse, err := client.Grant(context.TODO(), <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用租约</span></span><br><span class="line">    response, err := client.Put(context.TODO(), <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;xxx&quot;</span>, clientv3.WithLease(grantResponse.ID))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(response.Header.String())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待租约自动过期</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致能得到以下输出</p>
<blockquote>
<p>监听到put：aaa, xxx<br>cluster_id:14841639068965178418 member_id:10276657743932975437 revision:53 raft_term:4<br>[key:”aaa” create_revision:53 mod_revision:53 version:1 value:”xxx” ]<br>监听到del：aaa<br>cluster_id:14841639068965178418 member_id:10276657743932975437 revision:54 raft_term:4<br>监听到put：aaa, xxx<br>cluster_id:14841639068965178418 member_id:10276657743932975437 revision:55 raft_term:4<br>监听到del：aaa</p>
</blockquote>
<p>其实使用起来还是非常简单，我就不过多赘述了。</p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>浅入深出ETCD之【raft原理】</title>
    <url>/post/cd9f042e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这次我们来说说，有关于etcd原理的一些事情。之前我们已经了解到了etcd是一个分布式的k-v存储，那么它究竟是如何保证数据是如何复制到每个节点上面去的呢？又是如何保证在网络分区的情况下能正常工作下去？raft协议到底是什么？带着这些问题我们继续往下看。</p>
<span id="more"></span>
<h2 id="raft选举策略"><a href="#raft选举策略" class="headerlink" title="raft选举策略"></a>raft选举策略</h2><p>我们知道etcd使用raft协议来保证整个分布式的节点网络能正常的运转并且能正确的将数据复制到每个节点上面去。那么什么是raft协议嘞？</p>
<p>首先我们有这样一个背景：raft是想维护整一个网络，其中有一个领导人，这个领导人负责将收到的信息同步给网络中的其他所有节点，从而保证整个网络数据一致。</p>
<p>如果你有一定的英文基础，我建议直接查看下面这个网站，它用动画非常清楚的描述了raft选举的整个过程：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<p>这个其实已经说明的超级棒了，如果你还看不懂，我下面会用最简单的几个要点来进行最简单的说明。</p>
<h3 id="大多数理论"><a href="#大多数理论" class="headerlink" title="大多数理论"></a>大多数理论</h3><p>首先说明一个理论，叫做大多数理论，很简单，举个栗子：</p>
<ul>
<li>有10个人，如果你将苹果给其中的6个人（大多数），那么你随机选择5个人，一定有一个人会有苹果。</li>
</ul>
<p>在etcd中的应用：</p>
<ul>
<li>选举中只要有大多数（超过半数的人给你投票）你肯定就是票数最多的了，不可能有人比你更多。</li>
<li>只需要将日志复制给大多数的节点，那么只要有一半的节点正常工作就能保证数据最新</li>
</ul>
<h3 id="选举状态"><a href="#选举状态" class="headerlink" title="选举状态"></a>选举状态</h3><p>下面是一些选举过程中节点的状态<br>leader 表示选举最终产生的领导人<br>candidate 候选状态，表示当前正在参与选举<br>follower 表示选举最终自己不是领导人，那自己就是从属节点</p>
<h3 id="选举过程与要点"><a href="#选举过程与要点" class="headerlink" title="选举过程与要点"></a>选举过程与要点</h3><p><img src="http://blog.linkinstars.com/mweb/15603076610892.jpg" alt></p>
<ol>
<li>所有节点一开始都是follower状态</li>
<li>当节点处于follower状态时，每个节点随机经过一段时间，<strong>如果没有收到leader的消息就会进入candidate状态</strong>（证明当前没有leader节点需要重新进行选举），如果收到信息就会继续保持follower状态</li>
<li>当节点处于candidate就会要求别人给自己投票，<strong>收到大多数的节点的投票那就转变为leader状态</strong>，否则要么是别的节点成为了leader，要么就是因为特殊情况导致这次选举失败重新进行选举</li>
<li>每次选举举办的时候有一个term，在每一个term中，<strong>每个节点只能投票一次</strong></li>
<li>投票的时候必须投给当前数据至少和自己一样的节点，并且term大的优先</li>
</ol>
<h2 id="日志复制规则"><a href="#日志复制规则" class="headerlink" title="日志复制规则"></a>日志复制规则</h2><p>etcd是通过日志复制来实现数据同步的<br><img src="http://blog.linkinstars.com/mweb/15603077783791.jpg" alt><br>这个图网上也很多，说明的是日志复制的规则<br>每个节点都有一份自己的日志，有的节点多，有的节点少，日志最多的肯定是leader。<br>上图还有几个要点，我看别人没提到，我就提一下：</p>
<ol>
<li>颜色代表term</li>
<li>第四行表示的这个节点，第一term下复制了两个日志就异常挂掉了</li>
<li>最终只有第三行这个follower和第一行的leader保持了同步</li>
</ol>
<h2 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h2><p>raft之所以厉害因为即使出现一些特殊情况，整个网络在一定的时间之后也能自动恢复并正常工作。</p>
<h3 id="一个节点的异常"><a href="#一个节点的异常" class="headerlink" title="一个节点的异常"></a>一个节点的异常</h3><p>首先最常见的情况就是一个节点出现异常，有可能是这个节点的服务器挂了，或者别的什么原因。</p>
<ul>
<li>如果出现问题的这个节点是follower，那么没有关系，整个网络依旧能正常运行，当这个节点再次加入网络的时候也只需要同步后面的数据即可。</li>
<li>如果出现问题的是leader，有一点麻烦，因为网络中没有leader节点了，那么就会重新进行选举，重新找一个leader，当这个异常节点恢复之后发现当前网络中有leader了，而且term还比自己大，那么自己就退位称为follower。</li>
</ul>
<h3 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h3><p>还有一种异常情况是由于网络导致的，网络出现异常，导致节点之间的通信存在异常，一部分节点与另一部分之间没有办法访问了。如下图所示：<br><img src="http://blog.linkinstars.com/mweb/15603110122471.jpg" alt></p>
<p>上面三个follower没有办法与下面的节点进行通信。</p>
<ul>
<li>当客户端再次请求leader发送数据的时候，leader发现没有办法将数据同步给给大多数节点，它只能给自己和旁边的一个，此时leader没有办法给客户端反馈。</li>
<li>上面三个节点由于收不到leader的消息，那么会认为网络中没有leader存在，会重新进行选举操作，因为当前上面有三个节点存在（只要有超过半数的节点参与选举就行），所以可以重新选举成功，选出新的leader告诉客户端，客户端就会重新发送数据到新的leader。</li>
<li>当网络恢复之后又会找到最新的leader从而将数据同步至最新的状态。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，只要整个网络中存在大多数节点正常运行，那么etcd就是可用的，并且能够保证数据正确。当网络恢复之后也能将数据调整到最新的状态。<br>raft强大的地方在于它能自动的进行状态的变化，自动进行选举，并且选举遵循一定的策略，进而保证整个网络的正常运转。同时保证数据的一致性。<br>了解etcd的这个原理有助于我们后续的使用以及源码的阅读。</p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>大话图解gin源码</title>
    <url>/post/64a85efa.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近在网上搜了一下，对于gin框架用的人还是比较多的，我自己之前也在使用，但是对于源码解析这块，我没有看到自己想看到的那种从框架入手的解析图，所以嘿嘿嘿，我的机会就来了，今天就带来最完整的gin源码图解。希望通过这篇博客你也能自己学会拆轮子。</p>
<p>PS：本文建立在你已经能熟练使用gin的基础之上，如果还没用过可以去官网看一下：<br><a href="https://gin-gonic.com/zh-cn/docs/">https://gin-gonic.com/zh-cn/docs/</a><br>然后gin是对golang的http包的封装，所以最好对http包也要有了解。</p>
<span id="more"></span>
<h2 id="整体分析逻辑"><a href="#整体分析逻辑" class="headerlink" title="整体分析逻辑"></a>整体分析逻辑</h2><p>先来说明一下我整体拆解的逻辑，对于一个框架，我喜欢从下面几个方面去入手拆解：</p>
<ol>
<li>启动方式</li>
<li>如何使用</li>
<li>实现与特点<br>针对于gin，我也将从这几个方面去入手，就会得到下面几个问题，带着问题看源码是必备条件。<br>首先启动的时候gin做了些什么？<br>gin封装了什么然后怎么去实现的？<br>gin整体结构是怎么样的，有哪些结构？<br>…</li>
</ol>
<p>然后使用一个比较小的demo，然后先从方法入手，进源码看。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    </span><br><span class="line">    router.Use(gin.Recovery())</span><br><span class="line">    </span><br><span class="line">    router.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">        context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;code&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;message&quot;</span> : <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := router.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="整体结构认识"><a href="#整体结构认识" class="headerlink" title="整体结构认识"></a>整体结构认识</h2><p><img src="http://blog.linkinstars.com/mweb/15662772307077.jpg" alt><br>Engine是一个总的引擎，保存了各个组件的信息<br>RouterGroup是一个路由组，保存了路由信息<br>trees是一棵树，保存了url与handle的映射关系<br>engine中的pool用于复用Context<br>Context用于request中传递值</p>
<p>这样你就对gin的整个结构有了大致的认识，当然有一些细节字段我这里就不展开了。</p>
<h2 id="每个方法分析"><a href="#每个方法分析" class="headerlink" title="每个方法分析"></a>每个方法分析</h2><h3 id="gin-Default"><a href="#gin-Default" class="headerlink" title="gin.Default()"></a>gin.Default()</h3><p><img src="http://blog.linkinstars.com/mweb/15662774362702.jpg" alt><br>调用过程大概是这样，这是一个gin的初始化方法，目的是为了创建整个引擎，并初始化相关参数。初始化RouterGroup、pool等</p>
<h3 id="router-Use"><a href="#router-Use" class="headerlink" title="router.Use()"></a>router.Use()</h3><p><img src="http://blog.linkinstars.com/mweb/15662775073706.jpg" alt><br>这个是一个使用中间件的方法，当然中间件也有别的方法，这边使用use举例，其实就是将请求过程中需要调用的中间件放入到HandlersChain，这个是一个数组<br>PS：你不知道中间件？那你用一下就知道了，我们很多时候再请求前后需要加入通用方法如鉴权等，就会用到它</p>
<h3 id="router-GET"><a href="#router-GET" class="headerlink" title="router.GET"></a>router.GET</h3><p><img src="http://blog.linkinstars.com/mweb/15662776382936.jpg" alt><br>这个就是构建url和具体处理请求的handle的关系了，其实目标很明确，就是要将这组关系存入到最终的trees中去，这里先这样，后面会有详细解释。</p>
<h3 id="router-Run"><a href="#router-Run" class="headerlink" title="router.Run()"></a>router.Run()</h3><p><img src="http://blog.linkinstars.com/mweb/15662777270926.jpg" alt><br>这个就非常简单了，就是调用golang中http包下的方法监听服务端口而已，没啥好说的，启动了嘛。</p>
<h3 id="func-engine-Engine-ServeHTTP"><a href="#func-engine-Engine-ServeHTTP" class="headerlink" title="func (engine *Engine) ServeHTTP"></a>func (engine *Engine) ServeHTTP</h3><p>你以为这就完了？？？上面只是启动的时候，那么请求过来的时候怎么办呢？<br>我们知道如果要接收请求，那么就需要实现下面这个接口<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接口中ServeHTTP就是用来处理请求的，所有请求都会经过这个方法去处理。<br>那么gin是怎么实现这个方法的呢？<br><img src="http://blog.linkinstars.com/mweb/15662778798063.jpg" alt><br>这个就是调用过程，总的来说就是根据请求的url和method找到对应的handle去处理，还记得之前那棵树吗？对，就是去里面找。同时利用context进行参数传递，最后注意很隐秘的用c.Next进行递归的调用（我已开始都没找到）为啥要递归？因为有中间件鸭！handle是一个链式过程而非只有一个handle</p>
<p>至此所有gin的框架里面的内容应该都包括了，包括整个实现过程，其实并不复杂，你可以根据上面的过程在源码中找到对应的地方详细查看。</p>
<h2 id="好在哪里？"><a href="#好在哪里？" class="headerlink" title="好在哪里？"></a>好在哪里？</h2><p>我们看源码肯定不能看完，哦，知道怎么实现就完事了，我们最终的目的是要学习其中的优点，那么这个框架有哪些好的地方呢？我个人总结了以下三点供你参考。</p>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>使用context包含了Request，Writer等信息，用它来传递参数，也算是利用golang的一个特性去做的，我没想到。</p>
<h3 id="sync-pool"><a href="#sync-pool" class="headerlink" title="sync.pool"></a>sync.pool</h3><p>利用pool来重复利用对象，因为请求很多，所以会产生很多数量的context，利用sync.pool进行复用，从而减少内存的分配也提高了效率，值得学习。</p>
<h3 id="trees"><a href="#trees" class="headerlink" title="trees"></a>trees</h3><p>用什么数据结构存放的url和handle的映射关系呢？<br>我一开始想到的就是map，直接弄个hashmap存一下不就好了嘛，没想到gin用了一颗树来进行存放，内部实现很复杂，这里不做展开，据说是radix tree，我就是把它理解成字典树，从而提高存储和查询，棒。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实gin框架本身实现好像并不是很复杂，很适合新手进行学习，其中也有一些设计思想可以借鉴。</p>
]]></content>
      <categories>
        <category>gin</category>
      </categories>
      <tags>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级 k8s 应用日志收集方案 loki</title>
    <url>/post/da4cf864.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>微服务早已是一个过时的热词，同时，容器 和 k8s 的出现让它更一步成为了一种时尚。同样会带来很多附赠的问题，<strong>日志收集</strong>就是其中一个比较重要的问题。当应用容器化之后，需要查看日志，如果还需要登录服务器，找到对应目录，然后 tail 查看，成本太高了，极大的影响效率。当前其实日志收集方案很多，在实践了多个方案之后，我终于能在今天写出我个人认为我最喜欢的一个方案了 <strong>loki</strong></p>
<span id="more"></span>
<h2 id="我的需求"><a href="#我的需求" class="headerlink" title="我的需求"></a>我的需求</h2><p>技术上没有银弹，需要根据实际需求来选择方案，那么我的需求是这样的，你可以做个比较：</p>
<ol>
<li>当前所有的应用是部署在 k8s 中的，需要收集所有的应用的日志到一个地方做展示</li>
<li>部署最好要轻量，对于性能要求并不高（当前日志量并不大）</li>
<li>日志展示方式友好，能支持基本的时间查询，或者是定位到某个关键字</li>
</ol>
<h2 id="可选方案"><a href="#可选方案" class="headerlink" title="可选方案"></a>可选方案</h2><p>从之前的公司包括个人的一些项目上都尝试过很多不同的组合和方案，列举出三个最具有可比性的方案：（以下为个人使用案例，并不能代表所有大众观点，图片来源本地测试服，线上日志不允许公开，但同样禁止转载~）</p>
<h3 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h3><p><img src="http://blog.linkinstars.com//blog/elk.png" alt="ELK"></p>
<p>这似乎是业界最成熟的日志收集方案之一了，因为无论你问哪个有点经验的程序员，提到日志收集，必然会给到这个，我当然不是说这个方案不行，因为我知道很多公司都采用了这个方案，并且稳定运行着，所以这个方案我也尝试去使用过，带来的问题有下面几个：</p>
<ol>
<li>部署并不容易，当前现在已经好很多了，当年确实手工部署比较困难，会有很多意外</li>
<li>占用资源过多，特别是 logstash，懂得都懂</li>
<li>ES 使用比较困难，上手成本比较高，因为并不是所有的开发对于 ES 的使用都是熟练的，包括我自己都是需要查看文档之后才能回忆起来很多操作</li>
</ol>
<p>当然后面改进了：变成了 EFK</p>
<p>其中的 F 可以是 filebeat、fluentd、fluent-bit 这样日志采集的部分可以占用更少的资源，使用上会更加轻量一些，所以，其实现在 EFK 算是一个通用的商业日志收集的解决方案了。我觉得如果是一个中型或者大型的项目可以使用这样成熟的解决方案，没有问题。</p>
<h3 id="FIC"><a href="#FIC" class="headerlink" title="FIC"></a>FIC</h3><p>FIC 可能小众一些，但是这是我第二个使用上来说对于我来说使用下来感觉不错的方案：fluentbit + influxdb + chronograf</p>
<p>其实我蛮喜欢 influxdb 这家公司出品的东西的，使用感觉还不错，因为 influxdb 作为一个时序数据库来说其实非常轻量了，部署也很方便，配置上面也比较简单，主要还是日志收集上面的配置，并且 influxdb 的使用比起 es 来说理解起来更加的简单一点，更容易上手</p>
<p><img src="http://blog.linkinstars.com//blog/chronograf.png" alt="chronograf"></p>
<p>部署方式：<a href="https://www.jianshu.com/p/c5faf3c10bce">https://www.jianshu.com/p/c5faf3c10bce</a></p>
<p>在使用的 FIC 的时候，我发现它对于单体应用还是相当友好的，搭建使用都非常舒服，并且 chronograf 的页面比 kibana 个人认为要舒服很多，简洁。当然也有它自己的问题：</p>
<ol>
<li>influxdb 还是比较吃内存的</li>
<li>日志量大的时候 chronograf 明显第一次进去会卡，不知道现在优化没有，然后如果当入库数据异常的时候其实页面会报错的：之前我提过 issue 应该已经修复</li>
<li>日志关键字搜索的时候会卡，准确的说比较慢</li>
<li>其实 fluentbit 对于多行日志的处理很鸡肋，因为每家每户的日志格式其实不太一样，公司内部日志格式都不一样，我还尝试重新自己造过轮子，发送到 influxdb ，后面才发现 filebeat 也能满足要求。</li>
<li>tag 会爆炸，塞日志的时候，如果日志量巨大，因为会根据日志级别打 tag 建立索引，而 influxdb 是有默认限制的，所以当时也踩了坑，调整了配置后得以解决</li>
</ol>
<p>但是 其实 FIC 对于系统日志也就是 syslog 的监控还是有着自己独特的一面，有机会你可以尝试一下，还是相当不错的，这个方案我也使用了一段时间了。</p>
<h3 id="Loki"><a href="#Loki" class="headerlink" title="Loki"></a>Loki</h3><p>这是我当前使用过一段时间之后，最终认可的一个方案：<a href="https://github.com/grafana/loki">https://github.com/grafana/loki</a></p>
<p>其实在使用 FIC 的时候我就犹豫过当时要不要使用 loki 犹豫当时的公司内部没有大力推 k8s ，多数都是 docker-compose 的使用，更多的是小单体居多的。而当时 loki 也是没有很多的实际使用经验，不敢往上推，怕出问题。但是后面有了机会实践之后就真香了。</p>
<p>其实 loki 包含三个组件：</p>
<ol>
<li><strong>Promtail</strong>:日志收集工具</li>
<li><strong>Loki</strong>:日志聚合系统</li>
<li><strong>Grafana</strong>:可视化工具</li>
</ol>
<p>grafana 其实很熟悉了，很多监控展示都用到它了，用起来也相当的舒服，有很多的展示方式，当时在比较的时候，当初 grafana 还只有表格展示模式，所以就比较尴尬，后面出现了 log 模式就很舒服了。</p>
<p><img src="http://blog.linkinstars.com//blog/grafana.png" alt="grafana"></p>
<p>我觉得 loki 让我舒服在下面几个点：</p>
<ol>
<li>k8s 内部署非常方便，几乎是一个 helm 就能部署好了，不需要额外的配置，默认的配置已经足够日常的使用了</li>
<li>能筛选到某应用，甚至到某个 pod 的日志，查问题的时候非常方便</li>
<li>支持关键字搜索，我甚至不需要调整原有的日志格式，就能有很好的支持，如果调整输出日志的格式为官方推荐的 logfmt 的话可能更加靠谱</li>
<li>日志数据本身会被压缩，使用成本低</li>
<li>几乎没有入侵：我没有调整日志格式，不需要建立特定的 sidecar 去监控日志也就不需要改动原有的 deployment 的 yaml 配置，就是使用 loki 不需要我改动什么就能用起来</li>
</ol>
<p>但是毕竟没有 ES 那么多建立的索引，当日志量大的时候搜索没有那么快，但是也足够满足我的要求了，足够用了。（当然如果调整loki一些参数如缓存等可以大大加快查询速度，个人没有调整，已经足够使用）</p>
<p>虽然网上见到有吐槽过性能的，但是目前个人使用下来暂时没有遇到瓶颈。后面还会持续关注@TODO。</p>
<p><strong>PS: 需要注意的是，你的应用日志需要输出到 stdout 中</strong> 这里有关 k8s 日志收集方案不做过多讨论，因为网上的方案大多三种，一种 stdout，一种挂 sidecar，一种用 DaemonSet 各有各的说法。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>官方已经给出了很多部署的方案，其中我选择的是 helm，非常轻松：<a href="https://grafana.com/docs/loki/latest/installation/helm/">https://grafana.com/docs/loki/latest/installation/helm/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 repo 并更新</span></span><br><span class="line">helm repo add grafana https://grafana.github.io/helm-charts</span><br><span class="line">helm repo update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里后面是 -stack 的是默认打包好在一起的，没stack的是默认只有 loki 的，自定义安装请参考官网给出的命令</span></span><br><span class="line">helm upgrade --install loki --namespace=loki grafana/loki-stack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 grafana</span></span><br><span class="line">helm install loki-grafana --namespace=&lt;YOUR-NAMESPACE&gt; grafana/grafana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 grafana 的密码</span></span><br><span class="line">kubectl get secret --namespace &lt;YOUR-NAMESPACE&gt; loki-grafana -o jsonpath=<span class="string">&quot;&#123;.data.admin-password&#125;&quot;</span> | base64 --decode ; <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时暴露 端口 进行访问测试</span></span><br><span class="line">kubectl port-forward --namespace &lt;YOUR-NAMESPACE&gt; service/loki-grafana 3000:80</span><br></pre></td></tr></table></figure>
<p>然后设置对应的 service 暴露出你需要使用的端口即可，其实非常容易操作。</p>
<p>使用 admin 和上面查看的  grafana 的密码即可进入，然后添加数据源选择 loki</p>
<p><img src="http://blog.linkinstars.com//blog/loki-data-sources.png" alt="loki-data-sources"></p>
<p>注意这里的地址输入 <a href="http://loki:3100">http://loki:3100</a> 即可，没有什么其他需要配置的。我真的觉得 so easy</p>
<p>如果没有意外，就可以使用 grafana 的 explorer 进行日志查看的了，前提是运行一段时间，让你的输出一些日志。</p>
<h3 id="关键字检索"><a href="#关键字检索" class="headerlink" title="关键字检索"></a>关键字检索</h3><p>其实我一开始还担心没办法进行日志关键字检索，找了半天，才发现很简单，只需要在最上面的输入框中写入 <code>&#123;job=&quot;mysql&quot;&#125; |= &quot;error&quot;</code> 其中的 error 就是你要找的关键字，就可以了，还有一些正则表达式这里就不多介绍了，explorer 打开的一开始有提示的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其他使用细节因为涉及具体生产使用，不方便截图，我将一些必要的的链接参考扔在下面，应该足够你使用了。</p>
<p>总的来说，我要的 loki 都有，并且部署方便，想要替换也很方便，直接删掉就好了，然后满足我日志查看的全部需求，而且占用资源情况也没有其他几个那么高，完美~ 后悔没有早点用上它。不过后面也会持续追踪使用情况，后面会再出一个有关使用过程中的坑点的博客。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>部署相关：<a href="https://blog.cong.moe/post/2020-07-27-use_loki_as_k8s_log_collector/">https://blog.cong.moe/post/2020-07-27-use_loki_as_k8s_log_collector/</a></p>
<p><a href="https://bbs.huaweicloud.com/blogs/200177">https://bbs.huaweicloud.com/blogs/200177</a></p>
<p><a href="https://www.qikqiak.com/post/use-loki-monitor-alert/">https://www.qikqiak.com/post/use-loki-monitor-alert/</a></p>
<p><a href="https://www.qikqiak.com/post/grafana-loki-usage/">https://www.qikqiak.com/post/grafana-loki-usage/</a></p>
<p>官方最佳实践：<a href="https://grafana.com/docs/loki/latest/best-practices/current-best-practices/">https://grafana.com/docs/loki/latest/best-practices/current-best-practices/</a></p>
<p>通过设定annotations只收集固定 pod 的日志：<a href="https://blog.csdn.net/kozazyh/article/details/102881301">https://blog.csdn.net/kozazyh/article/details/102881301</a> （个人认为没有必要，这样对于 k8s 的 yaml 文件有入侵）</p>
<p>如何设置只收集固定 namespace 的日志：<a href="https://www.giantswarm.io/blog/grafana-logging-using-loki">https://www.giantswarm.io/blog/grafana-logging-using-loki</a></p>
]]></content>
      <categories>
        <category>loki</category>
      </categories>
      <tags>
        <tag>loki</tag>
      </tags>
  </entry>
  <entry>
    <title>monitoror/monitoror 最轻量的监控大屏</title>
    <url>/post/94902806.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一提到监控大屏，那第一想法就是 grafana 对吧，各种样式图形都非常好看，而且支持各种数据源。而今天要分享的是一个更加轻量的监控大屏 monitoror/monitoror</p>
<p>有了它能帮你快读构建一个的对于网站或者应用的监控页面，特别是在小应用数量多的时候非常简单易用，作为一个大屏展示时它我觉得它足够简洁</p>
<span id="more"></span>
<p align="center"><br>    <img src="https://github.com/monitoror/monitoror/raw/develop/.assets/monitoror-mockup.svg" alt width="70%"> <br><br></p>

<h2 id="demo-amp-repo"><a href="#demo-amp-repo" class="headerlink" title="demo &amp; repo"></a>demo &amp; repo</h2><p><a href="https://demo.monitoror.com/">https://demo.monitoror.com/</a></p>
<p><a href="https://github.com/monitoror/monitoror">https://github.com/monitoror/monitoror</a></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>部署轻量</li>
<li>配置简单</li>
<li>大屏简洁</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="二进制部署"><a href="#二进制部署" class="headerlink" title="二进制部署"></a>二进制部署</h3><p><a href="https://monitoror.com/documentation/get-started/">https://monitoror.com/documentation/get-started/</a></p>
<p>非常简单，只需要将二进制文件下载，然后按照要求配置对应的配置文件，就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x monitoror</span><br><span class="line">./monitoror</span><br></pre></td></tr></table></figure>
<p>配置文件.env</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MO_CONFIG=&quot;./config.json&quot;</span><br></pre></td></tr></table></figure>
<p>配置文件config.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;columns&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;tiles&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;PORT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Welcome config example&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;hostname&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;port&quot;</span>: <span class="number">8080</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;HTTP-RAW&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Monitoror stars&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/monitoror/monitoror&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;regex&quot;</span>: <span class="string">&quot;(\\d+) users starred&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k8s-部署"><a href="#k8s-部署" class="headerlink" title="k8s 部署"></a>k8s 部署</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">monitoror</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoror</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">monitoror</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">monitoror</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">monitoror</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">monitoror</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">monitoror/monitoror:latest</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MO_CONFIG</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;/conf/monitoror.json&quot;</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">&quot;/conf&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">32000</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">monitoror-config</span></span><br><span class="line">            <span class="attr">items:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">monitoror.json</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">monitoror.json</span></span><br></pre></td></tr></table></figure>
<p>其中需要注意的就是配置文件 configmap 挂载的位置</p>
<p>还有环境变量 MO_CONFIG 需要指定对应的配置文件路径</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><a href="https://monitoror.com/documentation/#configuration">https://monitoror.com/documentation/#configuration</a></p>
<p>monitoror 的配置很简单</p>
<h3 id="监控端口"><a href="#监控端口" class="headerlink" title="监控端口"></a>监控端口</h3><p>只需要填入对应的地址和端口即可</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;PORT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Welcome config example&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hostname&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="number">8080</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="监控HTTP"><a href="#监控HTTP" class="headerlink" title="监控HTTP"></a>监控HTTP</h3><p>只需要填入对应的地址，然后还可以做简单的处理，还有可能监控对应的 http code 状态码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;HTTP-RAW&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Monitoror stars&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/monitoror/monitoror&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;regex&quot;</span>: <span class="string">&quot;(\\d+) users starred&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多平台"><a href="#多平台" class="headerlink" title="多平台"></a>多平台</h2><p><a href="https://monitoror.com/guides/">https://monitoror.com/guides/</a></p>
<p>甚至可以将这个安装到树莓派上去，这个就很有意思了，因为轻量的关系，这个作为一个监控随便插到哪里，还蛮有意思的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你需要最快速的搭建一个可用的监控大屏，或许这就是一个不错的选择；当然如果你需要更多的数据监控，需要一些流量数值等等还需要一些图表，那么或许它还没有那么强大。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当前这个监控还没有通知模块，也就是说，也只能大屏盯着看，emmm…，这个还是有点小鸡肋的，因为确实不可能一直盯着看。当然已经有人提 issue 了，但是官方的 roadmap 里面还没有这个计划，于是我自己先加了一个钉钉的监控意思一下，这样至少能保证出现问题的时候有个反应提醒。比较隔壁的 grafana 做了那么久 alert 模块应该能直接抄过来吧。</p>
<p><img src="http://blog.linkinstars.com//blog/dingding.png" alt="dingding"></p>
<blockquote>
<p>地址：<a href="https://github.com/LinkinStars/monitoror/tree/add-notification">https://github.com/LinkinStars/monitoror/tree/add-notification</a></p>
</blockquote>
<p>可以直接拿下来编译使用，注意需要配置：.env 文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">MO_CONFIG</span>=<span class="string">&quot;./config.json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 钉钉的 webhook 地址</span></span><br><span class="line"><span class="attr">MO_MONITORABLE_DINGDING_WEBHOOK</span>=<span class="string">&quot;https://oapi.dingtalk.com/robot/send?access_token=xxxxx&quot;</span></span><br><span class="line"><span class="comment"># 钉钉的 secret 如果不配置 secret 使用 monitoror 关键字应该也可以</span></span><br><span class="line"><span class="attr">MO_MONITORABLE_DINGDING_SECRET</span>=<span class="string">&quot;SECxxxxxx&quot;</span></span><br></pre></td></tr></table></figure>
<p>当前通知规则：</p>
<p>最大连续出错通知 3 次，超过这个次数不会继续通知，当服务恢复后计数清零，再次出现异常时会重新通知，同样是 3 次；（这个是临时设置的规则，等全部写完之后会抽离为配置或者调整为更加合适的规则）</p>
]]></content>
      <categories>
        <category>monitoror</category>
      </categories>
      <tags>
        <tag>monitoror</tag>
      </tags>
  </entry>
  <entry>
    <title>openfaas/faas 环境搭建和开发使用</title>
    <url>/post/f7a42ef3.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>serverless 大环境下出现了 faas，即 function as  a service，函数即服务；其意思也非常好理解，就是能将一个函数作为一个服务进行使用，用户只需要编写一个函数功能即可，不需要额外去关心别的东西。<a href="https://github.com/openfaas/faas">https://github.com/openfaas/faas</a> 是其中的一种实现方式。</p>
<span id="more"></span>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>以下环境在 mac 上进行搭建：</p>
<p>首先需要准备 docker 和 kubernetes 的环境，先做 k8s 的环境直接能通过 docker 桌面进行配置，已经算是很方便了。</p>
<p><img src="http://blog.linkinstars.com//blog/image-20201019193844247.png" alt="image-20201019193844247"></p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="openfaas-cli"><a href="#openfaas-cli" class="headerlink" title="openfaas-cli"></a>openfaas-cli</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sL https://cli.openfaas.com | sh</span><br></pre></td></tr></table></figure>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/openfaas/faas-netes</span><br><span class="line"><span class="built_in">cd</span> faas-netes</span><br><span class="line">kubectl apply -f namespaces.yml</span><br></pre></td></tr></table></figure>
<h3 id="password"><a href="#password" class="headerlink" title="password"></a>password</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat passwd.sh</span><br><span class="line">    <span class="comment"># PASSWORD=$(head -c 12 /dev/urandom | sha1sum |cut -d&#x27; &#x27; -f1)</span></span><br><span class="line">    PASSWORD=admin123</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$PASSWORD</span> &gt; passwd</span><br><span class="line">    kubectl -n openfaas create secret generic basic-auth \</span><br><span class="line">    --from-literal=basic-auth-user=admin \</span><br><span class="line">    --from-literal=basic-auth-password=<span class="string">&quot;<span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line">$ sh ./passwd.sh</span><br></pre></td></tr></table></figure>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f ./yaml</span><br><span class="line">$ kubectl get pods -n openfaas --watch </span><br><span class="line"></span><br><span class="line">➜  ~ kubectl get pods -n openfaas</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">alertmanager-7dd959fd86-stslk        1/1     Running   0          3h30m</span><br><span class="line">basic-auth-plugin-85649fd6fc-4xlph   1/1     Running   0          3h30m</span><br><span class="line">faas-idler-f4597f655-6c4nb           1/1     Running   2          3h30m</span><br><span class="line">gateway-7c579bc859-cpm6g             2/2     Running   1          3h30m</span><br><span class="line">nats-8455bfbb58-gq2vh                1/1     Running   0          3h30m</span><br><span class="line">prometheus-86f7fdf9b5-jtb6q          1/1     Running   0          3h30m</span><br><span class="line">queue-worker-c6d788779-xl6d2         1/1     Running   0          3h30m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当全部启动时则正常部署成功</span></span><br></pre></td></tr></table></figure>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:31112</span><br><span class="line">admin/admin123</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>openfaas 默认带有一些可以部署的 function</p>
<h3 id="nodeinfo"><a href="#nodeinfo" class="headerlink" title="nodeinfo"></a>nodeinfo</h3><p><img src="http://blog.linkinstars.com//blog/image-20201019194703907.png" alt="image-20201019194703907"></p>
<p><img src="http://blog.linkinstars.com//blog/image-20201019194738010.png" alt="image-20201019194738010"></p>
<p>点击 deploy 之后等待状态 ready 之后就可以进行使用了，点击 invoke 进行调用，这个 function 是用来获取主机信息的。</p>
<h3 id="ocr"><a href="#ocr" class="headerlink" title="ocr"></a>ocr</h3><p><img src="http://blog.linkinstars.com//blog/image-20201019194944708.png" alt="image-20201019194944708"></p>
<p>这个 function 是用来做图像识别的</p>
<p>还有其他很多自带的 function 都可以试试，这里不再列举了</p>
<h3 id="qrcode"><a href="#qrcode" class="headerlink" title="qrcode"></a>qrcode</h3><p>其实很多 function 的实现是非常简单的，如这个生成二维码的 function，使用 go 实现，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	qrcode <span class="string">&quot;github.com/skip2/go-qrcode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	input, err := ioutil.ReadAll(os.Stdin)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Unable to read standard input: %s&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	png, err := qrcode.Encode(<span class="keyword">string</span>(input), qrcode.Medium, <span class="number">256</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Unable to read standard input: %s&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	binary.Write(os.Stdout, binary.LittleEndian, png)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是调用了一个三方的库，在 main 函数中从 std 读如参数，然后将结果输出到 stdout 中就可以了，就其实和我们普通写的函数一模一样。</p>
<h2 id="实现function"><a href="#实现function" class="headerlink" title="实现function"></a>实现function</h2><p>那么如何自己实现一个 function 并注册使用呢？其实也很简单，现在 faas-cli 工具已经提供了相关的功能，这里说明使用 golang 来时进实现的方式，其他语言也是类似的。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建一个空目录，在空目录下使用  faas-cli 命令进行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">faas-cli new hellofaas --lang go</span><br></pre></td></tr></table></figure>
<p>这样你就能得到一个基础的功能目录</p>
<p>hellofaas 文件夹中包含一个 go 文件，这个文件就是你需要自己实现的 function，里面是一个 http 请求的 handle，接受一个参数，返回一个字符串，函数中你可以实现你自己的逻辑功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle a serverless request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(req []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hello, Go. You said: %s&quot;</span>, <span class="keyword">string</span>(req))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置镜像参数"><a href="#配置镜像参数" class="headerlink" title="配置镜像参数"></a>配置镜像参数</h3><p>hellofaas.yml 文件是用来部署和上传镜像的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">provider:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">openfaas</span></span><br><span class="line">  <span class="attr">gateway:</span> <span class="string">http://127.0.0.1:31112</span></span><br><span class="line"><span class="attr">functions:</span></span><br><span class="line">  <span class="attr">hellofaas:</span></span><br><span class="line">    <span class="attr">lang:</span> <span class="string">go</span></span><br><span class="line">    <span class="attr">handler:</span> <span class="string">./hellofaas</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">linkinstar/hellofaas:latest</span> </span><br></pre></td></tr></table></figure>
<p>其中需要修改的是 gateway 为你自己的 faas 部署地址</p>
<p>然后就是 images 是你 docker hub 的地址，如果需要推送到私有仓库需要你手动进行登录操作</p>
<h3 id="构建、推送、部署"><a href="#构建、推送、部署" class="headerlink" title="构建、推送、部署"></a>构建、推送、部署</h3><p>剩下就很简单了，三个命令，构建时间可能会长一些，拉取镜像比较缓慢</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">faas-cli build -f hellofaas.yml</span><br><span class="line">faas-cli push -f hellofaas.yml</span><br><span class="line">faas-cli deploy -f hello.yml --gateway http://127.0.0.1:31112</span><br></pre></td></tr></table></figure>
<p>如果没有问题，那么在页面上你就可以看到你自己的 function 了</p>
<p><img src="http://blog.linkinstars.com//blog/image-20201019204020609.png" alt="image-20201019204020609"></p>
<p>当然你也可以这样调用：</p>
<p><code>echo test | faas-cli invoke hellofaas --gateway http://127.0.0.1:31112</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实对于 faas 的使用还算简单，并没有想象中的那么复杂，它的实现方式也比较符合我的想法，作为一个镜像进行打包进行输出进行使用，而且支持各种语言进行实现，也不失为一种比较好的实现策略吧。</p>
<p>我觉得更多的是 function 的这样的思想，让我们要意识到，什么样类型的功能能被抽离为一个 function ，并且这个的 function 是否应该有业务属性，以及它作为一个 service 的定义是什么，这我觉得是我们应该考虑的。因为它很轻，轻的东西就容易多，多的东西就不好管控，所以控制方面也应该做考虑。</p>
<p>总之要认清它的目标和使用场景还是一个比较难得事情。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.lanqiao.cn/library/kubernetes-handbook/usecases/openfaas-quick-start/">https://www.lanqiao.cn/library/kubernetes-handbook/usecases/openfaas-quick-start/</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1681551">https://cloud.tencent.com/developer/article/1681551</a></p>
<p><a href="http://www.liangxiaolei.fun/2020/06/11/k8s%E7%AC%94%E8%AE%B0-serverless-openfaas%E4%BD%93%E9%AA%8C/">http://www.liangxiaolei.fun/2020/06/11/k8s%E7%AC%94%E8%AE%B0-serverless-openfaas%E4%BD%93%E9%AA%8C/</a></p>
<p><a href="https://linux.cn/article-9078-1.html">https://linux.cn/article-9078-1.html</a></p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>faas</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手terraform —— 阿里云OSS和ECS的创建</title>
    <url>/post/4779b75d.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近在研究terraform，采了一圈坑，记录一下。</p>
<p>什么是terraform？terraform 通过代码配置实现物理机等一些资源的分配。简单说就是，写一个配置文件，启动，就能帮你购买一台云的机器，或者说申请到oss的资源，或者是别的什么。具体功能见官网。<br><span id="more"></span></p>
<p><a href="https://www.terraform.io/docs/index.html">https://www.terraform.io/docs/index.html</a></p>
<p>名词解释：provider你可以把它看做各个厂商对terraform提供的插件，terraform可以调用这些插件从而实现对资源的操作管理。<br>terraform流程：init -&gt; plan -&gt; apply -&gt; destroy<br>对应为：初始化，计划验证，实际应用，销毁</p>
<h2 id="最小demo"><a href="#最小demo" class="headerlink" title="最小demo"></a>最小demo</h2><p>我将用一个最小的demo来演示它怎么干活的：通过terraform来创建一个阿里云的oss<br>（以下没有利益相关）只是因为阿里云我有账号而已，其他供应商也有。</p>
<p>我的本地环境：macOS</p>
<h3 id="步骤1-下载相关资源"><a href="#步骤1-下载相关资源" class="headerlink" title="步骤1 下载相关资源"></a>步骤1 下载相关资源</h3><p>下载对应的客户端：<a href="https://www.terraform.io/downloads.html">https://www.terraform.io/downloads.html</a><br>下载解压后得到：terraform的客户端，将它复制到 <code>/usr/local/bin</code> 目录下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ terraform -version</span><br><span class="line">Terraform v0.12.13</span><br></pre></td></tr></table></figure><br>验证一下，输出版本正常的话就好了</p>
<p>下载阿里云对应provider：<a href="https://releases.hashicorp.com/terraform-provider-alicloud/1.60.0/">https://releases.hashicorp.com/terraform-provider-alicloud/1.60.0/</a><br>我下载的版本为：terraform-provider-alicloud_1.60.0_darwin_amd64.zip</p>
<p>放置到一个你喜欢的目录下，我这边为<code>/Users/LinkinStar/Documents/tf-plugin</code></p>
<h3 id="步骤2-申请阿里云相关资源"><a href="#步骤2-申请阿里云相关资源" class="headerlink" title="步骤2 申请阿里云相关资源"></a>步骤2 申请阿里云相关资源</h3><p>创建你的阿里云账号，这个不多说了。然后需要创建一个ram用户<br><a href="https://ram.console.aliyun.com/">https://ram.console.aliyun.com/</a><br>用户管理 -&gt; 新建用户 -&gt; 保存好AccessKey和Secret</p>
<p>注意！这里还需要对用户进行授权，点击授权给到相关权限就行，我给了全部，方便测试</p>
<h3 id="步骤3-编写文件"><a href="#步骤3-编写文件" class="headerlink" title="步骤3 编写文件"></a>步骤3 编写文件</h3><p>随便创建一个工作目录，然后创建一个tf文件main.tf<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Configure the Alicloud Provider</span><br><span class="line">provider &quot;alicloud&quot; &#123;</span><br><span class="line">  access_key = &quot;LTAIaskjfhadsklfhklasdjfhdsakjlfhdask&quot;</span><br><span class="line">  secret_key = &quot;6GPashfjksladfhdjskafhdsklajfdhaljfhajfl&quot;</span><br><span class="line">  region     = &quot;cn-beijing&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;alicloud_oss_bucket&quot; &quot;bucket-acl&quot; &#123;</span><br><span class="line">  bucket = &quot;bucket-123456654321-acl&quot;</span><br><span class="line">  acl    = &quot;private&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 access_key 和 secret_key 为你刚才申请ram的信息<br>bucket 的名称你随便取一个</p>
<h3 id="步骤4-运行命令"><a href="#步骤4-运行命令" class="headerlink" title="步骤4 运行命令"></a>步骤4 运行命令</h3><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>以下命令均在tf文件当前目录下运行<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">terraform init -plugin-dir=/Users/LinkinStar/Documents/tf-plugin</span><br></pre></td></tr></table></figure><br>注意后面的目录是我们刚才下载的provider的目录<br>出现 Terraform has been successfully initialized! 为成功</p>
<h4 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h4><p>然后使用命令 <code>terraform plan</code> 出现以下信息<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  # alicloud_oss_bucket.bucket-acl will be created</span><br><span class="line">  + resource &quot;alicloud_oss_bucket&quot; &quot;bucket-acl&quot; &#123;</span><br><span class="line">      + acl               = &quot;private&quot;</span><br><span class="line">      + bucket            = &quot;bucket-123456654321-acl&quot;</span><br><span class="line">      + creation_date     = (known after apply)</span><br><span class="line">      + extranet_endpoint = (known after apply)</span><br><span class="line">      + force_destroy     = false</span><br><span class="line">      + id                = (known after apply)</span><br><span class="line">      + intranet_endpoint = (known after apply)</span><br><span class="line">      + location          = (known after apply)</span><br><span class="line">      + owner             = (known after apply)</span><br><span class="line">      + storage_class     = &quot;Standard&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure></p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>运行命令 <code>terraform apply</code> 过程中需要输出yes确认<br>出现以下信息就证明成功了：<br><code>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</code></p>
<p>你可以到：<a href="https://oss.console.aliyun.com/overview">https://oss.console.aliyun.com/overview</a><br>查看OSS是否已经被创建</p>
<h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><p>最后运行命令 <code>terraform destroy</code> 过程中需要输出yes确认<br>刚才创建的OSS资源就会被销毁，你可以再在网上刷新一下查看</p>
<p>以上就是通过terraform进行的资源操作，同样的，你可以修改tf文件进行更多资源的操作</p>
<h2 id="对ECS进行操作"><a href="#对ECS进行操作" class="headerlink" title="对ECS进行操作"></a>对ECS进行操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Configure the Alicloud Provider</span><br><span class="line">provider &quot;alicloud&quot; &#123;</span><br><span class="line">  access_key = &quot;LTAIaskjfhadsklfhklasdjfhdsakjlfhdask&quot;</span><br><span class="line">  secret_key = &quot;6GPashfjksladfhdjskafhdsklajfdhaljfhajfl&quot;</span><br><span class="line">  region     = &quot;cn-hangzhou&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Create a new ECS instance for a VPC</span><br><span class="line">resource &quot;alicloud_security_group&quot; &quot;group&quot; &#123;</span><br><span class="line">  name        = &quot;tf_test_foo&quot;</span><br><span class="line">  description = &quot;foo&quot;</span><br><span class="line">  vpc_id      = &quot;$&#123;alicloud_vpc.vpc.id&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">resource &quot;alicloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  name       = &quot;tf_test_foo&quot;</span><br><span class="line">  cidr_block = &quot;172.16.0.0/12&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;alicloud_vswitch&quot; &quot;vswitch&quot; &#123;</span><br><span class="line">  vpc_id            = &quot;$&#123;alicloud_vpc.vpc.id&#125;&quot;</span><br><span class="line">  cidr_block        = &quot;172.16.0.0/21&quot;</span><br><span class="line">  availability_zone = &quot;cn-hangzhou-i&quot;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">resource &quot;alicloud_instance&quot; &quot;instance&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-hangzhou-i&quot;</span><br><span class="line">  security_groups   = &quot;$&#123;alicloud_security_group.group.*.id&#125;&quot;</span><br><span class="line">  instance_type              = &quot;ecs.t6-c2m1.large&quot;</span><br><span class="line">  system_disk_category       = &quot;cloud_efficiency&quot;</span><br><span class="line">  image_id                   = &quot;ubuntu_18_04_64_20G_alibase_20190624.vhd&quot;</span><br><span class="line">  instance_name              = &quot;test_foo&quot;</span><br><span class="line">  vswitch_id                 = &quot;$&#123;alicloud_vswitch.vswitch.id&#125;&quot;</span><br><span class="line">  </span><br><span class="line">  internet_max_bandwidth_out = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://blog.linkinstars.com/mweb/15733034184247.jpg" alt></p>
<p>需要注意的是你的账户余额必须&gt;100块，否则会提示余额不足，我这边tf里面写的是非常便宜几分钱一个小时的机器，所以问题不大，你要是害怕你可以不测（再说一遍本文没有利益相关）</p>
<h2 id="相关资源总结"><a href="#相关资源总结" class="headerlink" title="相关资源总结"></a>相关资源总结</h2><p>provider下载地址：<a href="https://releases.hashicorp.com/">https://releases.hashicorp.com/</a><br>provider相关文档：<a href="https://www.terraform.io/docs/providers/index.html">https://www.terraform.io/docs/providers/index.html</a></p>
<h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><ul>
<li>国内的墙导致直接执行init是不可以的，它会去官方拉取provider但是会报错，必须手动下载provider并指定-plugin-dir，呼吸不到外面的新鲜空气有点难受。</li>
<li>terraform的文档都是英文的并且provider给到的参数选项不全，不知道该填什么。</li>
<li>阿里云创建的ram用户默认没有权限。</li>
<li>阿里云需要100块？！我充10块钱不行吗？我又花不了那么多，弄得我晚饭都吃不起了。</li>
<li>阿里云很多地区是没有便宜的机器卖的，一直提示我机器没有，很难受。</li>
</ul>
<p>PS: 以上TF文件均用来测试，所以一些变量没有做抽离，实际使用一些变量如key等会抽离成别的文件统一管理，别被我带跑偏了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说使用tf对于资源的申请还是非常方便的，一个文件就可以搞定，可以做到随时使用随时销毁，同时也支持多次apply对资源进行更新和操作。它不仅可以对服务器进行操作，还有很多公有云的资源如dns等进行操作，并且现在provider支持的厂商很多。</p>
<p>原理相关的博客后续有机会补充，希望不会鸽。</p>
]]></content>
      <categories>
        <category>terraform</category>
      </categories>
      <tags>
        <tag>terraform</tag>
      </tags>
  </entry>
  <entry>
    <title>不是我吹，你可能连defer都不清楚</title>
    <url>/post/48e6221e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在golang中，对于defer，我之前的理解就是和java中的finally代码块一样，没什么难度，但是吧，当我最近看的一些神奇的问题，我就发现原来并非想的那么简单。</p>
<span id="more"></span>
<h2 id="先举个栗子"><a href="#先举个栗子" class="headerlink" title="先举个栗子"></a>先举个栗子</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(DeferFunc1(<span class="number">1</span>))</span><br><span class="line">    fmt.Println(DeferFunc2(<span class="number">1</span>))</span><br><span class="line">    fmt.Println(DeferFunc3(<span class="number">1</span>))</span><br><span class="line">    DeferFunc4()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc1</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t = i</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc2</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    t := i</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc3</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += i</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc4</span><span class="params">()</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        fmt.Println(t)</span><br><span class="line">    &#125;(t)</span><br><span class="line">    t = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问这段代码输出的结果是什么？<br><br><br><em>答案见文末</em><br><br><br>如果你看完答对了，那么请直接点击右上角的关闭按钮，如果你答错了，你可以继续往下看了。<br>下面会一步步介绍，到底为什么结果会是这样</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="函数的返回值初始化"><a href="#函数的返回值初始化" class="headerlink" title="函数的返回值初始化"></a>函数的返回值初始化</h3><p>如 ： <code>func DeferFunc1(i int) (t int) &#123;</code><br>其中返回值t int，这个t会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。</p>
<h3 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h3><p>虽然这边没有提及，但是还是要说一下，因为很多人学习defer的时候都会用到，就是当多个defer出现的时候，<strong>它是一个“栈”的关系，也就是先进后出</strong>。一个函数中，写在前面的defer会比写在后面的defer调用的晚。</p>
<h3 id="defer与return谁先谁后"><a href="#defer与return谁先谁后" class="headerlink" title="defer与return谁先谁后"></a>defer与return谁先谁后</h3><p>return先，defer后<br>这个可能会让人怀疑，后面会详细解释。</p>
<h3 id="函数的返回与return"><a href="#函数的返回与return" class="headerlink" title="函数的返回与return"></a>函数的返回与return</h3><p>在没有defer的情况下，其实函数的返回就是与return一致的，但是有了defer就不一样了。<br>函数的返回其实是有两个步骤的，第一个当执行到return语句的时候<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc3</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += i</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个时候会先将返回值t赋值为2，然后执行defer，完成之后才会真正返回外部调用者。</p>
<h3 id="defer调用的三步走"><a href="#defer调用的三步走" class="headerlink" title="defer调用的三步走"></a>defer调用的三步走</h3><p>这个就是今天的重头戏了，defer这个语法其实一共有三个步骤。</p>
<ol>
<li>将defer方法中的参数进行赋值。</li>
<li>将defer压入栈中。</li>
<li>当return或者是panic的时候依次出栈执行。<br>后面会用实际的例子说明具体执行的情况。</li>
</ol>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>有了上面的所有知识点，其实你就应该能明白上面输出的结果了。如果还不明白就看看下面的分析解释吧。</p>
<h3 id="DeferFunc1"><a href="#DeferFunc1" class="headerlink" title="DeferFunc1"></a>DeferFunc1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc1</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t = i</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先上面是第一个方法</p>
<ol>
<li>将返回值t赋值为传入的i，此时t为1</li>
<li>执行return语句将t赋值给t（等于啥也没做）</li>
<li>执行defer方法，将t + 3 = 4</li>
<li>函数返回 4<br>因为t的作用域为整个函数所以修改有效。</li>
</ol>
<h3 id="DeferFunc2"><a href="#DeferFunc2" class="headerlink" title="DeferFunc2"></a>DeferFunc2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc2</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    t := i</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个方法</p>
<ol>
<li>创建变量t并赋值为1</li>
<li>执行return语句，注意这里是将t赋值给返回值，此时返回值为1（这个返回值并不是t）</li>
<li>执行defer方法，将t + 3 = 4 </li>
<li>函数返回返回值1</li>
</ol>
<p>可能这里就有点难理解了，修改一下代码你就明白了<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc2</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t := i</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码return的时候相当于将t赋值给了result，当defer修改了t的值之后，对result是不会造成影响的。</p>
<h3 id="DeferFunc3"><a href="#DeferFunc3" class="headerlink" title="DeferFunc3"></a>DeferFunc3</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc3</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t += i</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先执行return将返回值t赋值为2</li>
<li>执行defer方法将t + 1</li>
<li>最后返回 3</li>
</ol>
<h3 id="DeferFunc4"><a href="#DeferFunc4" class="headerlink" title="DeferFunc4"></a>DeferFunc4</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferFunc4</span><span class="params">()</span> <span class="params">(t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        fmt.Println(t)</span><br><span class="line">    &#125;(t)</span><br><span class="line">    t = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个分析的步骤要详细一些</p>
<ol>
<li>初始化返回值t为零值 0</li>
<li>首先执行defer的第一步，赋值defer中的func入参t为0</li>
<li>执行defer的第二步，将defer压栈</li>
<li>将t赋值为1</li>
<li>执行return语句，将返回值t赋值为2</li>
<li>执行defer的第三步，出栈并执行<br>因为在入栈时defer执行的func的入参已经赋值了，此时它作为的是一个形式参数，所以打印为0；相对应的因为最后已经将t的值修改为2，所以再打印一个2</li>
</ol>
<h2 id="源码一瞥"><a href="#源码一瞥" class="headerlink" title="源码一瞥"></a>源码一瞥</h2><p>那么 defer 在底层究竟是如何实现的呢？<br>通过生成汇编代码我们可以看到下面这样的方法：<br>CALL runtime.deferproc(SB)<br>CALL runtime.deferreturn(SB)<br>实际上来说当我们使用defer的使用就会调用runtime.deferproc，那么这个时候，就会将所有的参数赋值好，所有就像我们上面例子中看到的一样，在调用defer的时候参数会先计算好保存起来，然后挂载到G._defer中，最后deferreturn的时候进行执行相关的defer中的方法<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123; <span class="comment">// arguments of fn follow fn</span></span><br><span class="line">     sp := getcallersp(unsafe.Pointer(&amp;siz))</span><br><span class="line">     argp := <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)</span><br><span class="line">     callerpc := getcallerpc(unsafe.Pointer(&amp;siz))</span><br><span class="line">     systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            d := newdefer(siz)</span><br><span class="line">&#125;)</span><br><span class="line">d.fn = fn</span><br><span class="line">d.pc = callerpc</span><br><span class="line">d.sp = sp</span><br><span class="line">memmove(add(unsafe.Pointer(d), unsafe.Sizeof(*d)),</span><br><span class="line">       unsafe.Pointer(argp), <span class="keyword">uintptr</span>(siz))</span><br><span class="line">     <span class="comment">// deferproc returns 0 normally.</span></span><br><span class="line">     <span class="comment">// a deferred func that stops a panic makes the deferproc return 1.</span></span><br><span class="line">     <span class="comment">// the code the compiler generates always checks the return value and jumps to the</span></span><br><span class="line">     <span class="comment">// end of the function if deferproc returns != 0.</span></span><br><span class="line">     return0()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完，有的人肯定又要出来搞事了，说这个在实际中不会遇到的，实际中谁写这么蠢的代码。但是其实某些时候非常重要，当我们需要在defer中返回一些错误信息的时候，并且需要将这些信息给到调用者的时候，就需要注意变量的作用域以及执行顺序所带来的差异。</p>
<p>而且正因为这样的执行顺序，在实际中要记住：<br><strong>defer 最大的功能是 panic 后依然有效</strong><br>所以defer可以保证你的一些资源一定会被关闭，从而避免一些异常出现的问题。</p>
<p>参考例子来源于网络，自己做了修改和结合：<br><a href="https://stackoverflow.com/questions/52718143/is-golang-defer-statement-execute-before-or-after-return-statement">https://stackoverflow.com/questions/52718143/is-golang-defer-statement-execute-before-or-after-return-statement</a></p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>4<br>1<br>3<br>0<br>2</p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>defer</tag>
      </tags>
  </entry>
  <entry>
    <title>Weave Scope 监控 k8s 集群</title>
    <url>/post/2580a453.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前一直在寻找一个 k8s 监控的工具，因为一直使用的是本地的 lens 的客户端，虽然使用上已经非常方便了，但是其实对于资源消耗的监控少了一点，有些资源消耗并不是能容易看到，并且服务间依赖是没有办法表现出来的，后来发现了 Weave Scope 满足了我的需求。</p>
<span id="more"></span>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/weaveworks/scope">https://github.com/weaveworks/scope</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>资源监控：能实时反映整个集群中的资源状况 cpu 内存 使用情况 并且支持各种角度</li>
<li>服务间依赖：能通过图形展现出服务之间访问的依赖关系</li>
<li>容器交互：实时查看日志和描述信息</li>
<li>支持插件：可以通过插件扩展</li>
<li>部署方便：一个命令即可部署完成</li>
</ul>
<h2 id="监控页面"><a href="#监控页面" class="headerlink" title="监控页面"></a>监控页面</h2><h3 id="资源监控"><a href="#资源监控" class="headerlink" title="资源监控"></a>资源监控</h3><p><img src="http://blog.linkinstars.com//blog/weavescope-hosts-memory-stat.png" alt="weavescope-hosts-memory-stat"></p>
<p>可以清楚的看到每个 node 的资源使用情况</p>
<h3 id="服务间依赖"><a href="#服务间依赖" class="headerlink" title="服务间依赖"></a>服务间依赖</h3><p><img src="http://blog.linkinstars.com//blog/weavescope-service-dependcy.png" alt="weavescope-service-dependcy"></p>
<p>因为内部服务与服务之间通过 rpc 进行交互，从这里可以很容易看出，某个服务被别的五个服务所依赖调用</p>
<h3 id="容器交互"><a href="#容器交互" class="headerlink" title="容器交互"></a>容器交互</h3><p><img src="http://blog.linkinstars.com//blog/weacescope-pod-interaction.png" alt="weacescope-pod-interaction"></p>
<p>可以看到占用的 cpu 和内存的情况，然后占用的端口等，还有日志信息</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>支持直接部署在 k8s 集群中，不需要额外的任何配置</p>
<p><a href="https://www.weave.works/docs/scope/latest/installing/#k8s">https://www.weave.works/docs/scope/latest/installing/#k8s</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面一个命令就能部署完成了</span></span><br><span class="line">kubectl apply -f <span class="string">&quot;https://cloud.weave.works/k8s/scope.yaml?k8s-version=<span class="subst">$(kubectl version | base64 | tr -d &#x27;\n&#x27;)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过下面的命令临时暴露端口转发到本地进行访问</span></span><br><span class="line">kubectl port-forward -n weave <span class="string">&quot;<span class="subst">$(kubectl get -n weave pod --selector=weave-scope-component=app -o jsonpath=&#x27;&#123;.items..metadata.name&#125;&#x27;)</span>&quot;</span> 4040</span><br></pre></td></tr></table></figure>
<p>访问本地： <a href="http://localhost:4040">http://localhost:4040</a></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><a href="https://github.com/weaveworks-plugins/">https://github.com/weaveworks-plugins/</a></p>
<p>比如有一个 http 流量统计的插件：<a href="https://github.com/weaveworks-plugins/scope-http-statistics">https://github.com/weaveworks-plugins/scope-http-statistics</a></p>
<p>不过现在还并不是很多，但是基本功能其实已经足够了</p>
<h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><p><a href="https://www.weave.works/docs/scope/latest/faq/">https://www.weave.works/docs/scope/latest/faq/</a></p>
<p>支持最简单的一个 http 鉴权，如果有需要可以设置对应参数</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你需要一个资源监控的工具，并且觉得上面的信息就是你需要的，可以尝试使用下，目前是我比较推荐的一个集群监控。</p>
<p>当然它也有个我认为的小不足：其实服务复杂的时候，服务间的依赖也会非常复杂，而且页面不支持拖动，就有的时候有点“难看”，如果拓扑中的节点支持拖动其实就蛮不错的，个人想法。</p>
<p>相关链接：<a href="https://www.cnblogs.com/linuxk/p/10560022.html">https://www.cnblogs.com/linuxk/p/10560022.html</a></p>
]]></content>
      <categories>
        <category>Weave-Scope</category>
      </categories>
      <tags>
        <tag>Weave-Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>图解golang内存分配</title>
    <url>/post/b0bf4e5c.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们知道所有程序运行都需要使用内存，而内存的管理和分配又是非常重要的，它决定了你的程序能不能在有限的资源内跑的更快。可以设想一下，如果你自己来设计的一个内存分配的规则，会遇到什么问题呢？如果你有了一大块内存你要怎么去合理的分配和使用呢？今天我们通过几张图来看看golang中的内存分配是怎样的。</p>
<span id="more"></span>
<p>前置知识：对golang的GPM模型有所了解，对GC有一定的了解，有助于你理解下面的内容。</p>
<h2 id="想一想"><a href="#想一想" class="headerlink" title="想一想"></a>想一想</h2><p>我们首先来想一下，如果我们自己来分配内存的时候可能会遇到什么问题。</p>
<h3 id="我想要512G，你能给吗？"><a href="#我想要512G，你能给吗？" class="headerlink" title="我想要512G，你能给吗？"></a>我想要512G，你能给吗？</h3><p>操作系统的内存不是你想要多少就给你多少的。比如我跟操作系统说我要512G内存，你赶紧给我，不给我我就掐死你，如果你是操作系统，是不是立马就想把我给结束了？</p>
<h3 id="能随便分割吗？"><a href="#能随便分割吗？" class="headerlink" title="能随便分割吗？"></a>能随便分割吗？</h3><p>如果我拿到一块内存，挺大的，你把它想象成一块地，我今天要用这块地的这个部分，肯定是从中间切一块出来用，然后明天要另一个部分，然后再切出来一部分。如果随便切，今天要一块三角形，明天要一块圆形，那么肯定会留有很多小块的地方，那些地方没有办法被合理的使用，就会浪费。等到想再要一块正方形的地的时候发现没地方可以切了。</p>
<h3 id="不用了我需要放回去吗？"><a href="#不用了我需要放回去吗？" class="headerlink" title="不用了我需要放回去吗？"></a>不用了我需要放回去吗？</h3><p>如果我占用了很大一块内存资源，然后用完了，现在不需要了，那自私的人肯定想着，我就偷偷一直占用不行吗？显然是不可以的，不然的话你的应用程序就每天占用着一台机器大量的资源不释放，别的人都没得用了，肯定想把你干掉。所以用完了要放回去。</p>
<p>–<br>其实上面的问题就是内存分配常见的一些问题，那<strong>为了高效、合理利用内存</strong>，势必需要一些人的管理和帮助，下面我们就来看看那些在golang中的管理者，看看他们是如何帮助我们去管理和分配内存的。</p>
<h2 id="内存的管理者"><a href="#内存的管理者" class="headerlink" title="内存的管理者"></a>内存的管理者</h2><p><img src="http://blog.linkinstars.com/mweb/15726689114124.jpg" alt="-w505"><br>这张图里面就是golang中内存的管理者们，下面我来依次介绍一下</p>
<h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>首先是操作系统，他拥有着全部的机器内存，我们的程序必须向它要。但是他是大领导，很忙的，你不能没事总找他要，很烦，所以每次都会向他一大块内存（1M打底）他会给你一票地址，但是实际其实并不会直接给你分配内存，但是你用到了自然会有。</p>
<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p>这个是我们程序中最大的内存持有区域，堆，他管理着那些很大的内存块，同时是他向操作系统去申请内存的，全局只有他一个大人物。他还需要将从操作系统拿过来的内存进行一定的划分，划分成一整块一整块的样子方便管理，同时记录内存的使用情况，方便整理和回收。</p>
<h3 id="central"><a href="#central" class="headerlink" title="central"></a>central</h3><p>这个是二把手，有很多，他们会负责将内存划分成足够小的单元，同时需要向下提供内存的分配工作，这个时候就需要一些合理的分配措施了，这个我们后面再说。</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>这个是最后一个小领导了，管理着最终线程需要使用的内存资源，<strong>而且每个线程都会有一个独立的cache</strong>，一对一绑定，这样使用的时候就会直接从对应的cache中去取来使用，这样的好处是不用和别人发生争抢。如果所有的线程都从一个地方进行取用，那么势必会造成你也要用，我也要用的情况。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面的图我们可以基本明白一个总体的思路是说：需要有人总体去把控所有内存资源的使用，做到统一的调度和管理，这样可以方便后续的回收和利用。同时需要下面有人负责最终使用的分配，从而能达到一个内存的快速分配而不发生争抢。</p>
<h2 id="内存的分配结构"><a href="#内存的分配结构" class="headerlink" title="内存的分配结构"></a>内存的分配结构</h2><p>我们知道了内存的管理者是谁，那么现在我们再来看看内存到底是怎么划分的，究竟是切成一个个长方形还是切成一个个圆形了呢？<br><img src="http://blog.linkinstars.com/mweb/15726829058612.jpg" alt="-w594"></p>
<p>这张图就表示了整个golang中内存的分配结构长什么样子。</p>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>这块区域最大，明显就是用来存放我们最终的对象，里面分成了一个个8K大小的房间，每个房间我们称为page。（这里虽然写了它是512G，但是你心里要有B数，你电脑根本没这么大的内存，其实操作系统只是给了你地址而已）同时几个page组合在一起的大房间又叫做mspan（这个是golang中内存管理的基本单元）</p>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>然后我们再来看第二大的bitmap，它是用来表示arena中存放的对象的一些信息，包括这个对象GC标志，还有标识这个对象是否包含指针。你肯定就好奇，干嘛要有这个呢？这其实也很好理解，golang在进行垃圾回收的时候是根据引用的可达性分析来确定一个对象是否可以被回收，同时采用的是三色标记法进行标记对象，所以这里需要有bitmap来保存这些信息。（具体如果不清楚垃圾回收的细节可以去看看我之前写的有关垃圾回收的部分）</p>
<h3 id="spans"><a href="#spans" class="headerlink" title="spans"></a>spans</h3><p>最后是spans，这里保存了mspan的指针，这个也好理解，为了方便管理那一个个大房间嘛</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>那么最后我们来看看我们创建的一个对象最后究竟会经历些什么，是怎么样分配的呢？<br>首先要说明的是，golang很聪明的，如果一个变量可以分配在栈上，那么就不会被分配在堆上，这样可以有效的节约资源（具体我后续还会写别的来说明golang中的变量）。总之我们这里讨论的是分配在堆上的情况。<br><img src="http://blog.linkinstars.com/mweb/15726846463324.jpg" alt="-w794"><br>整个流程差不多类似就是这样，嗯，你只要把内存想象成房间，现在房价那么贵，你懂的</p>
<h3 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h3><ol>
<li>大对象： &gt;32KB 的对象，直接从heap上分配</li>
<li>小对象： 16B &lt; obj &lt;= 32KB 计算规格在mcache中找到合适大小的mspan进行分配（你有多大就住多大的房子竟可能的不要浪费房子的空间）</li>
<li>微小对象： &lt;=16B 的对象使用mcache的tiny分配器分配；（如果将多个微小对象组合起来，用单块内存（object）存储，可有效减少内存浪费。）</li>
</ol>
<p>秉持原则：给到最合适的大小，然后能凑一起的凑一起挤一挤</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>如果不够怎么办呢？不够肯定就要扩容了呗，当不够的时候就会向领导上报，逐层上报，最终想办法拿到内存。<br>如果cache没有相应规格大小的mspan，则向central申请<br>如果central没有相应规格大小的mspan，则向heap申请<br>如果heap中也没有合适大小的mspan，则向操作系统申请</p>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p>最后还要记得，如果你用完了，不用了，会有后台的清洁工来回收掉，最终还是会还回去的。一方面呢：cache用完了还给central，central就可以给别的cache用；central用完了就会还给heap…最终都不用的还给操作系统</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>至此golang的内存分配也就说的差不多了，其中一些细节可能没有说到，可能你还需要看看别的文章来补一补。总结一下：</p>
<ol>
<li>你多大人住多大的房间，不多给</li>
<li>划分成合理的大小可以一起给一起回收，大小合适的分割才不会浪费</li>
<li>用完还回去，需要标记怎么样算用完了</li>
<li>每个人线程有独立的缓冲区来进行快速分配，不用抢来抢去</li>
</ol>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>实现分布式锁，你能想到什么？</title>
    <url>/post/43f42137.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>所谓分布式锁，即在多个相同服务水平扩展时，对于同一资源，能稳定保证有且只有一个服务获得该资源 — by LinkinStar </p>
<p>其实对于分布式锁，也是属于那种看似简单，实则有很多细节的问题。很多人在被问到这个问题的时候，一上来就会说用redis嘛，setnx嘛，我知道我知道。但仅仅是这样就能搞定了吗？那么当我们在实现一个分布式锁的时候，我们究竟需要考虑些什么呢？</p>
<span id="more"></span>
<h2 id="必考点"><a href="#必考点" class="headerlink" title="必考点"></a>必考点</h2><p>首先作为一个分布式锁，你一定要保证的是什么呢？</p>
<ul>
<li>不能有两个服务同时获取到一把锁（资源）</li>
<li>不能出现有一个资源一直被锁住（锁一直被持有）</li>
</ul>
<p>我认为上面两点是必须要保证的，其他的点，比如锁的获取是否高效，锁获取的非阻塞等等是评价一个锁是否好用的点（当然也不是说不重要）</p>
<p>下面我们一个个实现方案来说，来看看究竟有多少细节是我们需要考虑的。</p>
<h2 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h2><p>先从最普遍的实现方案开始说起，redis。利用redis的特性，nx，资源不存在时才能够成功执行 set 操作，同时设置过期时间用于防止死锁</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>SET resource_key random_value NX PX lock-time</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>DEL resource_key</p>
<p>面试者往往能给出这样的方案，那么这样的实现足够了吗？</p>
<h3 id="问题1-解锁方式靠谱吗？"><a href="#问题1-解锁方式靠谱吗？" class="headerlink" title="问题1 解锁方式靠谱吗？"></a>问题1 解锁方式靠谱吗？</h3><p>上面的解锁方式是通过删除对应的key实现的。那么会有什么问题呢？<br>如果程序是我们自己写的，那么我们一定能保证，如果需要主动释放锁的话，必须要先要获取到锁。（我们可以这样强制编码）<br>那么问题来了，其实这个任何人都可能主动调用解锁，只要知道key就可以了，而key是肯定知道的。<br>那么，如果我主动捣乱，我可以说直接手动先删除这个key然后我就一定能重新拿到这个锁了，这显然有漏洞了。<br>其实不只是这样的场景，有一些场景下，获取锁和释放锁的人确实不是一个，那么就会存在问题。</p>
<h3 id="问题1-解决"><a href="#问题1-解决" class="headerlink" title="问题1 解决"></a>问题1 解决</h3><p>方式1：强制规定只能使用过期解锁<br>方式2：验证存放的value是否为存放的时候的值来保证是同一人的行为<br>方式3：通过lua脚本进一步保证验证和是否为原子操作<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if redis.get(&quot;resource_key&quot;) ==  &quot;random_value&quot;</span><br><span class="line">    return redis.del(&quot;resource_key&quot;)</span><br><span class="line">else </span><br><span class="line">    return 0</span><br></pre></td></tr></table></figure></p>
<h3 id="问题2-redis挂了…"><a href="#问题2-redis挂了…" class="headerlink" title="问题2 redis挂了…"></a>问题2 redis挂了…</h3><p>redis万一挂了，那么对外来说，没有人能获取到锁，那么业务肯定会有问题。<br>这个时候小明马上会说了，那就redis集群，主从，哨兵…<br>那么相对应的问题就来了，如果在复制的过程中挂了，是否就有可能出现虽然获取到了锁但是锁丢失了的情况呢？</p>
<h3 id="问题2-解决方案"><a href="#问题2-解决方案" class="headerlink" title="问题2 解决方案"></a>问题2 解决方案</h3><p>那么redis早就想到了解决方案，Redlock（红锁）<br>如果你是第一次听到这个名字可能会觉得它有点独特和高级，其实并没有。。。<br>它利用的就是抽屉原理，或者称为大多数原理，就是当你要获取锁的时候，如果有5个节点，你必须要拿到其中3个才可以。并且获取锁的时间共计时间要小于锁的超时时间。<br>更加详细的可以参考官网：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a><br>这样能保证在最多挂掉2个节点的情况下，依旧能正常的时候（原来是5个）</p>
<h3 id="问题3-超时时间设定多久"><a href="#问题3-超时时间设定多久" class="headerlink" title="问题3 超时时间设定多久"></a>问题3 超时时间设定多久</h3><p>这个问题其实就很难了，无论是一开始的方案还是说对超时时间要求更高的redlock，超时时间的设定一直是一个难题；设定太长，可能在意外情况下会导致锁迟迟得不到释放；设定太短，事情还没做好，锁就被释放了；更有甚者提出，设定时间即使合适，那么由于网络、GC、等等不稳定因素也会导致意外情况发生。</p>
<h3 id="问题3-解决"><a href="#问题3-解决" class="headerlink" title="问题3 解决"></a>问题3 解决</h3><p>其实问题在不好解决，因为问题本身存在不确定因素。所以我们不能从问题本身出发，那么就尝试从业务出发解决。（我总不能告诉你说’设定5分钟，这样是最好的’这样类似的话吧）<br>方案是说：当我们获取锁之后获得一个类似乐观锁的标记token（或者说version）比如当前是33，当我们做完事情之后，需要主动更新数据时，如果发现当前当前的version已经为34（已经出现了别人获取到锁并且更新了数据），那么此次操作将不进行。<br>虽然这样看来直接用乐观锁不就好了吗？后面我们会提到。</p>
<h2 id="mysql实现"><a href="#mysql实现" class="headerlink" title="mysql实现"></a>mysql实现</h2><p>说完了 redis 的实现，那让我们来看看 mysql 的实现吧。mysql的实现方式就五花八门了，我们一个个来看看。</p>
<h3 id="mysql实现的优点"><a href="#mysql实现的优点" class="headerlink" title="mysql实现的优点"></a>mysql实现的优点</h3><p>我先来说说 mysql 实现的优点吧，因为马上可能就会有人问，为什么要用 mysql 去实现呢？redis它不香吗？主要原因我想了一下：</p>
<ul>
<li>如果没有redis（当前项目中未使用）如果多引入一个中间件势必带来维护成本</li>
<li>实现和使用简单（因为只需要操作mysql）</li>
<li>如果出现意外不用慌张（mysql 都挂了，你的业务系统也就凉了，能不能拿到锁已经是次要的了，反正就是要死一起死）</li>
</ul>
<h3 id="方案1-主键锁"><a href="#方案1-主键锁" class="headerlink" title="方案1 主键锁"></a>方案1 主键锁</h3><p>这个是最容易想到的，利用主键的唯一性。</p>
<ul>
<li>获取锁就是插入一条记录（相同的主键插入不进去）</li>
<li>释放锁就是删除一条记录</li>
</ul>
<h3 id="方案1-主键锁-问题"><a href="#方案1-主键锁-问题" class="headerlink" title="方案1 主键锁 问题"></a>方案1 主键锁 问题</h3><p>问题其实也是显而易见的</p>
<ul>
<li>没有超时时间，可能一直无法释放，这问题很大</li>
<li>会一直造成 mysql 报错，并发下性能堪忧</li>
</ul>
<h3 id="方案1-主键锁-解决"><a href="#方案1-主键锁-解决" class="headerlink" title="方案1 主键锁 解决"></a>方案1 主键锁 解决</h3><ul>
<li>可以设定一个入表时间，然后另外建立一个定时任务去清理过期的记录</li>
<li>可以在程序中记录一下当前的id最大值，来减少冲突发生的情况</li>
</ul>
<p>总之这样的方式实现只能说在并发量不高，只是简单要保证实现的基础做是可以的</p>
<h3 id="方案2-乐观锁"><a href="#方案2-乐观锁" class="headerlink" title="方案2 乐观锁"></a>方案2 乐观锁</h3><p>有关乐观锁就简单解释一下好了，就是添加一个 version 的字段，需要更新操作的时候，必须满足当前取出时的版本号。举个例子：我取出时的版本号是3，当我更新时那么就必须写着 update…… where version = 3 因为 mysql 的 mvcc 的控制能保证没有问题</p>
<h3 id="方案2-乐观锁-问题"><a href="#方案2-乐观锁-问题" class="headerlink" title="方案2 乐观锁 问题"></a>方案2 乐观锁 问题</h3><p>其实乐观锁的问题就在需要给业务添加 version 字段，这个对于业务是入侵的。<br>其次在并发情况下会增加大量的数据库无用操作，如果数据量大的话也挺难顶的。（这也是为什么上面在redis实现中加入类似version控制，而不直接使用乐观锁控制的原因）</p>
<h3 id="方案2-乐观锁-解决"><a href="#方案2-乐观锁-解决" class="headerlink" title="方案2 乐观锁 解决"></a>方案2 乐观锁 解决</h3><p>乐观锁其实挺乐观的，它就是用于哪些乐观的不会发生很大程度并发的情况，所以它的使用就看你的业务需求即可，有时即使没有 version 字段，也会合理使用。</p>
<h3 id="方案3-悲观锁"><a href="#方案3-悲观锁" class="headerlink" title="方案3 悲观锁"></a>方案3 悲观锁</h3><p>网上搜一圈你就会发现如下的分布式锁的实现：<a href="https://www.jianshu.com/p/b76f409b2db2">https://www.jianshu.com/p/b76f409b2db2</a></p>
<ul>
<li>开始事务</li>
<li>使用 <code>for update</code> 进行查询（如果能查询就表示能获取到锁）</li>
<li>做需要做的任务</li>
<li>提交事务（解锁）</li>
</ul>
<h3 id="方案3-悲观锁-问题"><a href="#方案3-悲观锁-问题" class="headerlink" title="方案3 悲观锁 问题"></a>方案3 悲观锁 问题</h3><p>于是你就会发现这个方案虽然可行，但是存在很多问题</p>
<ul>
<li>通过提交来解锁，那么整个事务持续时间会很长（有可能，根据你做的任务有关）</li>
<li>获取不到锁的会一直在等待，因为前一个问题导致</li>
<li>没有超时时间，存在锁一直不释放的情况，并且有可能导致事务一直被开启</li>
<li>高并发下 mysql 连接会很多</li>
<li>…</li>
</ul>
<p>所以小明想要改动一下看看能不能做的更好，于是有了下面的改动方案</p>
<h3 id="方案3-悲观锁-改动之旅"><a href="#方案3-悲观锁-改动之旅" class="headerlink" title="方案3 悲观锁 改动之旅"></a>方案3 悲观锁 改动之旅</h3><p>小明想到的第一个改动方案是，我要锁的 key 是 xxx</p>
<ol>
<li>BEGIN;</li>
<li>SELECT * FROM lock_tab WHERE key = ‘xxx’ FOR UPDATE;</li>
<li>INSERT xxx….;</li>
<li>COMMIT;</li>
</ol>
<p>当第二个步骤查询到了之后：</p>
<ul>
<li>如果没有数据，证明服务正在持有锁，那么此时进行新增就可以了，由于悲观锁的存在，别的服务是没有办法同时进行插入操作的；</li>
<li>如果有数据，证明已经有服务在持有锁，那么就直接放弃；</li>
<li>释放锁通过删除这条记录去释放</li>
</ul>
<p>那么，你想想，这样有问题吗？</p>
<p>有，问题就在释放锁的时候，这个删除操作有可能无法成功，因为有别的服务可能会持有悲观锁，特别是在并发量大，且重试较多的情况下，非常容易出现锁无法释放的情况。</p>
<hr>
<p>那再改改呗，手动删除这个操作肯定是不行的，这次小明想到超时机制，于是尝试加入字段过期时间，查询之后通过时间去判断是否超时，如果已经超时，也同时证明没有服务正在持有这把锁。<br>那这样会有问题吗？<br>有，当前这样查询是直接加的表锁。（当前表设计上没有索引）当我们要锁资源的时候我们肯定想的是最好去锁一行数据，而不要去锁整张表，这样不会影响到其他资源的抢锁，于是小明给表的key（资源名称）字段加了索引。测试了一下。</p>
<p>当前表格中的数据<br>id key val<br>1  aa  a2<br>2  bb  b3<br>3  cc  c4</p>
<p>T1</p>
<ul>
<li>BEGIN;</li>
<li>SELECT * FROM lock_tab WHERE <code>key</code>=’aa’ FOR UPDATE;</li>
</ul>
<p>T2</p>
<ul>
<li>BEGIN;</li>
<li>SELECT * FROM lock_tab WHERE <code>key</code>=’bb’ FOR UPDATE;（正常）</li>
<li>COMMIT;</li>
<li>BEGIN;</li>
<li>SELECT * FROM lock_tab WHERE <code>key</code>=’aa’ FOR UPDATE;（卡主）</li>
</ul>
<p>发现T2查询bb可以正常执行，也就是说，两个不同的资源不会互相干扰了（如果锁表的情况下，T2查询bb就会卡主）</p>
<p>还有问题吗？显然还有问题。<br>当前确实是行锁没错了，但是如果这个资源本身在表里面不存在会怎么样？<br>T1</p>
<ul>
<li>BEGIN;</li>
<li>SELECT * FROM lock_tab WHERE <code>key</code>=’zz’ FOR UPDATE;</li>
</ul>
<p>T2</p>
<ul>
<li>BEGIN;</li>
<li>SELECT * FROM lock_tab WHERE <code>key</code>=’zz’ FOR UPDATE;（正常???）</li>
</ul>
<p>没错这就是问题，当资源本身在表格中不存在的时候是能查询到的，也就是说可能造成有两个服务同时获取到锁，这是为什么呢？因为 mysql 当查询主键或索引无记录的并不会触发锁机制，也就是说，没东西锁，这个时候 mysql 是不会将                                                                                         行锁退化成表锁的。</p>
<p>显然这样的方案不可行，那么如何解决呢？<br>看起来解决的方式也只有锁表了，不然的话就是必须在表中优先创建资源所占用的数据，这样或许也就只能针对特定的场景锁进行了。</p>
<h3 id="方案3-悲观锁-总结"><a href="#方案3-悲观锁-总结" class="headerlink" title="方案3 悲观锁 总结"></a>方案3 悲观锁 总结</h3><p>那总的来说，对于悲观锁的实现，总结一下：</p>
<ol>
<li>如果只是单纯对于一个业务的某个场景，并且这个场景下持有锁的时间很短暂，那么选择第一种，直接开启事务，并在事务中获得锁，通过提交事务来释放锁。</li>
<li>如果对于锁的业务不定，并且锁持有的时间较长，那么使用第二种，每次获取锁通过for update先锁表，然后通过插入数据来完成持有锁的操作，仅利用过期时间这一条件来释放锁，这样能最大程度的更快提交事务，不必占用过多资源也不会造成不必要的等待时间。</li>
<li>如果面对已知数量的业务场景，可以明确提前给出锁的对象，那么使用第三种，在第二种方式的基础上，在表中加入提前创建锁的对象，并建立索引来完成对于行的锁定，从而不会影响其他资源的锁定。最大限度保证锁的细粒度。</li>
</ol>
<h2 id="ETCD实现"><a href="#ETCD实现" class="headerlink" title="ETCD实现"></a>ETCD实现</h2><p>说了redis、说了mysql、可能很多人认为下面提到的应该是zk了。其实zk也并不失为一种很好的解决方案，但是由于篇幅不想拉的过长，我更想介绍一下ETCD的实现。</p>
<p>ETCD 在 K8S 火了之后也就自然被带火了，多的我就不介绍了，对于很多分布式场景存储的实现总会提到它，现在我们关注一下如何用它来实现分布式锁呢？</p>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>其实 ETCD 的实现分布式锁思路和 Redis 类似，只不过 ETCD 本身没有一个操作叫做SET NX或类似操作，我们需要使用 ETCD 的事务来帮助实现这个操作，从而实现如果查询到没有就set这样一个原子操作。下面是go实现中的部分代码片段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   kv := clientv3.NewKV(client)</span><br><span class="line">   txn := kv.Txn(context.TODO())</span><br><span class="line">txn.If(clientv3.Compare(clientv3.CreateRevision(<span class="string">&quot;/lock-key/uuid&quot;</span>), <span class="string">&quot;=&quot;</span>, <span class="number">0</span>)).</span><br><span class="line">	Then(clientv3.OpPut(<span class="string">&quot;/lock-key/uuid&quot;</span>, <span class="string">&quot;xxx&quot;</span>, clientv3.WithLease(leaseId))).</span><br><span class="line">	Else(clientv3.OpGet(<span class="string">&quot;/lock-key/uuid&quot;</span>))</span><br><span class="line"></span><br><span class="line">txnResp, err := txn.Commit()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !txnResp.Succeeded &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;锁被占用:&quot;</span>, <span class="keyword">string</span>(txnResp.Responses[<span class="number">0</span>].GetResponseRange().Kvs[<span class="number">0</span>].Value))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果仅仅只是这样，那我也不会单独拿出来重点说了，它可并不只是这样。</p>
<ul>
<li>ETCD 有着租约机制，什么意思呢？当你申请获得一个租约之后，它有一定的时间，在这个时间之内 key 都是有效的，但是租约到期了之后，key 就会被自动删除了。有点类似 redis 的过期，但是它有续租的概念，过一段时间可以主动进行续租，这样你又能获得一段时间的租约。</li>
</ul>
<p>那么利用这个租约机制，我们是可以实现出一种逻辑，就是当任务在进行的过程中，不断的去更新我们的租约，能保证我们在做任务的阶段一定是持有锁的，不会出现任务还在进行中，但是锁已经失效的情况。并且可以使用在任务时长无法控制的情况下，如：当前任务需要跑1分钟，可能下一次同一个任务需要跑1小时，无法确定合理的锁过期时间。</p>
<p>下面是在go中，使用<code>lease.KeepAlive</code>自动续租，而用 context 的 cancelFunc 来取消自动续租。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lease = clientv3.NewLease(client)</span><br><span class="line">leaseGrantResp, err := lease.Grant(context.TODO(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leaseId = leaseGrantResp.ID</span><br><span class="line">ctx, cancelFunc = context.WithCancel(context.TODO())</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> cancelFunc()</span><br><span class="line"><span class="keyword">defer</span> lease.Revoke(context.TODO(), leaseId)</span><br><span class="line"></span><br><span class="line">keepRespChan, err = lease.KeepAlive(ctx, leaseId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅是这样吗？etcd还有一个巧妙的 watch 机制，能监听一个 key 的变化，也就是说，当我没有获取到锁的时候，但是我又不想一直循环去调用 get 方法进行查询，那么让 watch 通知你可能不失为一种巧妙的解决方式（适用于一些特殊的等待场景，这里就不列举代码了）</p>
<h3 id="实现总结"><a href="#实现总结" class="headerlink" title="实现总结"></a>实现总结</h3><p>ETCD 本身就是支持分布式的，所以在分布式锁的实现上没有前两者可能带来的单点问题，而本身基于 raft 实现的它，也同时避免了 redis 主从或集群下复制可能出现的尴尬问题。要说有什么问题，那么就是成本了，ETCD 在实际的业务使用场景中并不是非常常见的，所以如果要单独为它进行部署维护还是需要成本的。</p>
<h2 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h2><ul>
<li>Consul 是 Go 实现的一个轻量级 服务发现 、KV存储 的工具<br>对于它，知道的人可能就不多了，它也能实现分布式锁，而且实现起来也很简单，只需要实例一个session，用这个session去获取锁和释放锁就可以了。如果你正好在用 Consul 那用它来实现你需要的分布式锁，也可以作为你的一种选择吧</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，回过头你会发现，我们实现分布式锁，其实要考虑的地方非常多，需要注意的问题也很多，并不是很多时候我们也在权衡考虑。为了保证一个分布式环境中的原子操作，其实说起来容易，做起来真的有点难。</p>
<p>推荐下面几篇博客供你进一步学习：<br><a href="https://dbaplus.cn/news-159-2469-1.html（ZK实现分布式锁，以及分布式锁就够了吗？如何能做到高并发下也能好用呢？）">https://dbaplus.cn/news-159-2469-1.html（ZK实现分布式锁，以及分布式锁就够了吗？如何能做到高并发下也能好用呢？）</a><br><a href="https://zhuanlan.zhihu.com/p/42056183">https://zhuanlan.zhihu.com/p/42056183</a><br><a href="https://mp.weixin.qq.com/s/1bPLk_VZhZ0QYNZS8LkviA（基于Redis的分布式锁真的安全吗？）">https://mp.weixin.qq.com/s/1bPLk_VZhZ0QYNZS8LkviA（基于Redis的分布式锁真的安全吗？）</a><br><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html（大佬说说分布式锁）">https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html（大佬说说分布式锁）</a></p>
]]></content>
      <categories>
        <category>architecture</category>
      </categories>
      <tags>
        <tag>distributed-lock</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的垃圾回收</title>
    <url>/post/3380ee15.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近垃圾分类的话题热度一下子就上去了，很多人因为垃圾分类的问题很头痛。因为垃圾这个话题，那我就想来说说Golang里面的垃圾，于是就有了这篇博客，golang中的垃圾回收。</p>
<p>现阶段网上针对golang垃圾回收的解析已经很多了，所以我也没有必要仔仔细细的一点点说，还是那个原则，用最直白的话告诉你，垃圾到底是怎么收的。</p>
<span id="more"></span>
<h2 id="GC的意义"><a href="#GC的意义" class="headerlink" title="GC的意义"></a>GC的意义</h2><p>首先本文后续都会使用 GC 代替垃圾回收这几个字。<br>我们知道创建对象会给他分配内存资源，如果这个对象不使用了，而这个内存资源却一直被占用的话，那么我们的电脑很快就会被放满，所以需要将这些垃圾对象进行回收。</p>
<h2 id="什么才是垃圾"><a href="#什么才是垃圾" class="headerlink" title="什么才是垃圾"></a>什么才是垃圾</h2><p>要回收，那么我们必须知道什么才是垃圾，什么不是垃圾。<br>在我们看来，一个对象以后都不用了，就是垃圾。<br>在程序看来，一个对象没有被引用了，就是垃圾。</p>
<h2 id="GC的流程"><a href="#GC的流程" class="headerlink" title="GC的流程"></a>GC的流程</h2><p>首先说明一下，下面说的停，都是STW，stop the world，全世界暂停，所有运行的都停下来了。<br>这个流程可以由下面这张图展示：<br><img src="http://blog.linkinstars.com/mweb/15656646367699.jpg" alt="-w1183"></p>
<h3 id="第一个过程"><a href="#第一个过程" class="headerlink" title="第一个过程"></a>第一个过程</h3><p>先告诉所有人，停一下，我来记录一下当前状态。</p>
<h3 id="第二个过程"><a href="#第二个过程" class="headerlink" title="第二个过程"></a>第二个过程</h3><p>告诉所有人，你们继续，该干嘛干嘛，我标记一下要用的对象<br><img src="http://blog.linkinstars.com/mweb/15622252973009.jpg" alt><br>一开始所有点是白色，首先从根节点出发，标记相连的点为灰色（相连证明有引用），并且将所有灰色的点存起来；<br><img src="http://blog.linkinstars.com/mweb/15622255254202.jpg" alt><br>然后遍历所有灰色的点，标记所有灰色的点相连的点为灰色，并且将自己标记为黑色；然后重复，直到没有点是灰色；</p>
<h3 id="第三个过程"><a href="#第三个过程" class="headerlink" title="第三个过程"></a>第三个过程</h3><p>告诉所有人，再停一下，在第二个过程中，因为所有人继续在工作，那么就会产生新的垃圾，因为第一个过程记录了状态，所以需要标记一下新的垃圾；然后清除所有白色的点，因为白色的点是没人引用的，也就是垃圾。</p>
<h2 id="为什么要这样GC"><a href="#为什么要这样GC" class="headerlink" title="为什么要这样GC"></a>为什么要这样GC</h2><p>你一定会有这样的疑问：</p>
<ul>
<li>为什么要暂停两次？</li>
<li>为什么不直接标记？</li>
</ul>
<ol>
<li>如果再标记的过程中不断的在创建新的对象，那么永远就标记不完了。</li>
<li>如果标记的过程中，原来的被标记的对象引用发生变更也会导致问题。</li>
</ol>
<p>那么既然会导致那么多问题，为什么不直接停下来，标记完回收完了再开始呢？<br><strong>因为慢~</strong></p>
<p><em>所以这样GC的原因是既要保证GC正常执行，又要保证效率，不能停的时间太长。</em></p>
<h3 id="第一个过程-1"><a href="#第一个过程-1" class="headerlink" title="第一个过程"></a>第一个过程</h3><p>其实第一次停的时候，启动了一个写屏障 (write barrier)它需要记录后续过程中新创建的对象</p>
<h3 id="第二个过程-1"><a href="#第二个过程-1" class="headerlink" title="第二个过程"></a>第二个过程</h3><p>这个过程称为三色标记，有点类似广度优先搜索。</p>
<h3 id="第三个过程-1"><a href="#第三个过程-1" class="headerlink" title="第三个过程"></a>第三个过程</h3><p>这次是必须停，因为在第二个过程中引用会发生变化，从而需要停止后重新扫描一遍；然后关闭写屏障，最后再清理。</p>
<h2 id="重-点"><a href="#重-点" class="headerlink" title="重 点"></a>重 点</h2><ul>
<li>什么时候需要stw？</li>
</ul>
<p><strong>开启写屏障时需要stw</strong><br><strong>关闭写屏障前需要stw</strong></p>
<p><br></p>
<ul>
<li>什么时候是并发执行的？</li>
</ul>
<p><strong>开启写屏障之后的标记过程与其他程序并发执行</strong><br><strong>关闭写屏障之后的清扫过程与其他程序并发执行</strong></p>
<h2 id="GC的触发条件"><a href="#GC的触发条件" class="headerlink" title="GC的触发条件"></a>GC的触发条件</h2><p>那毕竟GC还是需要STW的，虽然可能停止时间很短，但是对于程序来说，整个程序停止1秒那对于用户来说就是致命打击。所以GC肯定需要一个触发的条件，不能想来就来。</p>
<h3 id="GC百分比"><a href="#GC百分比" class="headerlink" title="GC百分比"></a>GC百分比</h3><p>这是一个触发的条件，默认GC百分比设置的是100，意思是，如果这次回收之后总共占用2M的内存，那么下次触发的条件时当超过4M的时候；同理，当这次回收之后总共占用4M，那么下次触发条件就是8M。</p>
<h3 id="2分钟"><a href="#2分钟" class="headerlink" title="2分钟"></a>2分钟</h3><p>这个简单，当一定时间（2分钟）没有执行过GC就触发GC（称为GC forced）<br>监控服务 sysmon 每隔 2 分钟就会检查一次垃圾 回收状态，如超出 2 分钟未曾触发，那就强制执行。</p>
<h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>使用命令<code>runtime.GC()</code>手动触发GC</p>
<h2 id="如何查询gc过程"><a href="#如何查询gc过程" class="headerlink" title="如何查询gc过程"></a>如何查询gc过程</h2><p>启动时加上命令<code>GODEBUG=&quot;gctrace=1&quot;</code><br>运行一段时间你会看到类似下面的输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gc 1 @351.002s 0%: 0.017+0.88+0.038 ms clock, 0.21+0/0.75/0.72+0.45 ms cpu, 4-&gt;4-&gt;2 MB, 5 MB goal, 12 P</span><br><span class="line">gc 2 @351.022s 0%: 0.006+1.6+0.045 ms clock, 0.075+0/0.57/0.65+0.54 ms cpu, 8-&gt;8-&gt;7 MB, 9 MB goal, 12 P</span><br><span class="line">gc 3 @351.030s 0%: 0.005+2.7+0.032 ms clock, 0.061+0/3.0/0.90+0.38 ms cpu, 15-&gt;15-&gt;13 MB, 16 MB goal, 12 P</span><br><span class="line">gc 4 @351.042s 0%: 0.005+5.7+0.043 ms clock, 0.067+0/0.44/5.6+0.52 ms cpu, 29-&gt;29-&gt;25 MB, 30 MB goal, 12 P</span><br><span class="line">gc 5 @351.069s 0%: 0.005+10+0.039 ms clock, 0.063+0/0.33/10+0.47 ms cpu, 57-&gt;57-&gt;49 MB, 58 MB goal, 12 P</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1 表示第一次执行</li>
<li>@351.002s 表示程序执行的总时间</li>
<li>0% 垃圾回收时间占用的百分比</li>
<li>0.017+0.88+0.038 ms clock 垃圾回收的时间，分别<br>stop-the-world (STW) sweep termination + concurrent mark and scan + and STW mark termination<br>0.017表示mark阶段stw的时间，是第一次stw，短暂的那个。<br>0.88表示并发标记和扫描的时间。<br>0.038表示mark termination中stw的时间，第二次stw，长的那个。</li>
<li>0.10+0.23/5.4/12+0.40 ms cpu：按顺序分成三部分，0.10表示整个进程在mark阶段STW停顿时间(0.013 <em> 8)；0.23/5.4/12有三块信息，0.23是mutator assists占用的时间，5.4是dedicated mark workers+fractional mark worker占用的时间，12是idle mark workers占用的时间。这三块时间加起来会接近2.9</em>8(P的个数)；0.40 ms表示整个进程在markTermination阶段STW停顿时间(0.050 * 8)。</li>
<li>4-&gt;4-&gt;2 MB 按顺序分成三部分，4表示开始mark阶段前的heap_live大小；4表示开始markTermination阶段前的heap_live大小；2表示被标记对象的大小。</li>
<li>5 MB goal 表示下一次触发GC的内存占用阀值是5MB，等于2MB * 2，向上取整。</li>
<li>12 P 使用的Processor数量</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是在golang中垃圾回收的大致流程，总的来说使用三色标记法进行标记清除，并且标记时与程序运行并行，为了解决问题使用写屏障来记录标记过程中对象的变更。总来的来说也是为了提高垃圾回收的效率，并且尽可能的减少STW的时间。<br>了解下来，与java的分代回收相比，golang中的回收算法理解起来更加简单一些。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://studygolang.com/articles/21569">https://studygolang.com/articles/21569</a><br><a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/</a><br><a href="https://www.jianshu.com/p/8b0c0f7772da">https://www.jianshu.com/p/8b0c0f7772da</a><br><a href="http://legendtkl.com/2017/04/28/golang-gc/">http://legendtkl.com/2017/04/28/golang-gc/</a></p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>再看golang垃圾回收</title>
    <url>/post/3e7124fd.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先要说一些废话：<br>之前我已经有博客写过golang的垃圾回收相关的内容，虽然很简略，但是涵盖了整体的流程，现在为啥又来写一遍呢？一方面有一些政治（你懂得）因素在里面，一方面最近又再研究。那么问题来了，那么多博客已经写过了它，我怎么把它讲出花来呢？我思前想后，于是想出了几个独特的角度来重新诠释一下golang的垃圾回收。</p>
<p>那首先如果再把整个gc过程简单说一遍，可能就没有人愿意听了，但是golang的gc说简单也简单说复杂其实也有很多细节，如何做到有自己的想法呢？于是我就强行举例了几个问题。</p>
<span id="more"></span>
<h2 id="问题-amp-角度"><a href="#问题-amp-角度" class="headerlink" title="问题&amp;角度"></a>问题&amp;角度</h2><p>在研究golang垃圾回收的时候，你有没有想过下面几个问题</p>
<ol>
<li>golang如果有两个对象循环互相引用，是否会出现永远回收不了的对象?</li>
<li>golang的gc标记方式为什么用bfs而不是dfs?</li>
<li>是否有可能永远不触发gc？</li>
<li>为什么golang的gc不整理、不分代？</li>
</ol>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>首先说明一下，这些问题都是我自己想的，也没有什么所谓的正确答案，所以下面也是我的个人理解，如果有问题可以在下方留言进行讨论。</p>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><ul>
<li>golang如果有两个对象循环互相引用，是否会出现永远回收不了的对象?</li>
</ul>
<p>为什么会想到有这个问题呢？因为有人曾经问过，为什么golang里面不能有包的循环引用？其实这两个问题并没有相关性。。。包的循环引用和对象的循环引用是不一样的。我们来看看下面的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Info *UserInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    U   *User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        user := &amp;User&#123;</span><br><span class="line">            Name: <span class="string">&quot;LinkinStar&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        userInfo := &amp;UserInfo&#123;</span><br><span class="line">            Age: <span class="number">24</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        user.Info = userInfo</span><br><span class="line">        userInfo.U = user</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先这样的代码肯定是可以编译通过的，而且明显两个对象就有互相引用，但是这样会导致gc无法回收这两个对象吗？</p>
<p>明显不可能。。。</p>
<p>因为golang的gc不是使用引用计数来完成的标记，并不是通过计算一个对象的引用数来计算一个对象是否会被回收，而是从root开始来进行寻找标记的。我们看下面这个图就很明确了。<br><img src="http://blog.linkinstars.com/mweb/15756986738605.jpg" alt></p>
<p>其中A和D明显是相互引用的，只要A不用了，那么两者就会被回收。</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><ul>
<li>golang的gc标记方式为什么用bfs而不是dfs?</li>
</ul>
<p>首先bfs是广度优先搜索，dfs是深度优先搜索，我们知道我们的三色标记是一层层往下走的，那为什么会这样设计呢？</p>
<p>这个问题没有明确的答案，我说一下我个人的理解。</p>
<ol>
<li>针对gc来说，其实对象是很多的，而对象直接的引用层级其实是不深的，说白了，如果把整个对象的引用比作一颗树的话，那么树的高度或者说深度是不会很高的，而root会很多。</li>
<li>后期引用的变动往往都发生在最底层，如果使用dfs那么很有可能已经被标记过的对象发生了引用变动，可能会影响部分性能。</li>
<li>dfs需要递归实现，那么函数的调用必然会有入栈出栈，所以不太合适。</li>
</ol>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><ul>
<li>是否有可能永远不触发gc？</li>
</ul>
<p>我们知道触发gc的条件有几个：</p>
<ol>
<li>达到GC百分比上限</li>
<li>达到一定的时间2分钟（sysmon）</li>
<li>使用runtime.GC()</li>
</ol>
<p>那么是否有办法实现永远不触发gc呢？有的！<br>来看看下面这个代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i := <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">            i--</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        array := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            array = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line">            array = <span class="built_in">append</span>(array, <span class="number">1</span>)</span><br><span class="line">            time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    runtime.GC()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">60</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们使用<code>GODEBUG=&quot;gctrace=1&quot;</code>打印出gc日志会发现，没有任何的输出。为什么呢？<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">        i--</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><br>原因就在这个地方，因为golang在想要gc的时候，需要保证所有的协程走到一个安全点，所谓的安全点是需要你有任何的函数调用都可以。而这里是没有任何函数调用的，也就是说没有安全点。所以golang没有办法触发gc，当我们在其中加入任意方法之后，就可以触发gc了。</p>
<p>所以这也让我们在写程序的时候要注意，千万不能有死循环，并且当中没有任何函数调用（虽然在实际中很少存在）</p>
<h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><ul>
<li>为什么golang的gc不整理、不分代？</li>
</ul>
<p>下面是来自源码中的一段：</p>
<ul>
<li>The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier. <strong>It is non-generational and non-compacting</strong>. Allocation is done using size segregated per P allocation areas to minimize fragmentation while eliminating locks in the common case.</li>
</ul>
<p>其中明确说明了是非分代和非整合的算法。</p>
<p>对于这个问题，首先我不得不说的是，分代确实能很好的提高gc的效率，因为大多数对象使用的时间是很短的，而长时间占用的对象是很少的，这也是java中分代的原因。而对于整理，整理的话有利于内存的管理和回收，当对象被回收之后，会出现很多的内存碎片，而整理可以很好的重新规范内存，回收那些不需要的页。</p>
<p>那么golang为啥不做呢？首先是复杂，我们看java分代回收的实现就非常的复杂，实现起来需要很大的力气，而当前的golang的gc效率已经可能已经满足需求了。然是就是整理，其实整理这块是由内存管理模块来管理的，而golang中的内存管理在分配的阶段已经利用了最小化的原则，每次给到的都是合适的大小，所以整理这块就交由他们进行来管了，gc这块只负责回收就可以了。</p>
<h2 id="最后来个tool"><a href="#最后来个tool" class="headerlink" title="最后来个tool"></a>最后来个tool</h2><p>最后补充一个tool之前博客中只是说用gctrace来输出gc日志，而没有可视化的展示，而其实有这样的工具可以满足这样的要求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (	</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)	</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;		</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> 	<span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()  </span><br><span class="line">    <span class="comment">// Your program here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在你的项目中添加如下的代码，然后在运行一段时间之后就可以通过go tool trace trace.out命令来在页面上查看整个项目gc的情况了。</p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>将版本信息打包到go的二进制中</title>
    <url>/post/f83d929.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>很多时候对于go打包后的二进制文件，我们是无法知道这个二进制是什么当前什么版本、什么时候打包的，而很多软件的命令行都会有一个 -version 的选项来打印出当前程序的版本号，当然你可以直接在程序里面写死这个版本号，但是还有更加优雅的解决方式。</p>
<span id="more"></span>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>其实很简单，只需要在 build 的时候通过 -X 参数去指定变量值就可以了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   Tag      = <span class="string">&quot;v0.0.0&quot;</span></span><br><span class="line">   CommitID = <span class="string">&quot;&quot;</span></span><br><span class="line">   Branch   = <span class="string">&quot;&quot;</span></span><br><span class="line">   DATE     = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;tag:&quot;</span>, Tag, <span class="string">&quot;branch:&quot;</span>, Branch, <span class="string">&quot;commitID:&quot;</span>, CommitID, <span class="string">&quot;DATE:&quot;</span>, DATE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前commit号</span></span><br><span class="line">CommitID=$(git rev-parse HEAD)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前分支名称</span></span><br><span class="line">Branch=$(git rev-parse --abbrev-ref HEAD)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最近的tag</span></span><br><span class="line">Tag=$(git describe --abbrev=0 --tags)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包时间</span></span><br><span class="line">DATE=$(date +<span class="string">&#x27;%Y-%m-%dT%H:%M:%m+08:00&#x27;</span>) </span><br><span class="line"></span><br><span class="line">go build -ldflags <span class="string">&quot;-X &#x27;main.Tag=<span class="variable">$Tag</span>&#x27; -X &#x27;main.Branch=<span class="variable">$Branch</span>&#x27; -X &#x27;main.CommitID=<span class="variable">$CommitID</span>&#x27; -X &#x27;main.DATE=<span class="variable">$DATE</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中需要注意的是，用单引号的原因是防止变量中带有空格，main标识包，你可以替换成程序中对应的包就可以。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样，当我们在实际生产环境使用的时候，就可以通过这些打包时携带的信息来分析这个包是什么时候的，是否为最新版本等。</p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>gobuild</tag>
      </tags>
  </entry>
  <entry>
    <title>图解goroutine调度</title>
    <url>/post/137ecf0f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>其实这个话题我早就想做了，奈何这个问题确实有点复杂，看了很多文章才有了一点点自己的理解。从golang一开始的使用我就已经开始好奇了，这个goroutine到底是怎么实现的呢？怎么就能搞出一个和线程类似，但是性能又那么好的东西的呢？</p>
<span id="more"></span>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="三个小伙子"><a href="#三个小伙子" class="headerlink" title="三个小伙子"></a>三个小伙子</h3><p>在看整体结构之前，我先来介绍三个小伙子，golang为了实现goroutine，定义了这样三个小伙子，让他们帮忙去实现。</p>
<h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p>表示goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等；另外G对象是可以重用的。</p>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>M代表着真正的执行计算资源。在绑定有效的P后，进入调度器循环；而调度器循环的机制大致是从各种队列、P的本地队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。<strong>M并不保留G状态，这是G可以跨M调度的基础。</strong></p>
<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>表示逻辑processor，P的数量决定了系统内最大可并行的G的数量（前提：系统的物理cpu核数&gt;=P的数量）；P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。</p>
<h3 id="整体结构模型"><a href="#整体结构模型" class="headerlink" title="整体结构模型"></a>整体结构模型</h3><p>我们先来看下面的这张图，从大体结构上看，我们就能理解goroutine了<br><img src="http://blog.linkinstars.com/mweb/15657513574146.jpg" alt="-w640"></p>
<p>看到这个图你应该理解了一半，下面我来说明一下。<br>我们知道，在操作系统眼里其实只有cpu和线程，它去控制着各个线程的调度，切换，执行等等，而对于goroutine的实现其实非常类似；<br>在golang层面，首先我们要知道，最终在外面执行的肯定是线程，但是我们内部开出的那些goroutine到哪里去了呢？<br>golang提出GPM模型，在G的眼里，只有P，P保存了需要执行的那些goroutine；<br>而在整个go调度的层面，对外的是M，P会找到一个M，让它去与外面的线程交互，从而去真正执行程序。<br>从这里我们可以发现，其实goroutine的调度器整个就是一个小型的操作系统，内部去造出了类似的部件去完成goroutine的实现，而因为是在内部实现，所以解决了操作系统层面所带来的线程创建慢等问题。</p>
<p>但是，同时这样的调度也会有问题，所以需要一些额外的措施！</p>
<h2 id="调度中的问题"><a href="#调度中的问题" class="headerlink" title="调度中的问题"></a>调度中的问题</h2><h3 id="问题1-G不均"><a href="#问题1-G不均" class="headerlink" title="问题1 G不均"></a>问题1 G不均</h3><p>我们知道，现实情况有的goroutine运行的快，有的慢，那么势必肯定会带来的问题就是，忙的忙死，闲的闲死，go肯定不允许摸鱼的P存在，势必要榨干所有劳动力。<br>如果你没有任务，那么，我们看到模型中还有一个全局G队列的存在，如本地队列已满，会一次性转移半数到全局队列。其他闲的小伙子就会从全局队列中拿；（顺便说一下，优先级是先拿下一个需要执行的，然后去本地队列中拿，再去全局队列中拿，先把自己的做完再做别人的嘛）同时如果全局都没有了，就会去抢别人的做。</p>
<h3 id="问题2-任务卡主了"><a href="#问题2-任务卡主了" class="headerlink" title="问题2 任务卡主了"></a>问题2 任务卡主了</h3><p>万一有个程序员启动一个goroutine去执行一个任务，然后这个任务一直睡觉（sleep）就是循环睡觉，那咋办嘛！你作为执行人，你总不能说，让它一直占用着一整个线程的资源，然后后面的goroutine都卡主了，那如果只有一个核心P，不就完蛋了？聪明的go才不会那么傻，它采用了抢占式调度来解决这个问题。只要你这个任务执行超过一定的时间（10ms），那么这个任务就会被标识为可抢占的，那么别的goroutine就可以抢先进来执行。只要下次这个goroutine进行函数调用，那么就会被强占，同时也会保护现场，然后重新放入P的本地队列里面等待下次执行。<br>谁来做的呢？<br>sysmon，就是这个背后默默付出的人，它是一个后台运行的监控线程，它来监控那些长时间运行的G任务然后设置可以强占的标识符。（同时顺便提一下，它还会做的一些事情，例如，释放闲置的span内存，2分钟的默认gc等）</p>
<h3 id="问题3-阻塞可怎么办？"><a href="#问题3-阻塞可怎么办？" class="headerlink" title="问题3 阻塞可怎么办？"></a>问题3 阻塞可怎么办？</h3><p>我们经常使用goroutine还有一个场景就是网络请求和IO操作，这种阻塞的情况下，我们的G和M又会怎么做呢？<br>这个时候有个叫做netpoller的东西出现了，当每次有一个网络请求阻塞的时候，如果按照原来的方法这个时候这个请求会阻塞线程，而有了netpoller这个东西，可以将请求阻塞到goroutine。<br>意思是说，当阻塞出现的时候，当前goroutine会被阻塞，等待阻塞notify，而放出M去做别的g，而当阻塞恢复的时候，netpoller就会通知对应的m可以做原来的g了。<br>同时还要顺便提一句，当P发现没有任务的时候，除了会找本地和全局，也会去netpoll中找。</p>
<h3 id="问题4-系统方法调用阻塞？"><a href="#问题4-系统方法调用阻塞？" class="headerlink" title="问题4 系统方法调用阻塞？"></a>问题4 系统方法调用阻塞？</h3><p>还有一个问题，我们自己想可能比较难想到，就是当调用一些系统方法的时候，如果系统方法调用的时候发生阻塞就比较麻烦了。下面引用一段话：<br>当G被阻塞在某个系统调用上时，此时G会阻塞在_Gsyscall状态，M也处于block on syscall状态，此时的M可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。如果没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；当系统调用完成后，G会重新尝试获取一个idle的P进入它的Local队列恢复执行，如果没有idle的P，G会被标记为runnable加入到Global队列。</p>
<h2 id="源码一瞥"><a href="#源码一瞥" class="headerlink" title="源码一瞥"></a>源码一瞥</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> G</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uintptr</span>    stackguard;    <span class="comment">// 分段栈的可用空间下界</span></span><br><span class="line">    <span class="keyword">uintptr</span>    stackbase;    <span class="comment">// 分段栈的栈基址</span></span><br><span class="line">    Gobuf    sched;        <span class="comment">//进程切换时，利用sched域来保存上下文</span></span><br><span class="line">    <span class="keyword">uintptr</span>    stack0;</span><br><span class="line">    FuncVal*    fnstart;        <span class="comment">// goroutine运行的函数</span></span><br><span class="line">    void*    param;        <span class="comment">// 用于传递参数，睡眠时其它goroutine设置param，唤醒时此goroutine可以获取</span></span><br><span class="line">    <span class="keyword">int16</span>    status;        <span class="comment">// 状态Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead</span></span><br><span class="line">    <span class="keyword">int64</span>    goid;        <span class="comment">// goroutine的id号</span></span><br><span class="line">    G*    schedlink;</span><br><span class="line">    M*    m;        <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    M*    lockedm;    <span class="comment">// G被锁定只能在这个m上运行</span></span><br><span class="line">    <span class="keyword">uintptr</span>    gopc;    <span class="comment">// 创建这个goroutine的go表达式的pc</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> M</span><br><span class="line">&#123;</span><br><span class="line">    G*    g0;        <span class="comment">// 带有调度栈的goroutine</span></span><br><span class="line">    G*    gsignal;    <span class="comment">// signal-handling G 处理信号的goroutine</span></span><br><span class="line">    void    (*mstartfn)(void);</span><br><span class="line">    G*    curg;        <span class="comment">// M中当前运行的goroutine</span></span><br><span class="line">    P*    p;        <span class="comment">// 关联P以执行Go代码 (如果没有执行Go代码则P为nil)</span></span><br><span class="line">    P*    nextp;</span><br><span class="line">    <span class="keyword">int32</span>    id;</span><br><span class="line">    <span class="keyword">int32</span>    mallocing; <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">int32</span>    throwing;</span><br><span class="line">    <span class="keyword">int32</span>    gcing;</span><br><span class="line">    <span class="keyword">int32</span>    locks;</span><br><span class="line">    <span class="keyword">int32</span>    helpgc;        <span class="comment">//不为0表示此m在做帮忙gc。helpgc等于n只是一个编号</span></span><br><span class="line">    <span class="keyword">bool</span>    blockingsyscall;</span><br><span class="line">    <span class="keyword">bool</span>    spinning;</span><br><span class="line">    Note    park;</span><br><span class="line">    M*    alllink;    <span class="comment">// 这个域用于链接allm</span></span><br><span class="line">    M*    schedlink;</span><br><span class="line">    MCache    *mcache;</span><br><span class="line">    G*    lockedg;</span><br><span class="line">    M*    nextwaitm;    <span class="comment">// next M waiting for lock</span></span><br><span class="line">    GCStats    gcstats;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> P</span><br><span class="line">&#123;</span><br><span class="line">    Lock;</span><br><span class="line">    <span class="keyword">uint32</span>    status;  <span class="comment">// Pidle或Prunning等</span></span><br><span class="line">    P*    link;</span><br><span class="line">    <span class="keyword">uint32</span>    schedtick;   <span class="comment">// 每次调度时将它加一</span></span><br><span class="line">    M*    m;    <span class="comment">// 链接到它关联的M (nil if idle)</span></span><br><span class="line">    MCache*    mcache;</span><br><span class="line"></span><br><span class="line">    G*    runq[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int32</span>    runqhead;</span><br><span class="line">    <span class="keyword">int32</span>    runqtail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G&#x27;s (status == Gdead)</span></span><br><span class="line">    G*    gfree;</span><br><span class="line">    <span class="keyword">int32</span>    gfreecnt;</span><br><span class="line">    <span class="keyword">byte</span>    pad[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Sched &#123;</span><br><span class="line">    Lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64</span>    goidgen;</span><br><span class="line"></span><br><span class="line">    M*    midle;     <span class="comment">// idle m&#x27;s waiting for work</span></span><br><span class="line">    <span class="keyword">int32</span>    nmidle;     <span class="comment">// number of idle m&#x27;s waiting for work</span></span><br><span class="line">    <span class="keyword">int32</span>    nmidlelocked; <span class="comment">// number of locked m&#x27;s waiting for work</span></span><br><span class="line">    int3    mcount;     <span class="comment">// number of m&#x27;s that have been created</span></span><br><span class="line">    <span class="keyword">int32</span>    maxmcount;    <span class="comment">// maximum number of m&#x27;s allowed (or die)</span></span><br><span class="line"></span><br><span class="line">    P*    pidle;  <span class="comment">// idle P&#x27;s</span></span><br><span class="line">    <span class="keyword">uint32</span>    npidle;  <span class="comment">//idle P的数量</span></span><br><span class="line">    <span class="keyword">uint32</span>    nmspinning;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global runnable queue.</span></span><br><span class="line">    G*    runqhead;</span><br><span class="line">    G*    runqtail;</span><br><span class="line">    <span class="keyword">int32</span>    runqsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global cache of dead G&#x27;s.</span></span><br><span class="line">    Lock    gflock;</span><br><span class="line">    G*    gfree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32</span>    stopwait;</span><br><span class="line">    Note    stopnote;</span><br><span class="line">    <span class="keyword">uint32</span>    sysmonwait;</span><br><span class="line">    Note    sysmonnote;</span><br><span class="line">    <span class="keyword">uint64</span>    lastpoll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32</span>    profilehz;    <span class="comment">// cpu profiling rate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>goroutine的设计总的来说就是参考操作系统的设计，所有的目的很明确就是为了在整个运行过程中能充分利用已有的资源，尽可能在有限的资源里面多做事情，利用gpm的模型以及一些netpoller、sysmon等帮助在阻塞的时候也能合理利用资源，从而达到我们现在高效的goroutine</p>
<p>参考资料：<br><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.1.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.1.html</a><br><a href="http://morsmachine.dk/go-scheduler">http://morsmachine.dk/go-scheduler</a><br><a href="http://morsmachine.dk/netpoller">http://morsmachine.dk/netpoller</a><br><a href="https://studygolang.com/articles/10116">https://studygolang.com/articles/10116</a></p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang Mutex 到底是否应该使用指针</title>
    <url>/post/e360d978.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在写 go 的时候，你使用 Mutex 的时候使用的是指针还是说没有使用指针，还是随意来？</p>
<p>前两天我收到了下面这样的一个 PR，我突然就想到了这个问题，于是就有了这篇博客。</p>
<span id="more"></span>
<p><img src="http://blog.linkinstars.com//blog/image-20200719223432357.png" alt></p>
<p><img src="http://blog.linkinstars.com//blog/image-20200719231757257.png" alt></p>
<h2 id="我一开始的想法"><a href="#我一开始的想法" class="headerlink" title="我一开始的想法"></a>我一开始的想法</h2><p>其实我一开始的想法很简单，因为我一直<strong>没有使用指针</strong></p>
<ol>
<li>在我的某些印象中我曾经记得，使用锁不申明为指针是一个代码规范类似的东西</li>
<li>大多数的（我看过的一些）源码中，没有见过将锁申明为指针的用法</li>
<li>但是当时我没有办法回答这个 PR，你总不能说我是一厢情愿吧…需要一个更加合理的解释</li>
</ol>
<h2 id="仔细分析"><a href="#仔细分析" class="headerlink" title="仔细分析"></a>仔细分析</h2><h3 id="上网搜索一番"><a href="#上网搜索一番" class="headerlink" title="上网搜索一番"></a>上网搜索一番</h3><p><a href="https://www.reddit.com/r/golang/comments/6uyf16/confusion_about_mutex_and_reference/">https://www.reddit.com/r/golang/comments/6uyf16/confusion_about_mutex_and_reference/</a></p>
<p>很多类似的问题都在问（你不用点开，只是举个例子）</p>
<h3 id="问题关键"><a href="#问题关键" class="headerlink" title="问题关键"></a>问题关键</h3><p><code>sync.Mutex</code> 这个东西不能被 copy！（这个我之前也是知道的，毕竟都分析过源码了）</p>
<h3 id="刨根问底"><a href="#刨根问底" class="headerlink" title="刨根问底"></a>刨根问底</h3><p><strong>虽然这个锁不能被拷贝，那么就应该被申明为指针防止拷贝出现问题吗？</strong></p>
<p>别慌，先写个例子测测看</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	*sync.Mutex</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := Config1&#123;Name: <span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">	cc1 := c1</span><br><span class="line">	fmt.Println(cc1.Name)</span><br><span class="line">	cc1.Lock()</span><br><span class="line">	cc1.Unlock()</span><br><span class="line"></span><br><span class="line">	c2 := Config2&#123;</span><br><span class="line">		Mutex: &amp;sync.Mutex&#123;&#125;,</span><br><span class="line">		Name:  <span class="string">&quot;2&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	cc2 := c2</span><br><span class="line">	fmt.Println(cc2.Name)</span><br><span class="line">	cc2.Lock()</span><br><span class="line">	cc2.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这个跑起来没问题，但是要注意的是，如果使用指针，你就必须对它初始化，否则会空指针。</p>
<p>看起来好像 copy 没问题啊？难道？让我 vet 看看</p>
<p><img src="http://blog.linkinstars.com//blog/image-20200719225413639.png" alt></p>
<p>果然有问题，因为有拷贝。</p>
<p><strong>但是结论我认为恰恰相反！！</strong></p>
<h2 id="我的结论"><a href="#我的结论" class="headerlink" title="我的结论"></a>我的结论</h2><p><strong>就应该不应该申明为指针</strong></p>
<h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因 1"></a>原因 1</h3><p>假设你申明为了指针，go vet 就不会报错，那么其实你在使用的时候，在不知情的情况下你就会“复制”这个锁</p>
<h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因 2"></a>原因 2</h3><p>在什么时候会使用锁呢？一般是不是有一个单例对象要控制，这个对象或者某个操作要控制并发的时候用对吧。</p>
<p>那什么时候会复制对象呢？那么这个对象一定就不是个单例对不对？（注意这里是复制对象，而不是创建指针对象从而复制指针）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c2 := Config2&#123;</span><br><span class="line">   Mutex: &amp;sync.Mutex&#123;&#125;,</span><br><span class="line">   Name:  <span class="string">&quot;2&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">cc2 := c2</span><br></pre></td></tr></table></figure>
<p>这个写法就已经很古怪了，你复制了这个对象，并且用了同一把锁，那么问题来了：</p>
<ul>
<li><p>你的想法究竟是 cc2 锁的时候 c2 也要被锁住？=&gt; 如果是这一种，那么就不应该将锁申明在对象内部。</p>
</li>
<li><p>还是 cc2 锁的时候 c2 不要被锁住？=&gt; 如果是这一种，既不能将锁申明为指针，也能进行拷贝，而应该重新申明一个对象，进行对象其他值的赋值操作。</p>
</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>所以我的结论很明显，不应该申明为指针，申明指针容易在不经意间导致意外。</p>
<p>如果担心拷贝锁的问题，可以使用 go vet 进行分析，现在很多 go 的代码静态分析工具也都提供了这个功能的，其他的也可以。</p>
<p>当然这是我的个人观点，因为语法本身没有错，可能会在一些特殊情况下真的有用到这样的写法~如果我</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>在我疑惑自己的想法的时候感谢群里大佬的肯定和指点。</p>
<p><img src="http://blog.linkinstars.com//blog/image-20200719231322972.png" alt></p>
<p>同时也感谢提出这个 PR 的同学，让我更加深刻的学会了这个知识点。</p>
<p>你们遇到问题也要刨根问底哦！不要放过任何一个小问题！</p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>Mutex</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 监控全局变量</title>
    <url>/post/2dc2d3f5.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>你是否曾经遇到过这样的情况，在开发环境排查问题，因为一些数据保存在了一些全局变量中，这些变量往往是一个 map 或者是一个数组，想看看在运行过程中，这里面究竟存放了什么数据，有时不得不在运行的时候将它输出到日志中，那么如果我想实时看到这些数据的情况又怎么办呢？</p>
<p>其实 golang 中已经存在这样的库，就是来做这个事情的 <code>expvar</code></p>
<span id="more"></span>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>废话不多数，直接上案例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;expvar&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	s    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	user User</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age  <span class="keyword">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMap</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showUser</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user.Name = <span class="string">&quot;tom&quot;</span></span><br><span class="line">	user.Age = <span class="number">18</span></span><br><span class="line">	s = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">	s[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;111&quot;</span></span><br><span class="line">	s[<span class="string">&quot;2&quot;</span>] = <span class="string">&quot;222&quot;</span></span><br><span class="line">	expvar.Publish(<span class="string">&quot;a_map&quot;</span>, expvar.Func(showMap))</span><br><span class="line">	expvar.Publish(<span class="string">&quot;b_user&quot;</span>, expvar.Func(showUser))</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">		s[<span class="string">&quot;3&quot;</span>] = <span class="string">&quot;333&quot;</span></span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="监控变量"><a href="#监控变量" class="headerlink" title="监控变量"></a>监控变量</h2><p>直接访问 <a href="http://127.0.0.1:8080/debug/vars">http://127.0.0.1:8080/debug/vars</a> 你就能看到一个 json 格式的返回数据，数据如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;a_map&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;1&quot;</span>: <span class="string">&quot;111&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;2&quot;</span>: <span class="string">&quot;222&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;b_user&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;cmdline&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;/private/var/folders/37/qpz6_ndd1w72bhrg2sgg042r0000gn/T/___go_build_go_demo_vars&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;memstats&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Alloc&quot;</span>: <span class="number">188992</span>,</span><br><span class="line">    <span class="attr">&quot;TotalAlloc&quot;</span>: <span class="number">188992</span>,</span><br><span class="line">    <span class="attr">&quot;Sys&quot;</span>: <span class="number">70453248</span>,</span><br><span class="line">    <span class="attr">&quot;Lookups&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;Mallocs&quot;</span>: <span class="number">818</span>,</span><br><span class="line">    <span class="attr">&quot;Frees&quot;</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">&quot;HeapAlloc&quot;</span>: <span class="number">188992</span>,</span><br><span class="line">    <span class="attr">&quot;HeapSys&quot;</span>: <span class="number">66650112</span>,</span><br><span class="line">    <span class="attr">&quot;HeapIdle&quot;</span>: <span class="number">65716224</span>,</span><br><span class="line">    <span class="attr">&quot;HeapInuse&quot;</span>: <span class="number">933888</span>,</span><br><span class="line">    <span class="attr">&quot;HeapReleased&quot;</span>: <span class="number">65683456</span>,</span><br><span class="line">    <span class="attr">&quot;HeapObjects&quot;</span>: <span class="number">797</span>,</span><br><span class="line">    <span class="attr">&quot;StackInuse&quot;</span>: <span class="number">458752</span>,</span><br><span class="line">    <span class="attr">&quot;StackSys&quot;</span>: <span class="number">458752</span>,</span><br><span class="line">    <span class="attr">&quot;MSpanInuse&quot;</span>: <span class="number">15776</span>,</span><br><span class="line">    <span class="attr">&quot;MSpanSys&quot;</span>: <span class="number">16384</span>,</span><br><span class="line">    <span class="attr">&quot;MCacheInuse&quot;</span>: <span class="number">6944</span>,</span><br><span class="line">    <span class="attr">&quot;MCacheSys&quot;</span>: <span class="number">16384</span>,</span><br><span class="line">    <span class="attr">&quot;BuckHashSys&quot;</span>: <span class="number">2638</span>,</span><br><span class="line">    <span class="attr">&quot;GCSys&quot;</span>: <span class="number">2240512</span>,</span><br><span class="line">    <span class="attr">&quot;OtherSys&quot;</span>: <span class="number">1068466</span>,</span><br><span class="line">    <span class="attr">&quot;NextGC&quot;</span>: <span class="number">4473924</span>,</span><br><span class="line">    <span class="attr">&quot;LastGC&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;PauseTotalNs&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面一方面将你的在代码中全局变量显示了出来还有个 <code>cmdline</code> 和 <code>memstats</code> 这个我们后面再说</p>
<p>这是你可以访问一次 <a href="http://127.0.0.1:8080/test">http://127.0.0.1:8080/test</a> 然后再回来看看，就会发现变量的值以及改变，说明这个变量显示的是实时的</p>
<h2 id="监控原理"><a href="#监控原理" class="headerlink" title="监控原理"></a>监控原理</h2><p>其实原理非常简单，你自己都能写，下面就是源码中的一部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handler returns the expvar HTTP Handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is only needed to install the handler in a non-standard location.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(expvarHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdline</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> os.Args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memstats</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	stats := <span class="built_in">new</span>(runtime.MemStats)</span><br><span class="line">	runtime.ReadMemStats(stats)</span><br><span class="line">	<span class="keyword">return</span> *stats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/debug/vars&quot;</span>, expvarHandler)</span><br><span class="line">	Publish(<span class="string">&quot;cmdline&quot;</span>, Func(cmdline))</span><br><span class="line">	Publish(<span class="string">&quot;memstats&quot;</span>, Func(memstats))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是在 init 的时候注册了对应的路由，还注册了 cmdline 和 memstats 两个值，这两个值很有用：</p>
<ul>
<li>cmdline 展示了当前启动时通过命令行传递的参数是什么</li>
<li>memstats 展示了当前运行时内存的使用情况，还有 gc 的部分信息等等</li>
</ul>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p><a href="https://golang.org/pkg/expvar/">https://golang.org/pkg/expvar/</a></p>
<p>当然这个包不止有 Publish 方法，还有 Add、Set 等等，个人最常用的还是 Publish</p>
<h2 id="监控内存并展示"><a href="#监控内存并展示" class="headerlink" title="监控内存并展示"></a>监控内存并展示</h2><p>既然 expvar 暴露了内存的使用情况，那我们当然能利用这个信息来作图了，所以就推荐一个很好用的库</p>
<p><a href="https://github.com/rs/jplot">https://github.com/rs/jplot</a></p>
<p>安装之后，就可以用命令通过之前的接口来监控内存等使用情况咯</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jplot --url http://127.0.0.1:8080/debug/vars \</span><br><span class="line">    memstats.HeapSys+memstats.HeapAlloc+memstats.HeapIdle+marker,counter:memstats.NumGC \</span><br><span class="line">    counter:memstats.TotalAlloc \</span><br><span class="line">    memstats.HeapObjects \</span><br><span class="line">    memstats.StackSys+memstats.StackInuse</span><br></pre></td></tr></table></figure>
<p><img src="http://blog.linkinstars.com//blog/10213518-5893b3e57bbe1f00.png" alt="10213518-5893b3e57bbe1f00"></p>
<p>我觉得这样的使用方式在本地和开发环境的时候测试更加轻量，不用部署一些监控软件，即开即测；当然线上环境肯定会有 prometheus + grafana 这样的监控神器，这里也只是抛个砖头。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果线上需要监控一些全局变量的使用情况可以考虑使用 expvar 进行监控和查看，或者用它来监控你的配置文件或者一些任务数量等等也是一个不错的选择。</p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>vars</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang之channel</title>
    <url>/post/f41f1ae.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>go中的一个精髓就是就是channel，那么你有没有想过，它究竟是怎么实现的呢？我之前就怀疑过，是不是就是通过一个数组保存了一下传入的数据，然后在接收方读一读就完事了，那么阻塞又是怎么实现的呢？close的时候需要注意些什么呢？</p>
<span id="more"></span>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>首先我们来看一下channel的结构是怎么样的。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其实看注释这几个字段都非常好理解，解释一下其中几个：<br>elemtype是表示这个channel中存放的是什么类型的数据；<br>sendx、recvx两个索引指向底层循环数组<br>recvq、sendq两个双向链表保存那些等待的goroutine<br>lock？对就是lock，不然你以为并发的时候channel怎么办？锁呗。</p>
<p>PS: 其实和我一开始想的差不多，底层就是利用一个循环数组来实现的带有缓冲的channel，利用两个index标记的移动来记录发送和读取，然后用一个计数器表示当前还有多少个元素，easy</p>
<p>但是如果你想着go只有这么点东西，那你就太小看它了，细节能把你看哭，嘿嘿嘿，下面来看看源码中具体的接收和发送是怎么实现的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>本质：channel发送接收数据的本质是数据拷贝！</p>
<h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p>我会删除其中一些细节部分，留下其中重要的点看一下，如果希望看到全部，请自行阅读源码。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	<span class="comment">// 如果收一个nil的channel不会panic的，而是被阻塞，gopark就是将当前goroutine阻塞</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;chan receive (nil chan)&quot;</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	<span class="comment">// 加锁哦！防止并操作channel</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理关闭的情况和无data的情况</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当无缓冲 或者 是有缓冲但是缓冲满了 这两种情况下去recv</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 剩下的情况就是有缓冲的情况，如果有数据的话进if里面，里面其实就是将缓冲中的数据拿出来，并且移动相对应的索引，减少qcount</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Receive directly from queue</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果当前没有数据，那么只能阻塞咯</span></span><br><span class="line">	<span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">&quot;chan receive&quot;</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>发送其实和接受异曲同工，也是处理其中几种情况<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="comment">// 发给一个nil的channel就panic呗</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">&quot;chan send (nil chan)&quot;</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	<span class="comment">// 如果</span></span><br><span class="line">	<span class="comment">// 不是缓冲的channel而且没有接受者正在接受</span></span><br><span class="line">	<span class="comment">// 是缓冲的channel但是缓冲满了</span></span><br><span class="line">	<span class="comment">// 那就直接返回</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="comment">// 加锁！</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 如果加锁完了之后发现被关了，要死，直接解锁并panic</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 当有接收者，那就直接发给它就好了</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是缓冲的，而且还有空间，那么久放到缓冲里面去，移动对应的索引</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当没有缓冲了，那么就需要阻塞发送人了</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">&quot;chan send&quot;</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up.</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 关闭一个nil的channel 那就panic</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭也是要加锁的！</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racewritepc(unsafe.Pointer(c), callerpc, funcPC(closechan))</span><br><span class="line">		racerelease(unsafe.Pointer(c))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 设置标志</span></span><br><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理所有的接收者，注意即使关闭了，也是可以接收的，因为有缓冲，缓冲里面还有东西</span></span><br><span class="line">	<span class="comment">// release all readers</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是对于发送的来说，如果你关闭了，还有人在发，那么就会无情的panic了，这个在发送的代码里面可以看到，在这里是处理所有发送的goroutine就可以了</span></span><br><span class="line">	<span class="comment">// release all writers (they will panic)</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line">	<span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">		gp := glist</span><br><span class="line">		glist = glist.schedlink.ptr()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里总结一下出现 panic 的情况：</p>
<ol>
<li>close 一个 nil 的 channel </li>
<li>close 一个已经 closed 的 channel</li>
<li>向一个 closed 的 channel 发送消息</li>
</ol>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>channel</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang之context</title>
    <url>/post/4fe5fa97.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当我们使用一些golang框架的时候，总能在框架中发现有个叫做context的东西。如果你之前了解过java的spring，那么你肯定也听说过其中有个牛逼的ApplicationContext。Context这个东西好像随时随地都在出现，在golang中也是非常重要的存在。今天我们就来看看这个神奇的Context。</p>
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>首先我们要知道什么是context？</li>
</ul>
<p>很多人把它翻译成上下文，其实这个是一个很难描述很定义的东西，对于这种东西，我习惯用功能去定义它。<br>我的定义是：context是用于在多个goroutines之间传递信息的媒介。<br>官方定义：At Google, we developed a context package that makes it easy to pass request-scoped values, cancelation signals, and deadlines across API boundaries to all the goroutines involved in handling a request.</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>同样的我们先来看看它的一些基本用法，大致了解它的使用。</p>
<h3 id="传递信息"><a href="#传递信息" class="headerlink" title="传递信息"></a>传递信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    ctx = context.WithValue(ctx, <span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">    value := ctx.Value(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实传递消息很简单，只需要通过<code>context.WithValue</code>方法设置，key-value然后通过<code>ctx.Value</code>方法取值就可以了。</p>
<p>暂时不用关心context.Background()只要知道context有传递值的功能就可以了。</p>
<h3 id="关闭goroutine"><a href="#关闭goroutine" class="headerlink" title="关闭goroutine"></a>关闭goroutine</h3><p>在我们写golang的时候goroutine是一个非常常用的东西，我们经常会开一个goroutine去处理对应的任务，特别是一些循环一直处理的情况，这些goroutine需要知道自己什么时候要停止。<br>我们常见的解决方案是使用一个channel去接收一个关闭的信号，收到信号之后关闭，或者说，需要一个标识符，每个goroutine去判断这个标识符的变更从而得知什么时候关闭。<br>那么用context如何实现呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, _ := context.WithTimeout(context.Background(), time.Second * <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        go1(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        go2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go1</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;1 正在工作&quot;</span>)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;1 停止工作&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;2 正在工作&quot;</span>)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;2 停止工作&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过context.WithTimeout我们创建了一个3秒后自动取消的context；<br>所有工作goroutine监听ctx.Done()的信号；<br>收到信号就证明需要取消任务；</p>
<p>其实使用起来比较简单，让我们来看看内部的原理。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="context-TODO"><a href="#context-TODO" class="headerlink" title="context.TODO()"></a>context.TODO()</h4><p>这个就是创建一个占位用的context，可能在写程序的过程中还不能确定后期这个context的作用，所以暂时用这个占位</p>
<h4 id="context-Background"><a href="#context-Background" class="headerlink" title="context.Background()"></a>context.Background()</h4><p>这个是最大的context，也就是根context，这里就有必要说一下context的整个构成了，context其实构成的是一棵树，Background为根节点，每次创建一个新的context就是创建了一个新的节点加入这棵树。</p>
<h4 id="context-WithTimeout"><a href="#context-WithTimeout" class="headerlink" title="context.WithTimeout()"></a>context.WithTimeout()</h4><p>比如这个方法，创建一个自动过期的context<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 	func slowOperationWithTimeout(ctx context.Context) (Result, error) &#123;</span></span><br><span class="line"><span class="comment">// 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</span></span><br><span class="line"><span class="comment">// 		defer cancel()  // releases resources if slowOperation completes before timeout elapses</span></span><br><span class="line"><span class="comment">// 		return slowOperation(ctx)</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到需要传入一个parent，和过期时间，新创建的context就是parent的子节点。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意其中<code>cancelCtx: newCancelCtx(parent),</code>其实是创建了一个可以取消的ctx，然后利用<code>time.AfterFunc</code>来实现定时自动过期。</p>
<p>还有一个细节<br><code>c.mu.Lock()</code><br><code>defer c.mu.Unlock()</code><br>这个mu来自：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">	err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个context因为有了锁，所以是并发安全的。</p>
<h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cancel closes c.done, cancels each of c&#x27;s children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent&#x27;s children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当达到过期时间或者调用cancelFunc的时候就会触发context的取消，然后看到上面的源码你就明白了，取消的时候有一个三个操作：</p>
<ol>
<li><code>c.mu.Lock()</code> 加锁保证安全</li>
<li><code>close(c.done)</code> 将done信道关闭，从而所有在观察done信道的goroutine都知道要关闭了</li>
<li><code>for child := range c.children</code> 循环每个子节点，关闭每个子节点。我们知道context的结构是树状的，所以同时我们要注意父节点如果关闭会关闭子节点的context。</li>
</ol>
<h3 id="WithValue和Value"><a href="#WithValue和Value" class="headerlink" title="WithValue和Value"></a>WithValue和Value</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先valueCtx的结构如上所示，包含一个Context和key-val</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个方法很简单，就是创建了一个parent的拷贝，并且将对应的key和val放进去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Value方法就更简单了，就是判断当前key是否匹配，如果不匹配就去子节点寻找。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>最后我们来看看在实际的使用过程中，我们在哪里使用到了context，我举两个实际中常用的框架gin和etcd</p>
<h3 id="gin"><a href="#gin" class="headerlink" title="gin"></a>gin</h3><p>gin是一个web框架，在web开发的时候非常实用。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	router.POST(<span class="string">&quot;/post&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		id := c.Query(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">		page := c.DefaultQuery(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">		name := c.PostForm(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">		message := c.PostForm(<span class="string">&quot;message&quot;</span>)</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;id: %s; page: %s; name: %s; message: %s&quot;</span>, id, page, name, message)</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其实很多web框架都有Context，他们都自己封装了一个Context，利用这个Context可以做到一个request-scope中的参数传递和返回，还有很多操作通通都可以用Context来完成。</p>
<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>如果你没有了解过etcd你就可以把它想象成redis，它其实是一个分布式的k-v数据存储<br>我们在使用etcd进行操作（put或del等）的时候，需要传入context参数<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timeoutCtx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span> * time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">putResponse, err := client.Put(timeoutCtx, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(putResponse.Header.String())</span><br></pre></td></tr></table></figure><br>这里传入的context是一个超时自动取消的context，也就是说，当put操作超过两秒后还没有执行成功的话，context就会自动done，同时这个操作也将被取消。</p>
<p>因为我们在使用etcd的时候，如果当前网络出现异常，无法连接到节点，或者是节点数量不足的时候，都会出现操作被hang住，如果没有定时取消的机制，或者手动取消，那么当前goroutine会被一直占用。所以就利用context来完成这个操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>context在web开发中，你可以类比java中的ThreadLocal，利用它来完成一个request-scope中参数的传递</li>
<li>context可以用于多个goroutine之间的参数传递</li>
<li>context还可以作为完成信号的通知</li>
<li>context并发安全</li>
</ul>
<p>其实，我们不仅要学到context的使用，还可以学到这样设计一个系统的优点，如果以后自己在设计一些框架和系统的时候可以有更多的想法。</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title>大话图解golang map源码详解</title>
    <url>/post/60d021b9.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>网上分析golang中map的源码的博客已经非常多了，随便一搜就有，而且也非常详细，所以如果我再来写就有点画蛇添足了（而且我也写不好，手动滑稽）。但是我还是要写，略略略，这篇博客的意义在于能从几张图片，然后用我最通俗的文字，让没看过源码的人最快程度上了解golang中map是怎么样的。</p>
<span id="more"></span>
<p>当然，因为简单，所以不完美。有很多地方省略了细节问题，如果你觉得没看够，或者本来就想了解详细情况的话在文末给出了一些非常不错的博客，当然有能力还是自己去阅读源码比较靠谱。</p>
<p>那么下面我将从这几个方面来说明，你先记住有下面几个方向，这样可以有一个大致的思路：</p>
<ul>
<li>基础结构：golang中的map是什么样子的，是由什么数据结构组成的？</li>
<li>初始化：初始化之后map是怎么样的？</li>
<li>get：如何获取一个元素？</li>
<li>put：如何存放一个元素？</li>
<li>扩容：当存放空间不够的时候扩容是怎么扩的？</li>
</ul>
<h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="http://blog.linkinstars.com/mweb/15593603213325.jpg" alt><br>这个就是golang中map的结构，其实真的不复杂，我省略了其中一些和结构关系不大的字段，就只剩下这些了。</p>
<h3 id="大话"><a href="#大话" class="headerlink" title="大话"></a>大话</h3><p>大话来描述一些要点：</p>
<ul>
<li><strong>最外面是hmap结构体，用buckets存放一些名字叫bmap的桶（数量不定，是2的指数倍）</strong></li>
<li><strong>bmap是一种有8个格子的桶（一定只有8个格子），每个格子存放一对key-value</strong></li>
<li><strong>bmap有一个overflow，用于连接下一个bmap（溢出桶）</strong></li>
<li><strong>hmap还有oldbuckets，用于存放老数据（用于扩容时）</strong></li>
<li><strong>mapextra用于存放非指针数据（用于优化存储和访问），内部的overflow和oldoverflow实际还是bmap的数组。</strong></li>
</ul>
<p>这就是map的结构，然后我们稍微对比总结一下。</p>
<blockquote>
<p>我们常见的map如java中的map是直接拿数组，数组中直接对应出了key-value，而在golang中，做了多加中间一层，buckets；java中如果key的哈希相同会采用链表的方式连接下去，当达到一定程度会转换红黑树，golang中直接类似链表连接下去，只不过连接下去的是buckets。</p>
</blockquote>
<h3 id="源码一瞥"><a href="#源码一瞥" class="headerlink" title="源码一瞥"></a>源码一瞥</h3><ul>
<li>下面附上源码中它们的样子，方便之后你自己阅读的时候有个印象（注意源码中的样子和编译之后是不同的哟，golang会根据map存放的类型不同来搞定它们实际的样子）<br><img src="http://blog.linkinstars.com/mweb/15593618241922.jpg" alt><br><img src="http://blog.linkinstars.com/mweb/15593618591929.jpg" alt><br><img src="http://blog.linkinstars.com/mweb/15593618386359.jpg" alt></li>
</ul>
<p>那么看完结构你肯定会有疑问？为什么要多一层8个格子的bucket呢？我们怎么确定放在8个格子其中的哪个呢？带着问题往下看。<br><br></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="源码一瞥-1"><a href="#源码一瞥-1" class="headerlink" title="源码一瞥"></a>源码一瞥</h3><p>初始化就不需要图去说明了，因为初始化之后就是产生基础的一个结构，根据map中存放的类型不同。这里主要说明一下，初始化的代码放在什么位置。我也删除了其中一些代码，大致看看就好。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makehmap_small implements Go map creation for make(map[k]v) and</span></span><br><span class="line"><span class="comment">// make(map[k]v, hint) when hint is known to be at most bucketCnt</span></span><br><span class="line"><span class="comment">// at compile time and the map needs to be allocated on the heap.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap_small</span><span class="params">()</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">	h := <span class="built_in">new</span>(hmap)</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makemap implements Go map creation for make(map[k]v, hint).</span></span><br><span class="line"><span class="comment">// If the compiler has determined that the map or the first bucket</span></span><br><span class="line"><span class="comment">// can be created on the stack, h and/or bucket may be non-nil.</span></span><br><span class="line"><span class="comment">// If h != nil, the map can be created directly in h.</span></span><br><span class="line"><span class="comment">// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize Hmap</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = (*hmap)(newobject(t.hmap))</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find size parameter which will hold the requested # of elements</span></span><br><span class="line">	B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中需要注意一个点：“B”</strong>，还记得刚才说名字叫bmap的桶数量是不确定的吗？这个B一定程度上表示的就是桶的数量，当然不是说B是3桶的数量就是3，而是2的3次方，也就是8；当B为5，桶的数量就是32；记住这个B，后面会用到它。</p>
<p>其实你想嘛，初始化还能干什么，<strong>最重要的肯定就是确定一开始要有多少个桶，初始的大小还是很重要的</strong>，还有一些别的初始化哈希种子等等，问题不大。我们的重点还是要放在存/取上面。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p>其实从结构上面来看，我们已经可以摸到一些门道了。先自己想一下，要从一个hashmap中获取一个元素，那么一定是通过key的哈希值去定位到这个元素，那么想着这个大致方向，看下面一张流程图来详细理解golang中是如何实现的。<br><img src="http://blog.linkinstars.com/mweb/15595430252367.jpg" alt></p>
<h3 id="大话-1"><a href="#大话-1" class="headerlink" title="大话"></a>大话</h3><p>下面说明要点：</p>
<ul>
<li><strong>计算出key的hash</strong></li>
<li><strong>用最后的“B”位来确定在哪个桶（“B”就是前面说的那个，B为4，就有16个桶，0101用十进制表示为5，所以在5号桶）</strong></li>
<li><strong>根据key的前8位快速确定是在哪个格子（额外说明一下，在bmap中存放了每个key对应的tophash，是key的前8位）</strong></li>
<li><strong>最终还是需要比对key完整的hash是否匹配，如果匹配则获取对应value</strong></li>
<li><strong>如果都没有找到，就去下一个overflow找</strong></li>
</ul>
<p>总结一下：通过后B位确定桶，通过前8位确定格子，循环遍历连着的所有桶全部找完为止。<br>那么为什么要有这个tophash呢？因为tophash可以快速确定key是否正确，你可以把它理解成一种缓存措施，如果前8位都不对了，后面就没有必要比较了。</p>
<h3 id="源码一瞥-2"><a href="#源码一瞥-2" class="headerlink" title="源码一瞥"></a>源码一瞥</h3><p><img src="http://blog.linkinstars.com/mweb/15595446518430.jpg" alt><br>其中红色的字标出的地方说明了上面的关键点，最后有关key和value具体的存放方式和取出的定位不做深究，有兴趣可以看最后的参考博客。</p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>其实当你知道了如何GET，那么PUT就没有什么难度了，因为本质是一样的。PUT的时候一样的方式去定位key的位置：</p>
<ul>
<li>通过key的后“B”位确定是哪一个桶</li>
<li>通过key的前8位快速确定是否已经存在</li>
<li>最终确定存放位置，如果8个格子已经满了，没地方放了，那么就重新创建一个bmap作为溢出桶连接在overflow</li>
</ul>
<h3 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h3><p><img src="http://blog.linkinstars.com/mweb/15595457248954.jpg" alt><br>这里主要图解说明一下，如果新来的key发现前面有一个格子空着（这个情况是删除造成的），就会记录这个位置，当全部扫描完成之后发现自己确实是新来的，那么就会放前面那个空着的，而不会放最后（我把这个称为紧凑原则，尽可能保证数据存放紧凑，这样下次扫描会快）</p>
<h3 id="代码位置"><a href="#代码位置" class="headerlink" title="代码位置"></a>代码位置</h3><p>go/src/runtime/hashmap.go的mapassign函数就是map的put方法，因为代码很长这里就不多赘述了。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>这个就是最复杂的地方了，但是呢？Don’t worry我这里还是会省略其中某些部分，将最重要的地方拎出来。</p>
<h3 id="扩容的方式"><a href="#扩容的方式" class="headerlink" title="扩容的方式"></a>扩容的方式</h3><ol>
<li>相同容量扩容</li>
<li>2倍容量扩容<br>啥意思呢？第一种出现的情况是：因为map不断的put和delete，出现了很多空格，这些空格会导致bmap很长，但是中间有很多空的地方，扫描时间变长。所以第一种扩容实际是一种整理，将数据整理到前面一起。第二种呢：就是真的不够用了，扩容两倍。</li>
</ol>
<h3 id="扩容的条件"><a href="#扩容的条件" class="headerlink" title="扩容的条件"></a>扩容的条件</h3><h4 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h4><p>如果你看过Java的HashMap实现，就知道有个装载因子，同样的在golang中也有，但是不一样哦。装载因子的定义是这个样子：<br>loadFactor := count / (2^B)<br>其中count为map中元素的个数，B就是之前个那个“B”<br>翻译一下就是装载因子 = （map中元素的个数）/（map当前桶的个数）</p>
<h4 id="扩容条件1"><a href="#扩容条件1" class="headerlink" title="扩容条件1"></a>扩容条件1</h4><p>装载因子 &gt; 6.5（这个值是源码中写的）<br>其实意思就是，桶只有那么几个，但是元素很多，证明有很多溢出桶的存在（可以想成链表拉的太长了），那么扫描速度会很慢，就要扩容。</p>
<h4 id="扩容条件2"><a href="#扩容条件2" class="headerlink" title="扩容条件2"></a>扩容条件2</h4><p>overflow 的 bucket 数量过多：当 B 小于 15，如果 overflow 的 bucket 数量超过 2^B ；当 B &gt;= 15，如果 overflow 的 bucket 数量超过 2^15 。<br>其实意思就是，可能有一个单独的一条链拉的很长，溢出桶太多了，说白了就是，加入的key不巧，后B位都一样，一直落在同一个桶里面，这个桶一直放，虽然装载因子不高，但是扫描速度就很慢。</p>
<h4 id="扩容条件3"><a href="#扩容条件3" class="headerlink" title="扩容条件3"></a>扩容条件3</h4><p>当前不能正在扩容</p>
<h3 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h3><p><img src="http://blog.linkinstars.com/mweb/15595559620626.jpg" alt><br>这张图表示的就是相同容量的扩容，实际上就是一种整理，将分散的数据集合到一起，提高扫描效率。（上面表示扩容之前，下面表示扩容之后）</p>
<p><img src="http://blog.linkinstars.com/mweb/15595560739274.jpg" alt><br>这张图表示的是就是2倍的扩容（上面表示扩容之前，下面表示扩容之后），如果有两个key后三位分别是001和101，当B=2时，只有4个桶，只看最后两位，这两个key后两位都是01所以在一个桶里面；扩容之后B=3，就会有8个桶，看后面三位，于是它们就分到了不同的桶里面。</p>
<h3 id="大话-2"><a href="#大话-2" class="headerlink" title="大话"></a>大话</h3><p>下面说一些扩容时的细节：</p>
<ul>
<li>扩容不是一次性完成的，还记的我们hmap一开始有一个oldbuckets吗？是先将老数据存到这个里面</li>
<li>每次搬运1到2个bucket，当插入或修改、删除key触发</li>
<li>扩容之后肯定会影响到get和put，遍历的时候肯定会先从oldbuckets拿，put肯定也要考虑是否要放到新产生的桶里面去</li>
</ul>
<h3 id="源码一瞥-3"><a href="#源码一瞥-3" class="headerlink" title="源码一瞥"></a>源码一瞥</h3><p><img src="http://blog.linkinstars.com/mweb/15595579954236.jpg" alt><br>扩容的三个条件，看到了吗？这个地方在mapassign方法中。</p>
<p><img src="http://blog.linkinstars.com/mweb/15595581176990.jpg" alt><br>这里可以看到，注释也写的很清楚，如果是加载因子超出了，那么就2倍扩容，如果不是那么就是因为太多溢出桶了，sameSizeGrow表示就是相同容量扩容</p>
<p><img src="http://blog.linkinstars.com/mweb/15595579061242.jpg" alt><br>evacuate是搬运方法，这边可以看到，每次搬运是1到2个</p>
<p>evacuate实在是太长了，也非常复杂，但是情况就是图上描述的那样，有兴趣的可以详细去看，这里不截图说明了。</p>
<h2 id="总结和小问题"><a href="#总结和小问题" class="headerlink" title="总结和小问题"></a>总结和小问题</h2><p>至此你应该对于golang中的map有一个基本的认识了，你还可以去看看删除，你还可以去看看遍历等等，相信有了上面的基本认识那么应该不会难到你。下面有几个小问题：</p>
<ol>
<li>是否线程安全？否，而且并发操作会抛出异常。</li>
<li>源码位置：src/runtime/hashmap.go</li>
<li>每次遍历map顺序是否一致？不一致，每次遍历会随机个数，通过随机数来决定从哪个元素开始。</li>
</ol>
<p>写的仓促，难免疏漏，有问题的地方还请批评指正。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>如果你希望看到源码的各种细节讲解，下面这几篇是我学习的时候看的，供你参考，希望对你有帮助<br><a href="https://github.com/qcrao/Go-Questions/tree/master/map">https://github.com/qcrao/Go-Questions/tree/master/map</a><br><a href="https://github.com/cch123/golang-notes/blob/master/map.md">https://github.com/cch123/golang-notes/blob/master/map.md</a><br><a href="https://draveness.me/golang-hashmap">https://draveness.me/golang-hashmap</a><br><a href="https://lukechampine.com/hackmap.html">https://lukechampine.com/hackmap.html</a></p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的interface</title>
    <url>/post/e21905c6.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>由于golang中说interface的文章太多了，很多都已经说的很细节了，所以我再说感觉也有点难。于是总结出几个关键问题，供你参考，如果能做到准确无误有理有据的回答，那么interface应该是没有问题了。</p>
<span id="more"></span>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>interface底层结构有哪两种，分别是什么样子的，里面保存了哪些信息？</li>
<li>其中tab是什么时候生成的？</li>
<li>从别的类型转换成interface，从interface转换成别的类型，这两者的过程是怎么样的？</li>
<li>两个interface之间是否可以比较？</li>
<li>golang底层是如何判断一个类型是否实现了一个interface？</li>
</ol>
<h2 id="1、底层结构"><a href="#1、底层结构" class="headerlink" title="1、底层结构"></a>1、底层结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 bytes on a 64bit arch</span></span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 bytes on a 64bit arch</span></span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123; <span class="comment">// 40 bytes on a 64bit arch</span></span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123; <span class="comment">// 48 bytes on a 64bit arch</span></span><br><span class="line">    size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    kind       <span class="keyword">uint8</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">    <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">    <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://draveness.me/golang/basic/golang-interface.html">https://draveness.me/golang/basic/golang-interface.html</a></p>
<h2 id="2、tab"><a href="#2、tab" class="headerlink" title="2、tab"></a>2、tab</h2><p>tab结构是itab，里面包含了interfacetype，_type，fun，编译期生成。<br><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md">https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md</a></p>
<h2 id="3、类型转换"><a href="#3、类型转换" class="headerlink" title="3、类型转换"></a>3、类型转换</h2><h3 id="由其他类型转换成interface"><a href="#由其他类型转换成interface" class="headerlink" title="由其他类型转换成interface"></a>由其他类型转换成interface</h3><h4 id="转eface"><a href="#转eface" class="headerlink" title="转eface"></a>转eface</h4><p>转空接口，很简单，将Eface中的data指针指向原型数据，type指针会指向数据的Type结构体。</p>
<h4 id="转iface"><a href="#转iface" class="headerlink" title="转iface"></a>转iface</h4><p>与eface相同，但是需要赋值到itab，并且需要做检测，只有实现接口所有方法才可以进行转换。</p>
<h3 id="interface转其他类型"><a href="#interface转其他类型" class="headerlink" title="interface转其他类型"></a>interface转其他类型</h3><p>那没话说，直接反射走起<br>有这样的语法解决v, ok := i.(T)<br>转换的时候也需要比较能否进行转换</p>
<h2 id="4、类型比较"><a href="#4、类型比较" class="headerlink" title="4、类型比较"></a>4、类型比较</h2><p>两个interface是可以比较的，<br><a href="http://docs.studygolang.com/ref/spec#Comparison_operators">http://docs.studygolang.com/ref/spec#Comparison_operators</a><br>其中说到<br>Interface values are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil.<br>只要两个interface的动态类型相同和值相同就可以。</p>
<h2 id="5、判断实现"><a href="#5、判断实现" class="headerlink" title="5、判断实现"></a>5、判断实现</h2><p>这个判断其实在检测的时候都需要用到。<br>检测就是看Type中的方法表是否包含了InterfaceType的方法表中的所有方法，并把Type方法表中的实现部分拷到Itab的func那张表中。其中表中的数据都是排序过的，所以对比起来快。<br><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html</a></p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang指针与unsafe</title>
    <url>/post/f8988a3a.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们知道在golang中是存在指针这个概念的。对于指针很多人有点忌惮（可能是因为之前学习过C语言），因为它会导致很多异常的问题。但是很多人学习之后发现，golang中的指针很简单，没有C那么复杂。所以今天就详细来说说指针。</p>
<span id="more"></span>
<h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">p := &amp;a</span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure>
<p>输出：0xc42001c070</p>
<p>可以看到p就是一个指针，也可以说是a的地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">p = &amp;a</span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure>
<p>或者也可以写成这样，因为我知道，在很多人看来，看到*号才是指针（手动滑稽）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">p := &amp;a</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure>
<p>输出：1</p>
<p>然后使用就直接通过*号就能去到对应的值了，就这么简单</p>
<h2 id="指针的限制"><a href="#指针的限制" class="headerlink" title="指针的限制"></a>指针的限制</h2><p>Golang中指针之所以看起来很简单，是因为指针的功能不多。我们能看到的功能就是指针的指向一个地址而已，然后对于这个地址也只能进行传递，或者通过这个的地址去访问值。</p>
<ul>
<li>不能像C语言中一样p++，这样移动操作指针，因为其实这样操作确实不安全，很容易访问到奇怪的区域。</li>
<li>不同类型的指针不能相互赋值、转换、比较。会出现cannot use &amp;a (type <em>int) as type </em>float32 in assignment类似这样的错误</li>
</ul>
<p>如果只是单纯说go中指针的功能，上面就已经说完了，没必要写博客，但是其实go中还有一个包叫unsafe，有了它，指针就可以像C一样想干嘛干嘛了。</p>
<h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><h3 id="三个类型"><a href="#三个类型" class="headerlink" title="三个类型"></a>三个类型</h3><p>其实指针有三种：<br>一种是我们常见的<code>*</code>，用*去表示的指针；<br>一种是unsafe.Pointer，Pointer是unsafe包下的一个类型；<br>最后一种是uintptr，uintptr就厉害了，这玩意是可以进行运算的也就是可以++–；</p>
<p><strong>他们之间有这样的转换关系：</strong><br><code>*</code>  &lt;=&gt;  unsafe.Pointer  &lt;=&gt;  uintptr</p>
<ul>
<li>有一点要注意的是，uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。</li>
</ul>
<p>从这样的关系你大概就可以猜到，我们使用的指针*p转换成Pointer然后转换uintptr进行运算之后再原路返回，理论上就能等同于进行了指针的运算。我们下面就来实践一下。</p>
<h3 id="unsafe操作slice"><a href="#unsafe操作slice" class="headerlink" title="unsafe操作slice"></a>unsafe操作slice</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    s[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    p := &amp;s[<span class="number">0</span>]</span><br><span class="line">    fmt.Println(*p)</span><br><span class="line">    </span><br><span class="line">    up := <span class="keyword">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">    up += unsafe.Sizeof(<span class="keyword">int</span>(<span class="number">0</span>)) <span class="comment">// 这里可不是up++哦</span></span><br><span class="line"></span><br><span class="line">    p2 := (*<span class="keyword">int</span>)(unsafe.Pointer(up))</span><br><span class="line">    fmt.Println(*p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>0<br>2</p>
<p>从代码中我们可以看到，我们首先将指针指向切片的第一个位置，然后通过转换得到uintptr，操作uintptr + 上8位（注意这里不能++因为存放的是int，下一个元素位置相隔举例int个字节），最后转换回来得到指针，取值，就能取到切片的第二个位置了。</p>
<h3 id="unsafe操作struct"><a href="#unsafe操作struct" class="headerlink" title="unsafe操作struct"></a>unsafe操作struct</h3><p>当然有人肯定要说了，上面那个一顿操作猛如虎，不就是访问下一个位置嘛，我直接访问就行了。<br>那下面就是厉害的来了，我们知道如果一个结构体里面定义的属性是私有的，那么这个属性是不能被外界访问到的。我们来看看下面这个操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user := &amp;basic.User&#123;&#125;</span><br><span class="line">    fmt.Println(user)</span><br><span class="line">    </span><br><span class="line">    s := (*<span class="keyword">int</span>)(unsafe.Pointer(user))</span><br><span class="line">    *s = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    up := <span class="keyword">uintptr</span>(unsafe.Pointer(user)) + unsafe.Sizeof(<span class="keyword">int</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    namep := (*<span class="keyword">string</span>)(unsafe.Pointer(up))</span><br><span class="line">    *namep = <span class="string">&quot;xxx&quot;</span> </span><br><span class="line"></span><br><span class="line">    fmt.Println(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>User是另外一个basic包中的结构体，其中的age是小写开头的，理论上来说，我们在外部没有办法修改age的值，但是经过上面这波操作之后，输出信息是：<br>&amp;{0 }<br>&amp;{10 xxx}<br>也就是说成功操作到了结构体的私有属性。</p>
<p>顺便提一句：创建结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。</p>
<blockquote>
<p>下面我们来验证一下你是否已经学会了unsafe的操作，尝试不看一个小结，自己尝试一下：如何完成字符串到[]byte的转换，并且不开辟新的空间？</p>
</blockquote>
<p><br><br><br><br><br><br><br></p>
<h3 id="字符串和byte数组转换inplace"><a href="#字符串和byte数组转换inplace" class="headerlink" title="字符串和byte数组转换inplace"></a>字符串和byte数组转换inplace</h3><p>我们知道如果将字符串转换成[]byte非常方便<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;123&quot;</span></span><br><span class="line">a := []<span class="keyword">byte</span>(s)</span><br></pre></td></tr></table></figure><br>但是这样需要开辟额外的空间，那么如何实现原地的，不需要拷贝数据的转换呢？<br>我们想一下，其实从底层的存储角度来说，string的存储规则和[]byte是一样的，也就是说，其实指针都是从某个位置开始到一段空间，中间一格一格。所以利用unsafe就可以做到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;123&quot;</span></span><br><span class="line">    a := []<span class="keyword">byte</span>(s)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;s = &quot;</span> , &amp;s, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span> , &amp;a, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    a2 := (*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a2 = &quot;</span> , a2, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(*a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>s = 0xc420055f40<br>a = 0xc420055f60<br>a2 = 0xc420055f40<br>[49 50 51]</p>
<p>我们可以看到s和a的地址是不一样的，但是s和a2的地址是一样的，并且a2已经是一个[]byte了。<br><br><br><br><br><br><br>嘿嘿嘿~你以为这样就结束了？？？</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p><strong>其实这个转换是存在问题的，问题就在新的[]byte的Cap没有正确的初始化。</strong><br>我们打印一下cap看一下<br>fmt.Println(“cap a =”, cap(a))<br>fmt.Println(“cap a2 =”, cap(*a2))<br>结果是：<br>cap a = 32<br>cap a2 = 17418400<br>这么大的容量是要上天呢？？？</p>
<h4 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h4><p>在src/reflect/value.go下看<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到其实string没有cap而[]byte有，所以导致问题出现，也容易理解，string是没有容量扩容这个说法的，所以新的[]byte没有赋值cap所以使用了默认值。</p>
<h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line"></span><br><span class="line">bh := reflect.SliceHeader&#123;</span><br><span class="line">	Data: stringHeader.Data,</span><br><span class="line">	Len:  stringHeader.Len,</span><br><span class="line">	Cap:  stringHeader.Len,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;bh))</span><br></pre></td></tr></table></figure>
<p>通过重新设置SliceHeader就可以完成</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是所有golang指针和unsafe的相关细节和使用。那么肯定有人会问这个有什么用了？</p>
<ul>
<li>1、没啥事你就别乱用了，别人都说unsafe不安全了。</li>
<li>2、源码中很多大量的使用了指针移动的操作。</li>
</ul>
<p>如map中通过key获取value的时候：</p>
<blockquote>
<p>v := add(unsafe.Pointer(b), dataOffset+bucketCnt <em> uintptr(t.keysize)+i </em> uintptr(t.valuesize))</p>
</blockquote>
<p>通过桶的指针的偏移拿到值，具体我就不多介绍了。<br>总之对于你看golang源码的时候会有很大帮助的。可能必要的时候你也能用到它，还是那句话，除非你知道它在干什么，否则不要用。</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>unsafe</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang之reflect</title>
    <url>/post/233cb1a0.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>反射 —— 如果你之前学过一些别的语言，比如java可能就会了解，反射是一个传说中很厉害的操作，算是一个高级用法。而同时，很多人也会告诉你，反射是一个危险的操作，那么在golang中，反射又是怎么操作的呢？今天就来说说golang中的反射reflect。</p>
<span id="more"></span>
<h2 id="反射的定义"><a href="#反射的定义" class="headerlink" title="反射的定义"></a>反射的定义</h2><p>首先问问自己，你知道什么是反射吗？如果你有一个清楚的定义，证明你已经对反射非常熟悉了。<br>官方的定义很官方，我就说说我的：<br>反射，反射，从字面理解就是通过镜子（或类似的东西）看到自己。<br>而在编程中，反射指的是在<strong>运行的过程中</strong>看到自己。<br>在实际的编程过程中我们知道，创建的这个变量或者对象是什么类型或者是什么样子的，同时很容易能对它进行操作。而在运行过程中，程序没有我们的眼睛，它并不知道这个东西是怎么样的，这个时候就需要运用到反射。<br><em>通过反射我可以知道自己长什么样子。</em></p>
<h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><h3 id="reflect-TypeOf"><a href="#reflect-TypeOf" class="headerlink" title="reflect.TypeOf"></a>reflect.TypeOf</h3><p>如果你对反射还是有些模糊，那么看下面这个最简单的例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1.3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a的类型是&quot;</span>, reflect.TypeOf(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a的类型是 float64</span><br></pre></td></tr></table></figure><br>是不是瞬间明白了，没错，反射没有那么复杂。<br>你想想，作为程序自己，我运行中，我怎么知道a是什么类型，只能通过照镜子（反射）得到。</p>
<p>下面再说说一些更高级的用法。</p>
<h3 id="reflect-ValueOf"><a href="#reflect-ValueOf" class="headerlink" title="reflect.ValueOf"></a>reflect.ValueOf</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println(v.Type())</span><br><span class="line">    fmt.Println(v.Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.MyInt</span><br><span class="line">int</span><br></pre></td></tr></table></figure><br>这里我们通过<code>reflect.ValueOf</code>方法拿到的v，其中v.Type()拿到的是它当前的类型，而v.Kind()可以拿到它最基本的类型。</p>
<h3 id="Elem"><a href="#Elem" class="headerlink" title="Elem()"></a>Elem()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1.3</span></span><br><span class="line">    v := reflect.ValueOf(&amp;a)</span><br><span class="line">    elem := v.Elem()</span><br><span class="line">    elem.SetFloat(<span class="number">0.2</span>)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.2</span><br></pre></td></tr></table></figure><br>这里我们可以看到，通过反射拿到v使用v.Elem()方法可以拿到对应指针进行操作赋值</p>
<h3 id="Field"><a href="#Field" class="headerlink" title="Field()"></a>Field()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyData <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">float32</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myData := MyData&#123;</span><br><span class="line">        A: <span class="number">1</span>,</span><br><span class="line">        b: <span class="number">1.1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    myDataV := reflect.ValueOf(&amp;myData).Elem()</span><br><span class="line">    fmt.Println(<span class="string">&quot;字段a:&quot;</span>, myDataV.Field(<span class="number">0</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;字段b:&quot;</span>, myDataV.Field(<span class="number">1</span>))</span><br><span class="line">    fmt.Println(myDataV)</span><br><span class="line">    myDataV.Field(<span class="number">0</span>).SetInt(<span class="number">2</span>)</span><br><span class="line">    fmt.Println(myDataV)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">字段a: <span class="number">1</span></span><br><span class="line">字段b: <span class="number">1.1</span></span><br><span class="line">&#123;<span class="number">1</span> <span class="number">1.1</span>&#125;</span><br><span class="line">&#123;<span class="number">2</span> <span class="number">1.1</span>&#125;</span><br></pre></td></tr></table></figure><br>这里我们可以看到，我们即使不知道一个结构体里面的情况，我们依旧可以通过Field方法获得其中的值，并且<strong>如果这个变量可以被外界访问</strong>那么还可以修改。</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface()"></a>Interface()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1.3</span></span><br><span class="line">    v := reflect.ValueOf(a)</span><br><span class="line">    a1 := v.Interface().(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(a1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.3<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a的类型是 float64</span><br></pre></td></tr></table></figure><br>反射之后的对象通过Interface还可以转换回来</p>
<h2 id="反射的法则"><a href="#反射的法则" class="headerlink" title="反射的法则"></a>反射的法则</h2><p>上面就是一些反射的基本用法，常用的就是获取一个对象在运行中的一个状态，或者是针对运行中的一个不确定的对象进行修改。下面要说的是反射的法则。<br>如果你英文够好，并且网络自由，可以看看golang官方的博客：<br><a href="https://blog.golang.org/laws-of-reflection">https://blog.golang.org/laws-of-reflection</a><br>里面详细描述了反射的三个法则，如果你看不到，那就只能听我下面吹一吹了。</p>
<blockquote>
<ul>
<li>Reflection goes from interface value to reflection object.</li>
<li>Reflection goes from reflection object to interface value.</li>
<li>To modify a reflection object, the value must be settable.</li>
</ul>
</blockquote>
<p>这三个就是官方给出的法则，我分别用自己的话解释一下。</p>
<h3 id="反射就是将任意值转换为反射对象"><a href="#反射就是将任意值转换为反射对象" class="headerlink" title="反射就是将任意值转换为反射对象"></a>反射就是将任意值转换为反射对象</h3><p>在golang中我们知道interface就和java中的Object类似（只是类似而已），代表了所有类型，reflect包正是帮我们将任意的一个类型转换成了我们上面例子中看到的一个v，这个v就是反射对象。<br>通过这个反射对象中的一些方法我们才能看见原来的对象是什么样子。</p>
<h3 id="反射对象可以转换为任意对象"><a href="#反射对象可以转换为任意对象" class="headerlink" title="反射对象可以转换为任意对象"></a>反射对象可以转换为任意对象</h3><p>这个正好与第一个相反，就像最后一个例子中给出的，反射获得的反射对象可以通过Interface方法转换为原来的对象。</p>
<h3 id="如果你要修改反射对象，那么这个对象必须要可以被修改"><a href="#如果你要修改反射对象，那么这个对象必须要可以被修改" class="headerlink" title="如果你要修改反射对象，那么这个对象必须要可以被修改"></a>如果你要修改反射对象，那么这个对象必须要可以被修改</h3><p>什么意思呢？就如同这个案例中<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1.3</span></span><br><span class="line">    v := reflect.ValueOf(&amp;a)</span><br><span class="line">    elem := v.Elem()</span><br><span class="line">    elem.SetFloat(<span class="number">0.2</span>)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果我们传递的并非a的地址并且直接使用v.SetFloat那么就会报错，因为我们无法对其进行修改，反射会帮我们copy一个，所以无法修改，只有当我们使用指针的时候才能修改。</p>
<p>同样的，和案例中的结构体操作一样，如果一个结构体的变量是小写的而不是大写的，证明外界没有办法访问到，所以也没有办法修改，也会出现异常。</p>
<h2 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h2><p>下面就需要看看在源码中，反射到底是怎么实现的了。<br>我们着重看两个方法<code>TypeOf</code>和<code>ValueOf</code></p>
<h3 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看这个简单的<code>TypeOf</code>看到源码中很简单，通过unsafe.Pointer获得指针转换成emptyInterface类型<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// emptyInterface is the header for an interface&#123;&#125; value.</span></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后通过toType方法得到具体类型<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中Type就包含了所有的信息，然后返回出去就完成了。</p>
<h3 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i. ValueOf(nil) returns the zero Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Maybe allow contents of a Value to live on the stack.</span></span><br><span class="line">	<span class="comment">// For now we make the contents always escape to the heap. It</span></span><br><span class="line">	<span class="comment">// makes life easier in a few places (see chanrecv/mapassign</span></span><br><span class="line">	<span class="comment">// comment below).</span></span><br><span class="line">	escapes(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面nil就不说了，主要方法是下面unpackEface<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unpackEface converts the empty interface i to a Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> don&#x27;t read e.word until we know whether it is really a pointer or not.</span></span><br><span class="line">	t := e.typ</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f := flag(t.Kind())</span><br><span class="line">	<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">		f |= flagIndir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到其实与TypeOf一样，只不过多封装了一层Value，其中的word就是当前对象的指针，因为我们知道通过TypeOf得到的Value可以用很多操作。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// emptyInterface is the header for an interface&#123;&#125; value.</span></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="反射的意义"><a href="#反射的意义" class="headerlink" title="反射的意义"></a>反射的意义</h2><p>说了这么多，那么反射存在的意义到底在哪？说白了，我们在写代码的时候什么时候能用上它？<br>还是举个例子你就明白了。</p>
<h3 id="json-Marshal案例"><a href="#json-Marshal案例" class="headerlink" title="json.Marshal案例"></a>json.Marshal案例</h3><p>json.Marshal这个方法用过吧，是将任意对象转换成json，这个案例就足以说明反射的厉害了。<br>我们先自己想一下，如果要将一个对象转换成json：</p>
<ul>
<li>我们运行之前其实是不知道传入对象的类型，而且传入的对象不同，那么解析方式肯定不同，如果传入的是map或者传入的是struct肯定解析方式不同，所以方法内部需要动态的判断传入类型从而做操作。</li>
<li>还有我们不知道传入的struct内部的属性长什么样子。</li>
</ul>
<p>这个时候反射就能解决这样的问题，通过反射可以知道传入对象的类型，根据不同的类型做操作，同时可以获取到如struct这样类型内部的字段属性和值分别是多少。</p>
<h3 id="json-Marshal源码分析"><a href="#json-Marshal源码分析" class="headerlink" title="json.Marshal源码分析"></a>json.Marshal源码分析</h3><p>因为所有源码太多，我给出查看路线，然后给出上面所述的两处重点。<br>json.Marshal -&gt; e.marshal -&gt; e.reflectValue -&gt; valueEncoder -&gt; typeEncoder -&gt; newTypeEncoder -&gt; newStructEncoder -&gt; se.encode</p>
<h4 id="要点1-newTypeEncoder"><a href="#要点1-newTypeEncoder" class="headerlink" title="要点1 - newTypeEncoder"></a>要点1 - newTypeEncoder</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newTypeEncoder constructs an encoderFunc for a type.</span></span><br><span class="line"><span class="comment">// The returned encoder only checks CanAddr when allowAddr is true.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTypeEncoder</span><span class="params">(t reflect.Type, allowAddr <span class="keyword">bool</span>)</span> <span class="title">encoderFunc</span></span> &#123;</span><br><span class="line">	...........</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">return</span> boolEncoder</span><br><span class="line">	<span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</span><br><span class="line">		<span class="keyword">return</span> intEncoder</span><br><span class="line">	<span class="keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</span><br><span class="line">		<span class="keyword">return</span> uintEncoder</span><br><span class="line">	<span class="keyword">case</span> reflect.Float32:</span><br><span class="line">		<span class="keyword">return</span> float32Encoder</span><br><span class="line">	<span class="keyword">case</span> reflect.Float64:</span><br><span class="line">		<span class="keyword">return</span> float64Encoder</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		<span class="keyword">return</span> stringEncoder</span><br><span class="line">	<span class="keyword">case</span> reflect.Interface:</span><br><span class="line">		<span class="keyword">return</span> interfaceEncoder</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		<span class="keyword">return</span> newStructEncoder(t)</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="keyword">return</span> newMapEncoder(t)</span><br><span class="line">	<span class="keyword">case</span> reflect.Slice:</span><br><span class="line">		<span class="keyword">return</span> newSliceEncoder(t)</span><br><span class="line">	<span class="keyword">case</span> reflect.Array:</span><br><span class="line">		<span class="keyword">return</span> newArrayEncoder(t)</span><br><span class="line">	<span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">		<span class="keyword">return</span> newPtrEncoder(t)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> unsupportedTypeEncoder</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反射获得传入对象的类型，判断选择具体的编码器进行编码，如果传入的是map那就…如果传入的是struct那就…</p>
<h4 id="要点2-se-encode"><a href="#要点2-se-encode" class="headerlink" title="要点2 - se.encode"></a>要点2 - se.encode</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(se *structEncoder)</span> <span class="title">encode</span><span class="params">(e *encodeState, v reflect.Value, opts encOpts)</span></span> &#123;</span><br><span class="line">	e.WriteByte(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">	first := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> i, f := <span class="keyword">range</span> se.fields &#123;</span><br><span class="line">		fv := fieldByIndex(v, f.index)</span><br><span class="line">		<span class="keyword">if</span> !fv.IsValid() || f.omitEmpty &amp;&amp; isEmptyValue(fv) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> first &#123;</span><br><span class="line">			first = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			e.WriteByte(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		e.<span class="keyword">string</span>(f.name, opts.escapeHTML)</span><br><span class="line">		e.WriteByte(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">		opts.quoted = f.quoted</span><br><span class="line">		se.fieldEncs[i](e, fv, opts)</span><br><span class="line">	&#125;</span><br><span class="line">	e.WriteByte(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fieldByIndex</span><span class="params">(v reflect.Value, index []<span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> index &#123;</span><br><span class="line">		<span class="keyword">if</span> v.Kind() == reflect.Ptr &#123;</span><br><span class="line">			<span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">				<span class="keyword">return</span> reflect.Value&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			v = v.Elem()</span><br><span class="line">		&#125;</span><br><span class="line">		v = v.Field(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>encode这个方法是解析结构体的，我们可以清楚的看的从结构体中通过v.Field将里面的参数拿出来。<br>其他细节这里就不做说明了，主要的目的是要表示反射在其中起到的重要作用。</p>
<h2 id="总结和提醒"><a href="#总结和提醒" class="headerlink" title="总结和提醒"></a>总结和提醒</h2><p>看完你就应该清楚反射到底是做什么用的，具体我们什么时候会用到它。最后还要提醒一下，反射也存在两个必然的问题：</p>
<ul>
<li>第一个是<strong>不安全</strong>，因为反射的类型在转换中极易出现问题，所以使用需谨慎。</li>
<li>第二个是<strong>速度慢</strong>，之所以有人抨击golang的json解析库慢，一部分原因就是因为其中涉及到了反射，所以如果对效率有要求的地方就要斟酌使用了。</li>
</ul>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 读写锁RWMutex 互斥锁Mutex 源码详解</title>
    <url>/post/bde46176.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Golang中有两种类型的锁，Mutex （互斥锁）和RWMutex（读写锁）对于这两种锁的使用这里就不多说了，本文主要侧重于从源码的角度分析这两种锁的具体实现。</p>
<span id="more"></span>
<h2 id="引子问题"><a href="#引子问题" class="headerlink" title="引子问题"></a>引子问题</h2><p>我一般喜欢带着问题去看源码。那么对于读写锁，你是否有这样的问题，为什么可以有多个读锁？有没有可能出现有协程一直无法获取到写锁的情况？带着你的疑问来往下看看，具体这个锁是如何实现的。</p>
<p>如果你自己想看，我给出阅读的一个思路，可以先看读写锁，因为读写锁的实现依赖于互斥锁，并且读写锁比较简单一些，然后整理思路之后再去想一下实际的应用场景，然后再去看互斥锁。</p>
<p>下面我就会按照这个思路一步步往下走。</p>
<h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><ul>
<li>知识点1：信号量<br>信号量是 Edsger Dijkstra 发明的数据结构（没错就是那个最短路径算法那个牛人），在解决多种同步问题时很有用。其本质是一个整数，并关联两个操作：</li>
</ul>
<p>申请acquire（也称为 wait、decrement 或 P 操作）<br>释放release（也称 signal、increment 或 V 操作）</p>
<p>acquire操作将信号量减 1，如果结果值为负则线程阻塞，且直到其他线程进行了信号量累加为正数才能恢复。如结果为正数，线程则继续执行。<br>release操作将信号量加 1，如存在被阻塞的线程，此时他们中的一个线程将解除阻塞。</p>
<ul>
<li><p>知识点2：锁的定义<br><img src="http://blog.linkinstars.com/mweb/15584204613293.jpg" alt><br>在goalng中如果实现了Lock和Unlock方法，那么它就可以被称为锁。</p>
</li>
<li><p>知识点3：锁的自旋：（详见百度）</p>
</li>
<li><p>知识点4：cas算法：（最好有所了解，不知道问题也不大）</p>
</li>
</ul>
<h2 id="读写锁RWMutex"><a href="#读写锁RWMutex" class="headerlink" title="读写锁RWMutex"></a>读写锁RWMutex</h2><h3 id="首先我们来看看RWMutex大体结构"><a href="#首先我们来看看RWMutex大体结构" class="headerlink" title="首先我们来看看RWMutex大体结构"></a>首先我们来看看RWMutex大体结构</h3><p><img src="http://blog.linkinstars.com/mweb/15584205421002.jpg" alt><br>看到结构发现读写锁内部包含了一个w Mutex互斥锁<br>注释也很明确，<strong>这个锁的目的就是控制多个写入操作的并发执行</strong><br>writerSem是写入操作的信号量<br>readerSem是读操作的信号量<br>readerCount是当前读操作的个数<br>readerWait当前写入操作需要等待读操作解锁的个数<br>这几个现在看不懂没关系，后面等用到了你再回来看就好了。</p>
<h3 id="然后我们看看方法"><a href="#然后我们看看方法" class="headerlink" title="然后我们看看方法"></a>然后我们看看方法</h3><p><img src="http://blog.linkinstars.com/mweb/15584206811382.jpg" alt><br>一共有5个方法，看起来就不复杂，我们一个个来看。</p>
<p><img src="http://blog.linkinstars.com/mweb/15584207933845.jpg" alt><br>这个最简单，就是返回一个locker对象没啥好说的</p>
<p>问题的关键就在于锁和解锁的几个方法，因为我已经看过，所以推荐这几个方法的阅读顺序是RLock Lock RUnlock Unlock</p>
<h3 id="RLock（获取读锁）"><a href="#RLock（获取读锁）" class="headerlink" title="RLock（获取读锁）"></a>RLock（获取读锁）</h3><p><img src="http://blog.linkinstars.com/mweb/15584212283633.jpg" alt><br>先不看竞态检测的部分，先重点看红色框中的部分<br>可以看到，其实很简单，每当有协程需要获取读锁的时候，就将readerCount + 1<br>但是需要注意的是，这里有一个条件，当readerCount + 1之后的值 &lt; 0的时候，那么将会调用runtime_Semacquire方法<br><img src="http://blog.linkinstars.com/mweb/15584216533656.jpg" alt><br>这个方法是一个runtime的方法，会一直等待传入的s出现&gt;0的时候<br>然后我们可以记得，这里有这样一个情况，当出先readerCount + 1为负数的情况那么就会被等待，看注释我们可以猜到，<strong>是当有写入操作出现的时候，那么读操作就会被等待。</strong></p>
<h3 id="Lock（获取写锁）"><a href="#Lock（获取写锁）" class="headerlink" title="Lock（获取写锁）"></a>Lock（获取写锁）</h3><p><img src="http://blog.linkinstars.com/mweb/15584229836367.jpg" alt><br>写锁稍微复杂一些，但是样子也差不多，我们还是先来看红色框中的部分。<br>首先操作最前面说的互斥锁，目的就是处理多个写锁并发的情况，因为我们知道写锁只有一把。这里不需要深入互斥锁，只需要知道，互斥锁只有一个人能拿到，所以写锁只有一个人能拿到。</p>
<p>然后重点来了，这里的这个操作细细体会一下，atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders)<br>是将当前的readerCount减去一个非常大的值rwmutexMaxReaders为1 &lt;&lt; 30<br>大概是1073741823这么大吧</p>
<p>所以我们可以从源码中看出，readerCount由于每有一个协程获取读锁就+1，一直都是正数，而当有写锁过来的时候，就瞬间减为很大的负数。<br>然后做完上面的操作以后的r其实就是原来的readerCount。<br>后面进行判断，如果原来的readerCount不为0（原来有协程已经获取到了读锁）并且将readerWait加上readerCount（表示需要等待readerCount这么多个读锁进行解锁），如果满足上述条件证明原来有读锁，所以暂时没有办法获取到写锁，所以调用runtime_Semacquire进行等待，等待的信号量为writerSem</p>
<h3 id="RUnlock（释放读锁）"><a href="#RUnlock（释放读锁）" class="headerlink" title="RUnlock（释放读锁）"></a>RUnlock（释放读锁）</h3><p><img src="http://blog.linkinstars.com/mweb/15584242415804.jpg" alt><br>如果是我们来写的话，可能就是将之前+1的readerCount，-1就完事了，但是其实还有一些操作需要注意。<br>如果-1之后+1==0是啥情况？没错就是我们常见的，新手程序员，<strong>没有获取读锁就想去释放读锁</strong>，于是异常了。当然+1之后刚好是rwmutexMaxReaders，<strong>就证获取了写锁而去释放了读锁</strong>，导致异常。<br>除去异常情况，剩下的就是r还是&lt;0的情况，那么证明确实有协程正在想要获取写锁，那么就需要操作我们前面看到的readerWait，当readerWait减到0的时候就证明没有人正在持有写锁了，就通过信号量writerSem的变化告知刚才等待的协程（想要获取写锁的协程）：你可以进行获取了。</p>
<p>到这里你可以把思路大致串起来了，然后懂了再往下看。</p>
<h3 id="Unlock（释放写锁）"><a href="#Unlock（释放写锁）" class="headerlink" title="Unlock（释放写锁）"></a>Unlock（释放写锁）</h3><p><img src="http://blog.linkinstars.com/mweb/15584247454301.jpg" alt><br>写锁释放需要恢复readerCount，还记得上锁的时候减了一个很大的数，这个时候要加回来了。<br>当然加完之后如果&gt;=rwmutexMaxReaders本身，那么还是新手程序员的问题，当没有获取写锁的时候就开始想着释放写锁了。<br>然后for循环就是为了通知所有在我们RLock方法中看到的，当有因为持有写锁所以等待的那些协程，通过信号量readerSem告诉他们可以动了。<br>最后别忘记还有一个互斥锁需要释放，让别的协程也可以开始抢写锁了。</p>
<p>至此，读写锁的分析基本上告一段落了。<br>针对于其中关于竞态分析的代码，有兴趣的小伙伴可以去了解一下。</p>
<h2 id="互斥锁Mutex"><a href="#互斥锁Mutex" class="headerlink" title="互斥锁Mutex"></a>互斥锁Mutex</h2><p>互斥锁比读写锁复杂，但是好在golang给的注释很详细，所以也不困难（注释真的很重要）。<br>我们先来看看里面的一段注释：<br><img src="http://blog.linkinstars.com/mweb/15584287274923.jpg" alt><br>很长的一段英文，我用英语四级的翻译能力给你翻译一下，可以将就看看，<strong>如果可以建议你仔细看英文看懂它</strong>，因为这对于后面的源码阅读非常重要。<br>///<br>这个互斥锁是公平锁</p>
<p>互斥锁有两种操作模式：正常模式和饥饿模式。<br>在正常模式下等待获取锁的goroutine会以一个先进先出的方式进行排队，但是被唤醒的等待者并不能代表它已经拥有了这个mutex锁，它需要与新到达的goroutine争夺mutex锁。新来的goroutine有一个优势 —— 他们已经在CPU上运行了并且他们，所以抢到的可能性大一些，所以一个被唤醒的等待者有很大可能抢不过。在这样的情况下，被唤醒的等待者在队列的头部。如果一个等待者抢锁超过1ms失败了，就会切换为饥饿模式。</p>
<p>在饥饿模式下，mutex锁会直接由解锁的goroutine交给队列头部的等待者。<br>新来的goroutine不能尝试去获取锁，即使可能根本就没goroutine在持有锁，并且不能尝试自旋。取而代之的是他们只能排到队伍尾巴上乖乖等着。</p>
<p>如果一个等待者获取到了锁，并且遇到了下面两种情况之一，就恢复成正常工作模式。<br>情况1：它是最后一个队列中的等待者。<br>情况2：它等待的时间小于1ms</p>
<p>正常模式下，即使有很多阻塞的等待者，有更好的表现，因为一轮能多次获得锁的机会。饥饿模式是为了避免那些一直在队尾的倒霉蛋。<br>///  </p>
<p>我的话简单总结就是，互斥锁有两种工作模式，竞争模式和队列模式，竞争就是大家一起抢，队列就是老老实实排队，这两种工作模式会通过一些情况进行切换。</p>
<h3 id="首先还是来看看大体结构"><a href="#首先还是来看看大体结构" class="headerlink" title="首先还是来看看大体结构"></a>首先还是来看看大体结构</h3><p><img src="http://blog.linkinstars.com/mweb/15584280789129.jpg" alt><br>可以看到，相对读写锁，结构上面很简单，只有两个值，但是千万不要小瞧它，减少了字段就增加了理解难度。<br>state：将一个32位整数拆分为：<br>当前阻塞的goroutine数(29位)<br>饥饿状态(1位，0为正常模式；1为饥饿模式)<br>唤醒状态(1位，0未唤醒；1已唤醒)<br>锁状态(1位，0可用；1占用) </p>
<p>sema：信号量</p>
<p><img src="http://blog.linkinstars.com/mweb/15584281281348.jpg" alt><br>方法也很简单，就是Lock和Unlock两个方法，一个上锁，一个解锁，没啥好说的。</p>
<h3 id="一个方法"><a href="#一个方法" class="headerlink" title="一个方法"></a>一个方法</h3><p>我们先来看一个的要用到的方法</p>
<p>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)<br>这个函数，会先判断参数addr指向的被操作值与参数old的值是否相等，如果相等会将参数new替换参数addr所指向的值，不然的话就啥也不做。<br>需要特别说明的是，这个方法并不会阻塞。</p>
<h3 id="几个常量"><a href="#几个常量" class="headerlink" title="几个常量"></a>几个常量</h3><p>这是定义的几个常量，我们在一开始的注释周围可以看到，后面需要用到，暂时记住它们的初始值就好。</p>
<p>mutexLocked = 1 &lt;&lt; iota // 1左移0位，是1，二进制是1，（1表示已经上锁）<br>mutexWoken              // 1左移1位，是2，二进制是10<br>mutexStarving           // 1左移2位，是4，二进制是100<br>mutexWaiterShift = iota // 就是3， 二进制是11</p>
<p>starvationThresholdNs = 1e6  // 这个就是我们一开始在注释里面看到的1ms，一定超过这个门限值就会更换模式</p>
<h3 id="Lock获取锁"><a href="#Lock获取锁" class="headerlink" title="Lock获取锁"></a>Lock获取锁</h3><p>因为Lock方法比较长，所以我切分一段段看，需要完整的请自己翻看源码。<strong>要注意的一点是，一定要时刻记住，Lock方法是做什么的，很简单，就是要抢锁。看不懂的时候想想这个目标。</strong><br><img src="http://blog.linkinstars.com/mweb/15584895207182.jpg" alt><br>第一步，判断state状态是否为0，如果为0，证明没有协程持有锁，那么就很简单了，直接获取到锁，将mutexLocked（为1）赋值到state就可以了。</p>
<p>看后面的方法时，告诉需要告诉你们一个小技巧，当遇到这种位操作很多的情况，有两个方法挺好用，对于你看源码会有帮助：<br>第一个是将所有定值先计算，然后判断非定值的情况；<br>第二个是将所有的计算写下来，自己用笔去计算，不要执着于打字。</p>
<p>然后我们以下面这个段举例：<br><img src="http://blog.linkinstars.com/mweb/15585949117771.jpg" alt><br>首先，看注释应该能明白这一段大致意思是，如果不是饥饿模式，就会进行自旋操作，然后不断循环。</p>
<p>然后根据上面的技巧，old&amp;(mutexLocked|mutexStarving) == mutexLocked<br>（下面均为二进制）<br>mutexLocked = 1<br>mutexStarving = 11<br>mutexLocked = 1<br>这三个是定值，所以我们容易得到，满足情况的结果为，当old为xxxx0xx（二进制第三位为0）等式成立。<br>也就是我们一开始说的，state的第三位是表示这个锁当前的模式，0为正常模式，1为饥饿模式。</p>
<p>那么第一个if就表示，如果当前模式为正常模式，且可以自旋，就进入if条件内部。<br>if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;</p>
<p>同样的分析，awoke表示是否唤醒，old&amp;mutexWoken是取第二位，0表示当前协程未被唤醒，old&gt;&gt;mutexWaiterShift表示右移3位，也就是前29位，不为0证明有协程在等待，并且尝试去对比当前m.state与取出时的old状态，尝试去唤醒自己。然后自旋，并且增加自旋次数表示iter，然后重新赋值old。再循环下一次。</p>
<p>（你自己理一理，确实有点绕，仔细想想就想通了就对了。）</p>
<p>以上是使用自旋的情况，就是canSpin的。</p>
<p><img src="http://blog.linkinstars.com/mweb/15586002686717.jpg" alt><br>然后进行判断old&amp;mutexStarving == 0就是第三位为0的情况，还是所说的正常模式。new就马上拿到锁了，new |= mutexLocked，表示或1，就是第一位无论是啥都赋值为1</p>
<p>old&amp;(mutexLocked|mutexStarving)，也就是old &amp; 0101<br>必须当old的1和3两个位置为1的时候才是true，也就是说当前处于饥饿模式，并且锁已经被占用的情况，那么就需要排队去。<br>排队也很精妙，new += 1 &lt;&lt; mutexWaiterShift<br>这边注意是先计算1 &lt;&lt; mutexWaiterShift也就是将new的前29位+1，就是表示有一个协程在等待了。</p>
<p><strong>好了到这里你的位操作应该就习惯的差不多了，之后我就直接说结论，不仔细的帮你01表示了，你已经长大了，要学会自己动手了。</strong></p>
<p>如果当前已经标记为饥饿模式，并且没有锁住，那么设置new为饥饿模式<br>if starving &amp;&amp; old&amp;mutexLocked != 0 {<br>    new |= mutexStarving<br>}</p>
<p>如果唤醒，需要在两种情况下重设标志<br>if awoke {<br>   如果唤醒标志为与awoke不相协调就panic<br>    if new&amp;mutexWoken == 0 {<br>        throw(“sync: inconsistent mutex state”)<br>    }<br>    设置唤醒状态位0,被唤醒<br>    new &amp;^= mutexWoken<br>}</p>
<p><img src="http://blog.linkinstars.com/mweb/15586027772503.jpg" alt><br>如果获取锁成功</p>
<p>old&amp;(mutexLocked|mutexStarving) == 0成立表示已经获取锁，就直接退出CAS</p>
<p>中间这一段我就不多解释了，就是最前面注释说的，满足什么条件转换什么模式，不多说了。然后从队列中，也就是前29位-1。<br>需要注意其中有一个runtime_SemacquireMutex和之前看的的runtime_Semacquire是一个意思，只是多了一个参数。<br><img src="http://blog.linkinstars.com/mweb/15586041456370.jpg" alt><br>这个就是这个方法的注释。可以看到，就是多了个队列去排队。</p>
<p><img src="http://blog.linkinstars.com/mweb/15586032018219.jpg" alt><br>如果获取锁失败，old刷新状态再次循环，继续cas</p>
<h3 id="UnLock释放锁"><a href="#UnLock释放锁" class="headerlink" title="UnLock释放锁"></a>UnLock释放锁</h3><p><img src="http://blog.linkinstars.com/mweb/15586034321669.jpg" alt></p>
<p>Unlock就相对简单一些，竞态分析不看。<br>其实我们自己想也能想到，unlock就是将标识位改回来嘛。<br>然后因为我们已经看过读写锁了，也是同样的道理，如果没有上锁就直接解锁，那肯定报错嘛。</p>
<p><img src="http://blog.linkinstars.com/mweb/15586035033460.jpg" alt><br>然后如果是正常模式，如果没有等待的goroutine或goroutine已经解锁完成的情况就直接返回了。如果有等待的goroutine那就通过信号量去唤醒runtime_Semrelease（注意这里是false），同时操作一下队列-1</p>
<p><img src="http://blog.linkinstars.com/mweb/15586040508623.jpg" alt><br>如果是饥饿模式就直接唤醒（注意这里是true），反正有队列嘛。</p>
<h2 id="互斥锁总结"><a href="#互斥锁总结" class="headerlink" title="互斥锁总结"></a>互斥锁总结</h2><p>其实话说回来，我们其实看起来也简单，没有冲突的情况下，能拿就拿呗，如果出现冲突了就尝试自旋解决（自旋一般都能解决）如果解决不了就通过信号量解决，同时如果正常模式就是我们说的抢占式，非公平，如果是饥饿模式，就是我们说的排队，公平，防止有一些倒霉蛋一直抢不到。</p>
<p>整体总结一下，看完源码我们发现，其实锁的设计并不复杂，主要设计我们要学到cas和处理读写状态的信号量通知，对于那些位操作，能看懂，学可能一时半会学不会，因为很难在一开始就设计的那么巧妙，你也体会到了只用一个变量就维护了整个体系是一种艺术。</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>Mutex</tag>
        <tag>RWMutex</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的slice</title>
    <url>/post/2b62473e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天来说个简单的，也不简单的东西，那就是切片。slice对于golang来说那真的是一个非常常用的东西了，很多地方都会用到它，今天就来说说，slice底层是如何实现的，又有哪些坑是需要提前注意的。</p>
<span id="more"></span>
<h2 id="slice结构"><a href="#slice结构" class="headerlink" title="slice结构"></a>slice结构</h2><p>很多第一次接触golang的同学都会认为，数组和切片是差不多的东西，其实不是的，切片是数组的封装。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面这个就是slice的结构，顺便说一下：slice的源码位置是：<br>go/src/runtime/slice.go</p>
<ul>
<li>其中array是一个指针，指向底层的数组</li>
<li>len代表slice的长度</li>
<li>cap代表slice的容量</li>
</ul>
<p>为什么会有长度和容量这个区分呢，这两个东西是用来干什么的呢？我们往下看。</p>
<h2 id="slice的长度和容量"><a href="#slice的长度和容量" class="headerlink" title="slice的长度和容量"></a>slice的长度和容量</h2><p>我们先来看一个最简单的案例<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d  cap=%d\n&quot;</span>, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli))</span><br><span class="line">sli = <span class="built_in">append</span>(sli, <span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d  cap=%d\n&quot;</span>, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli))</span><br></pre></td></tr></table></figure><br>我们创建一个长度为2的slice然后打印一下它的len和cap。<br>然后添加一个元素，再次打印最后结果为：<br>len=2  cap=2<br>len=3  cap=4</p>
<p>从中我们可以知道len和cap是不同的东西，明显嘛。但是为什么呢？</p>
<p>其实原因很简单，因为数组在创建的时候只能创建固定大小的数组，而当slice在不断往其中添加元素的时候，势必会遇到大小不够的情况，如果每次添加都不够，那么每次都要创建新的数组，那会相当浪费时间和资源，所以当不够的时候索性一次就创建大一些，所以cap其实就代表了整体的一个容量，而len代表当前用到了第几个。</p>
<h2 id="slice的扩容"><a href="#slice的扩容" class="headerlink" title="slice的扩容"></a>slice的扩容</h2><p>刚才提到的整个过程就是扩容的原因，那么slice究竟是如何进行扩容的呢？<br>网上我看见过两个说法：</p>
<ol>
<li>每次2倍</li>
<li>当len&lt;1024的时候每次2倍，当len&gt;1024的时候每次1.25倍</li>
</ol>
<p>我最后得到的结论是其实两个都不完全正确。正确的应该看看源码中是怎么说的。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	.....</span><br><span class="line">	</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">			<span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">			<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">const</span> ptrSize = unsafe.Sizeof((*<span class="keyword">byte</span>)(<span class="literal">nil</span>))</span><br><span class="line">	<span class="keyword">switch</span> et.size &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; _MaxMem</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line">	<span class="keyword">case</span> ptrSize:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * ptrSize</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * ptrSize</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; _MaxMem/ptrSize</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / ptrSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * et.size)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们省略其中部分代码看关键部分，首先说明一下growslice这个方法是扩容的方法，其中的入参<br><code>et *_type, old slice, cap int</code><br>分别是元素的类型，老的slice，<strong>新slice要求的最小容量</strong><br>针对最后这个参数举个简单的例子，当前如果是len=2，cap=2的一个slice添加一个元素，那么这个参数传入的就是3，因为最小需要容量为3。</p>
<p>其实从前半部分来看，第二种说法是正确的，当len&lt;1024确实就是两倍，而当len&gt;1024的时候，每次以原来的25%增加直到满足要求。</p>
<p>但是其实你看后面部分，有一个roundupsize的方法，并且又对newcap进行赋值，所以肯定修改了cap的值，所以其实扩容并没有描述的那么简单，实际中会进行<code>内存对齐</code>，具体什么事内存对齐呢？简单的描述是，内存中肯定不是你想怎么放就怎么放的肯定要满足一个规则，有的地方虽然你只要这么点地方，但是由于美观的要求，会多给你一点，凑个整，保持统一整齐，这就是内存对齐。（是不是花里胡哨的，我尽可能已经白话了，具体还是要看）<br><a href="https://blog.csdn.net/u011957758/article/details/85059117">https://blog.csdn.net/u011957758/article/details/85059117</a><br>总之，我们知道，slice的扩容并不是那么简单的。最后附上一个例子作为验证：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    preCap := <span class="built_in">cap</span>(sli)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">2048</span>; i++ &#123;</span><br><span class="line">        sli = <span class="built_in">append</span>(sli, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">cap</span>(sli) != preCap &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;len=%4d \t cap=%d\n&quot;</span>, <span class="built_in">len</span>(sli)<span class="number">-1</span>, <span class="built_in">cap</span>(sli))</span><br><span class="line">            preCap = <span class="built_in">cap</span>(sli)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len=   2 	 cap=4</span><br><span class="line">len=   4 	 cap=8</span><br><span class="line">len=   8 	 cap=16</span><br><span class="line">len=  16 	 cap=32</span><br><span class="line">len=  32 	 cap=64</span><br><span class="line">len=  64 	 cap=128</span><br><span class="line">len= 128 	 cap=256</span><br><span class="line">len= 256 	 cap=512</span><br><span class="line">len= 512 	 cap=1024</span><br><span class="line">len=1024 	 cap=1280</span><br><span class="line">len=1280 	 cap=1696</span><br><span class="line">len=1696 	 cap=2304</span><br></pre></td></tr></table></figure><br>1280 = 1024 <em> 1.25<br>1696 = 1280 </em> 1.325</p>
<h2 id="slice的操作"><a href="#slice的操作" class="headerlink" title="slice的操作"></a>slice的操作</h2><p>普通的创建添加元素我就不多说了，你肯定知道，你要是不知道就不会来看我的博客了。说一些看起来高端的微操。</p>
<h3 id="创建slice"><a href="#创建slice" class="headerlink" title="创建slice"></a>创建slice</h3><p>make([]int, 10, 32)<br>make的时候可以指定第三个参数也就是初始的cap</p>
<h3 id="slice删除一个元素"><a href="#slice删除一个元素" class="headerlink" title="slice删除一个元素"></a>slice删除一个元素</h3><p>sli = append(sli[:3], sli[4:]…)<br>因为底层是数组，所以删除一个元素看起来会比较麻烦</p>
<h3 id="reslice"><a href="#reslice" class="headerlink" title="reslice"></a>reslice</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        sli = <span class="built_in">append</span>(sli, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(sli)</span><br><span class="line">    sli = sli[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(sli)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sli = sli[1:3:5]<br>reslice的时候也可以指定cap，但是注意的是，这个时候并不是指定的整体容量为5，而是容量为原来slice下标为5的地方。<br>如果原来是[1 2 3 4 5 6 7 8 9 10]<br>按照上面的操作，按照我自己的平常说的就是切两刀，第一刀是切到3，第二刀是切到5<br>slice是[2,3]，但是实际底层还有[4,5] cap应该是4，所以输出应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1 2 3 4 5 6 7 8 9 10]</span><br><span class="line">[2 3]</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h2 id="slice的坑点"><a href="#slice的坑点" class="headerlink" title="slice的坑点"></a>slice的坑点</h2><p>slice的坑其实主要在于使用者需要清楚值传递引用传递的关系。<br><strong>首先在golang中只有值传递，没有引用传递。</strong></p>
<ul>
<li>reslice的时候要注意，如果只是reslice那么后续操作是会对原来的slice造成影响的。</li>
<li>但是如果经过append之后，那么由于扩容的时候回重新分配内存，如果涉及扩容之后，那么就不会对原来的slice造成影响。</li>
<li>如果作为函数的参数传递的是数组，因为是值传递，所以函数内部的修改不会对外部的变量产生影响，但是如果是slice传递，那么因为传递的是指针，所以会修改外部的变量。</li>
<li>同时因为是值传递，形参的重新赋值是不会对外部的变量造成影响的。</li>
</ul>
<p>下面的代码说明了以上可能出现的坑点<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    modifyArray(a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    </span><br><span class="line">    modifySlice(s)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    reslice(s)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    s2 := <span class="built_in">append</span>(s1, <span class="number">1</span>)</span><br><span class="line">    s2[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">    s3 := <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    s3[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(a [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reslice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s = s[:<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，创建slice的时候如果可以的话尽可能初始化好要用容量，以免经常扩容。slice作为参数进行传递的时候，还有slice进行append的时候注意一下，别的应该没有问题。总的来说slice的实现还是比较简单的。</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的strings.go源码解析 - Rabin-Karp了解一下？</title>
    <url>/post/5084c7fa.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>strings包是我们经常在处理字符串的时候要用的，这次我们来看看它其中的一些方法具体是如何实现的。我就找到其中常用的几个方法，然后针对其中比较难的部分还有应用到一些特别算法的部分进行分析。</p>
<span id="more"></span>
<h2 id="ToUpper"><a href="#ToUpper" class="headerlink" title="ToUpper"></a>ToUpper</h2><p>先来看个简单的ToUpper，将所有字符转换成大写。这个如果让我们自己实现也没有什么难度，就是遍历每个字符转换成大写就可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	isASCII, hasLower := <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		c := s[i]</span><br><span class="line">		<span class="keyword">if</span> c &gt;= utf8.RuneSelf &#123;</span><br><span class="line">			isASCII = <span class="literal">false</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		hasLower = hasLower || (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> isASCII &#123; <span class="comment">// optimize for ASCII-only strings.</span></span><br><span class="line">		<span class="keyword">if</span> !hasLower &#123;</span><br><span class="line">			<span class="keyword">return</span> s</span><br><span class="line">		&#125;</span><br><span class="line">		b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(s))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">			c := s[i]</span><br><span class="line">			<span class="keyword">if</span> c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line">				c -= <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">			b[i] = c</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Map(unicode.ToUpper, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，源码中考虑的比较周全，判断了一下字符集的问题。</p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>c -= ‘a’ - ‘A’<br>我们可以看到，这个转换大写的技巧，学习一下。如果转换成小写，只要改成+就可以了。</p>
<h2 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h2><p>然后看一个稍微复杂一些的，Replace，这个函数的目标是替换s中old的字符，替换前n个，如果n为负数则全部替换。作为实现也其实不难，就是找到对应字符替换就可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Replace returns a copy of the string s with the first n</span></span><br><span class="line"><span class="comment">// non-overlapping instances of old replaced by new.</span></span><br><span class="line"><span class="comment">// If old is empty, it matches at the beginning of the string</span></span><br><span class="line"><span class="comment">// and after each UTF-8 sequence, yielding up to k+1 replacements</span></span><br><span class="line"><span class="comment">// for a k-rune string.</span></span><br><span class="line"><span class="comment">// If n &lt; 0, there is no limit on the number of replacements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> old == <span class="built_in">new</span> || n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s <span class="comment">// avoid allocation</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute number of replacements.</span></span><br><span class="line">	<span class="keyword">if</span> m := Count(s, old); m == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s <span class="comment">// avoid allocation</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">0</span> || m &lt; n &#123;</span><br><span class="line">		n = m</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Apply replacements to buffer.</span></span><br><span class="line">	t := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(s)+n*(<span class="built_in">len</span>(<span class="built_in">new</span>)-<span class="built_in">len</span>(old)))</span><br><span class="line">	w := <span class="number">0</span></span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		j := start</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(old) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">				_, wid := utf8.DecodeRuneInString(s[start:])</span><br><span class="line">				j += wid</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j += Index(s[start:], old)</span><br><span class="line">		&#125;</span><br><span class="line">		w += <span class="built_in">copy</span>(t[w:], s[start:j])</span><br><span class="line">		w += <span class="built_in">copy</span>(t[w:], <span class="built_in">new</span>)</span><br><span class="line">		start = j + <span class="built_in">len</span>(old)</span><br><span class="line">	&#125;</span><br><span class="line">	w += <span class="built_in">copy</span>(t[w:], s[start:])</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(t[<span class="number">0</span>:w])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实核心就是下面三句<br>w += copy(t[w:], s[start:j])<br>w += copy(t[w:], new)<br>start = j + len(old)<br>利用一个start去标记从旧字符串的那个位置开始复制，到目标字符处，然后复制需要替换的字符进去就可以了，最后移动start为了下一次准备就可以了。</p>
<h3 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h3><p>t := make([]byte, len(s)+n*(len(new)-len(old)))<br>这个在源码中很是常见，告诉我们一个道理，在创建slice的时候，尽可能的去指定好你需要的长度来避免扩容。</p>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>好了，热身差不多了，来看我们这次的重头戏，index。我们经常需要确定一个字符串是否存在于另一个字符串内，并且要知道它的位置，所以需要index方法。<br>其实说到底就是字符串匹配嘛。</p>
<h3 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h3><p>一般看源码我都习惯先自己想想怎么去实现，这个方法对于我来说很熟悉，在java中其实很暴力，就是两层for搞定，先找到第一个一样的字符，然后匹配剩下的。然后我也知道，字符串匹配在算法中有著名的KMP算法，但是理解难度很大。不知道golang会怎么实现，于是我看到了一个新的算法RabinKarp（我之前不了解）</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexRabinKarp</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// Rabin-Karp search</span></span><br><span class="line">	hashss, pow := hashStr(substr)</span><br><span class="line">	n := <span class="built_in">len</span>(substr)</span><br><span class="line">	<span class="keyword">var</span> h <span class="keyword">uint32</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		h = h*primeRK + <span class="keyword">uint32</span>(s[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == hashss &amp;&amp; s[:n] == substr &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := n; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">		h *= primeRK</span><br><span class="line">		h += <span class="keyword">uint32</span>(s[i])</span><br><span class="line">		h -= pow * <span class="keyword">uint32</span>(s[i-n])</span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">if</span> h == hashss &amp;&amp; s[i-n:i] == substr &#123;</span><br><span class="line">			<span class="keyword">return</span> i - n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你先自己尝试看看是否能看出什么门道？</p>
<h3 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h3><p>是不是乍看之下这个方法很复杂，各种操作眼花缭乱，如果你是第一次看源码可能是这样的，看多了你应该有和我一样的直觉和经验（反正我是有感觉）<br><strong>我看源码的第二个步骤就是大致看一眼，然后在不看任何文章解析的情况下猜测它的实现。</strong><br>在我看完上面之后留个我三个重点</p>
<ul>
<li><code>hashss, pow := hashStr(substr)</code></li>
<li><code>h += uint32(s[i])</code> <code>h -= pow * uint32(s[i-n])</code></li>
<li><code>if h == hashss &amp;&amp; s[i-n:i] == substr &#123;</code></li>
</ul>
<ol>
<li>它获取了对应的hash值，这个算法和hash有关</li>
<li>它对哈希值进行了增减操作</li>
<li>它比较哈希值和字符串从而确定位置</li>
</ol>
<p>到这里，我已经有了一个大概的思路，这个算法应该是通过哈希值快速确定子串是否可能存在，在哈希值相同的情况下再去比较真实的字符是否一致，同时在计算哈希值的时候采用特殊的机制来实现了增加就可以完成哈希的改变。其实如果你有相同的想法，恭喜你，已经八九不离十了。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们举个实际的例子来说明上面的事情<br>原本的字符串为：”ABCDE”，子串为”BCD”<br>首先计算出”BCD”的hash为100（举个例子）<br>然后循环原本的字符串<br>取出”ABC”计算hash为200 != 100所以一定不是<br>取出字符D<br>原来的hash加D减去A计算hash为100 == 100（这里注意，不是重新计算，而是在原有的基础上进行的计算）<br>最后还是要比较一遍是否正确，因为hash一致不一定原值一致。</p>
<p><em>假设待匹配字符串的长度为M，目标字符串的长度为N，那么一共比较N-M+1就可以了</em></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>那么其实你应该注意到了，最神奇的就是这个hash值，为什么可以这样操作，如果是md5这种必须重新计算，是不可能完成这样的操作的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// primeRK is the prime base used in Rabin-Karp algorithm.</span></span><br><span class="line"><span class="keyword">const</span> primeRK = <span class="number">16777619</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashStr returns the hash and the appropriate multiplicative</span></span><br><span class="line"><span class="comment">// factor for use in Rabin-Karp algorithm.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashStr</span><span class="params">(sep <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">uint32</span>, <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	hash := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sep); i++ &#123;</span><br><span class="line">		hash = hash*primeRK + <span class="keyword">uint32</span>(sep[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> pow, sq <span class="keyword">uint32</span> = <span class="number">1</span>, primeRK</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(sep); i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">			pow *= sq</span><br><span class="line">		&#125;</span><br><span class="line">		sq *= sq</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hash, pow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是hash算法，其实它每次完成的就是 *primeRK 加上新的字符，那么pow是什么呢？加减究竟是如何完成的呢？我举个例子你就明白了。</p>
<p>还是刚才的ABCDE和BCD，我们用q表示常数primeRK<br>那么BCD的hash计算出来应该是B <em> q^2 + C </em> q + D<br>而ABC的hash应该是A <em> q^2 + B </em> q + C<br>那当D来的时候如何操作的呢？回看一下indexRabinKarp就明白了。<br>[A <em> q^2 + B </em> q + C] <em> q + D - A </em> pow<br>= A <em> q^3 - A </em> pow + B <em> q^2 + C </em> q + D<br>明白了吧，这个pow其实就是计算hash值时的最高指数，通过每次减去常数的最高指数项就能完成之前的操作。</p>
<p>聪明。不由得佩服能想出这样算法的人~</p>
<h2 id="其他一些方法"><a href="#其他一些方法" class="headerlink" title="其他一些方法"></a>其他一些方法</h2><p>看完最复杂的index实现，再说说几个由它引申出来的方法。</p>
<h3 id="genSplit"><a href="#genSplit" class="headerlink" title="genSplit"></a>genSplit</h3><p>其实就是分组字符串，通过某些子串去分割成一个个部分，其实实现就是每次Index找到位置然后进行存储到新的地方就可以了。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">	m := Index(s, sep)</span><br><span class="line">	<span class="keyword">if</span> m &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	a[i] = s[:m+sepSave]</span><br><span class="line">	s = s[m+<span class="built_in">len</span>(sep):]</span><br><span class="line">	i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="countGeneric"><a href="#countGeneric" class="headerlink" title="countGeneric"></a>countGeneric</h3><p>计数，统计字符串中子串出现的数目，也是通过index完成，统计一下而已<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	i := Index(s, substr)</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	n++</span><br><span class="line">	s = s[i+<span class="built_in">len</span>(substr):]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实很多源码中的实现不复杂，多看看，不仅能熟练使用api还能学到一些骚操作，何乐而不为呢？不得不佩服一些牛逼的算法实现，真的厉害~</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>strings</tag>
      </tags>
  </entry>
  <entry>
    <title>golang中神奇的sync.Pool</title>
    <url>/post/71525482.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 golang 中有一个池，它特别神奇，你只要和它有个约定，你要什么它就给什么，你用完了还可以还回去，但是下次拿的时候呢，确不一定是你上次存的那个，这个池就是 sync.Pool</p>
<p>说实话第一次看到这个东西的时候，真的想不到这个东西有啥用啊，为什么要有这个东西呢？等我看完之后，嗯，还有有点用的；等到有一次优化经历的时候，嗯，这个有点意思了。今天我们就来看看这个神奇的 sync.Pool</p>
<span id="more"></span>
<h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><p>首先我们来看看这个 sync.Pool 是如何使用的，其实非常的简单。<br>它一共只有三个方法我们需要知道的：New、Put、Get</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test str&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := strPool.Get()</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">    strPool.Put(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>New</code>去定义你这个池子里面放的究竟是什么东西，在这个池子里面你只能放一种类型的东西。比如在上面的例子中我就在池子里面放了字符串。</li>
<li>我们随时可以通过<code>Get</code>方法从池子里面获取我们之前在New里面定义类型的数据。</li>
<li>当我们用完了之后可以通过<code>Put</code>方法放回去，或者放别的同类型的数据进去。</li>
</ul>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>那么这个池子的目的是什么呢？其实一句话就可以说明白，就是为了复用已经使用过的对象，来达到优化内存使用和回收的目的。说白了，一开始这个池子会初始化一些对象供你使用，如果不够了呢，自己会通过new产生一些，当你放回去了之后这些对象会被别人进行复用，当对象特别大并且使用非常频繁的时候可以大大的减少对象的创建和回收的时间。</p>
<h2 id="来看看doc"><a href="#来看看doc" class="headerlink" title="来看看doc"></a>来看看doc</h2><p>其实官方文档里面给出了一些小细节让我们一起来看看</p>
<ul>
<li><a href="https://golang.google.cn/pkg/sync/#Pool">https://golang.google.cn/pkg/sync/#Pool</a></li>
</ul>
<p>A Pool is a set of <strong>temporary objects</strong> that may be individually saved and retrieved.</p>
<p>Any item stored in the Pool may be <strong>removed automatically</strong> at any time without notification. <strong>If the Pool holds the only reference when this happens, the item might be deallocated.</strong></p>
<p><strong>A Pool is safe for use by multiple goroutines simultaneously.</strong></p>
<p>Pool’s purpose is to cache allocated but unused items for later reuse, <strong>relieving pressure on the garbage collector</strong>. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.</p>
<p>An appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. Pool provides a way to amortize allocation overhead across many clients.</p>
<p>An example of good use of a Pool is in the fmt package, which maintains a dynamically-sized store of temporary output buffers. <strong>The store scales under load (when many goroutines are actively printing) and shrinks when quiescent.</strong></p>
<p>On the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list.</p>
<p><strong>A Pool must not be copied after first use.</strong></p>
<p>注意其中加粗的部分，我列一下其中的点，建议还是尝试去阅读doc里面的说明。</p>
<ul>
<li>临时对象</li>
<li>自动移除</li>
<li>当这个对象的引用只有sync.Pool持有时，这个对象内存会被释放</li>
<li>多线程安全</li>
<li>目的就是缓存并重用对象，减少GC的压力</li>
<li>自动扩容、缩容</li>
<li>不要去拷贝pool，也就是说最好单例</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>下面我们从源码层面来看看这个 sync.Pool；可能需要你有GPM模型和GC的相关知识。<br>使用golang版本： go version go1.13</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span></span><br><span class="line">	localSize <span class="keyword">uintptr</span>        <span class="comment">// size of the local array</span></span><br><span class="line"></span><br><span class="line">	victim     unsafe.Pointer <span class="comment">// local from previous cycle</span></span><br><span class="line">	victimSize <span class="keyword">uintptr</span>        <span class="comment">// size of victims array</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// New optionally specifies a function to generate</span></span><br><span class="line">	<span class="comment">// a value when Get would otherwise return nil.</span></span><br><span class="line">	<span class="comment">// It may not be changed concurrently with calls to Get.</span></span><br><span class="line">	New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Local per-P Pool appendix.</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">	private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.</span></span><br><span class="line">	shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">	poolLocalInternal</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prevents false sharing on widespread platforms with</span></span><br><span class="line">	<span class="comment">// 128 mod (cache line size) = 0 .</span></span><br><span class="line">	pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到其实结构并不复杂，但是如果自己看的话有点懵。注意几个细节就ok。</p>
<ul>
<li>local这里面真正的是[P]poolLocal其中P就是GPM模型中的P，有多少个P数组就有多大，也就是每个P维护了一个本地的poolLocal。</li>
<li>poolLocal里面维护了一个private一个shared，看名字其实就很明显了，private是给自己用的，而shared的是一个队列，可以给别人用的。注释写的也很清楚，自己可以从队列的头部存然后从头部取，而别的P可以从尾部取。</li>
<li>victim这个从字面上面也可以知道，幸存者嘛，当进行gc的stw时候，会将local中的对象移到victim中去，也就是说幸存了一次gc，</li>
</ul>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	......</span><br><span class="line">	l, pid := p.pin()</span><br><span class="line">	x := l.private</span><br><span class="line">	l.private = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Try to pop the head of the local shard. We prefer</span></span><br><span class="line">		<span class="comment">// the head over the tail for temporal locality of</span></span><br><span class="line">		<span class="comment">// reuse.</span></span><br><span class="line">		x, _ = l.shared.popHead()</span><br><span class="line">		<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">			x = p.getSlow(pid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">		x = p.New()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// See the comment in pin regarding ordering of the loads.</span></span><br><span class="line">	size := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">	locals := p.local                        <span class="comment">// load-consume</span></span><br><span class="line">	<span class="comment">// Try to steal one element from other procs.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">		l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try the victim cache. We do this after attempting to steal</span></span><br><span class="line">	<span class="comment">// from all primary caches because we want objects in the</span></span><br><span class="line">	<span class="comment">// victim cache to age out if at all possible.</span></span><br><span class="line">	size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	locals = p.victim</span><br><span class="line">	l := indexLocal(locals, pid)</span><br><span class="line">	<span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">		l.private = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">		l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the victim cache as empty for future gets don&#x27;t bother</span></span><br><span class="line">	<span class="comment">// with it.</span></span><br><span class="line">	atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我去掉了其中一些竞态分析的代码，Get的逻辑其实非常清晰。</p>
<ul>
<li>如果 private 不是空的，那就直接拿来用</li>
<li>如果 private 是空的，那就先去本地的shared队列里面从头 pop 一个</li>
<li>如果本地的 shared 也没有了，那 getSlow 去拿，其实就是去别的P的 shared 里面偷，偷不到回去 victim 幸存者里面找</li>
<li>如果最后都没有，那就只能调用 New 方法创建一个了</li>
</ul>
<p>我随手画了一下，可能不是特别准确，意思到位了</p>
<p><img src="http://blog.linkinstars.com/mweb/15732709504973.jpg" alt="-w566"></p>
<h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Put adds x to the pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	l, _ := p.pin()</span><br><span class="line">	<span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.private = x</span><br><span class="line">		x = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">		l.shared.pushHead(x)</span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完Get其实Put就很简单了</p>
<ul>
<li>如果 private 没有，就放在 private</li>
<li>如果 private 有了，那么就放到 shared 队列的头部</li>
</ul>
<h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>让我们实际写个测试的案例来测测具体使用时会有什么样的变化</p>
<h3 id="Put之后马上Get"><a href="#Put之后马上Get" class="headerlink" title="Put之后马上Get"></a>Put之后马上Get</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := pool.Get().(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(t)</span><br><span class="line"></span><br><span class="line">    pool.Put(<span class="string">&quot;321&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    t2 := pool.Get().(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>123<br>321</p>
<h3 id="Put之后GC后Get"><a href="#Put之后GC后Get" class="headerlink" title="Put之后GC后Get"></a>Put之后GC后Get</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := pool.Get().(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(t)</span><br><span class="line"></span><br><span class="line">    pool.Put(<span class="string">&quot;321&quot;</span>)</span><br><span class="line">    pool.Put(<span class="string">&quot;321&quot;</span>)</span><br><span class="line">    pool.Put(<span class="string">&quot;321&quot;</span>)</span><br><span class="line">    pool.Put(<span class="string">&quot;321&quot;</span>)</span><br><span class="line"></span><br><span class="line">    runtime.GC()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    t2 := pool.Get().(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(t2)</span><br><span class="line"></span><br><span class="line">    runtime.GC()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    t2 = pool.Get().(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>123<br>321<br>123</p>
<p>你知道为什么吗？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次总结来点不一样的，提几个问题吧。</p>
<ol>
<li>什么情况下适合使用sync.Pool呢？</li>
<li>sync.Pool的对象什么时候会被回收呢？</li>
<li>sync.Pool是如何实现线程安全的？<br>如果你能回答上面的问题，证明你对它已经足够了解了，那么就可以尝试在具体的情况下使用它来玩玩了。试试吧~</li>
</ol>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>sync.Pool</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 之 WaitGroup 源码解析</title>
    <url>/post/a0cda732.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如果我们有一个大的任务要做，我们会尝试将这个任务分解，分解完成之后并发交由 goroutine 去做，并且我需要当全部的任务完成之后再进行下面的步骤，在 sync 包下，就有这样一个东西适合上述情况，WaitGroup，今天我们来看看具体它是怎么实现的。</p>
<span id="more"></span>
<p>PS：在下面我统一用 wg 来简称 WaitGroup</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>它的使用非常简单，如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add (<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(job <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done ()</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            fmt.Printf (<span class="string">&quot;job % d done\n&quot;</span>, job)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait ()</span><br><span class="line">    fmt.Println (<span class="string">&quot;all done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">job <span class="number">9</span> done</span><br><span class="line">job <span class="number">1</span> done</span><br><span class="line">job <span class="number">0</span> done</span><br><span class="line">job <span class="number">8</span> done</span><br><span class="line">job <span class="number">7</span> done</span><br><span class="line">job <span class="number">3</span> done</span><br><span class="line">job <span class="number">6</span> done</span><br><span class="line">job <span class="number">2</span> done</span><br><span class="line">job <span class="number">4</span> done</span><br><span class="line">job <span class="number">5</span> done</span><br><span class="line">all done</span><br></pre></td></tr></table></figure>
<p>我们可以看到，使用非常简单，每次有一个任务就使用 Add 方法加一个，每次做完任务就使用 Done 方法告诉它已经完成了，而 Wait 就是等着所有的任务完成。</p>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><p>在看 wg 的实现之前，首先来问几个问题，来考考自己。</p>
<ol>
<li>Wait 方法能否被多次调用，比如再开一个 goroutine 去 wait</li>
<li>Wait 方法调用后是否还能再继续调用 Add 添加任务</li>
<li>每次只能 Done 一个任务，能否一次性 Done 多个任务呢</li>
<li>wg 能否被拷贝或作为参数传递</li>
<li>如果让你自己实现一个，你会如何实现</li>
</ol>
<p>前几个问题，如果你都能很清楚的回答，那么你对 wg 的了解可以说已经非常熟悉了。首选我来说一下对于最后的一个问题的回答，因为在看源码之前我都会想想如果是我，我会如何去实现，那么我想的也很简单。</p>
<ul>
<li>使用一个变量进行计数</li>
<li>每次任务数量变更时使用 atom 原子操作 + 1 或者 - 1</li>
<li>-1 时判断任务数量是否已经为 0</li>
<li>如果为 0 向一个 channel 里面发送消息</li>
<li>所有 wait 的地方监听 channel 的消息，收到消息则证明任务全部完成</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line">	<span class="comment">//compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line">	<span class="comment">//the aligned 8 bytes in them as state, and the other 4 as storage</span></span><br><span class="line">	<span class="comment">//for the sema.</span></span><br><span class="line">	state1 [<span class="number">3</span>] <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构非常简单，就只有两个熟悉，一个 <code>noCopy</code> 还有一个 <code>state1</code>（我也很好奇为什么要用 1 来结尾命名，大佬的想法总是很奇妙）</p>
<p>noCopy： sync 包下的一个特殊标记吧，vet 检查，如果有拷贝的变量则会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup &#123;&#125;</span><br><span class="line">    w := wg</span><br><span class="line">    fmt.Println (w, wg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你 run 肯定没问题的，但是如果你使用 go vet 做个检查就有警告了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  <span class="keyword">go</span> vet main.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">10</span>: assignment copies lock value to w: sync.WaitGroup contains sync.noCopy</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">17</span>: call of fmt.Println copies lock value: sync.WaitGroup contains sync.noCopy</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">20</span>: call of fmt.Println copies lock value: sync.WaitGroup contains sync.noCopy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>state1：是用来存放任务计数器和等待者计数器的（我一看到这个结构就明白肯定后面又是位操作这样的高端操作了）</p>
<table>
<thead>
<tr>
<th></th>
<th>state [0]</th>
<th>state [1]</th>
<th>state [2]</th>
</tr>
</thead>
<tbody>
<tr>
<td>64 位</td>
<td>waiter</td>
<td>counter</td>
<td>sema</td>
</tr>
<tr>
<td>32 位</td>
<td>sema</td>
<td>waiter</td>
<td>counter</td>
</tr>
</tbody>
</table>
<p>其中 waiter 是等待者计数，counter 是任务计数，sema 是信号量</p>
<p>奇怪的是在 64 位还 32 位操作系统上是不一样的，具体原因以及对于它操作请继续看下去</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state returns pointers to the state and sema fields stored within wg.state1.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span> <span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span> (unsafe.Pointer (&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer (&amp;wg.state1)), &amp;wg.state1 [<span class="number">2</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer (&amp;wg.state1 [<span class="number">1</span>])), &amp;wg.state1 [<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是一个内部方法，就是将 state1 中存储的状态取出来，返回值 statep 就是计数器的状态，semap 是信号量</p>
<h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add (<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没想到吧～居然 Done 就是调用 Add 并传递一个 - 1</p>
<p>所以其实我们完全可以再外部调用 Add 传递一个 - 3 一次性结束 3 个任务</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span> <span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 首先获取状态值</span></span><br><span class="line">	statep, semap := wg.state ()</span><br><span class="line">	<span class="comment">// 对于 statep 中 counter + delta</span></span><br><span class="line">	state := atomic.AddUint64 (statep, <span class="keyword">uint64</span> (delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">	<span class="comment">// 获取任务计数器的值</span></span><br><span class="line">	v := <span class="keyword">int32</span> (state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">	<span class="comment">// 获取等待者计数器的值</span></span><br><span class="line">	w := <span class="keyword">uint32</span> (state)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 任务计数器不能为负数</span></span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span> (<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 已经有人在等待，但是还在添加任务</span></span><br><span class="line">	<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span> (delta) &#123;</span><br><span class="line">		<span class="built_in">panic</span> (<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没有等待者或者任务还有没做完的</span></span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 有等待者，但是在这个过程中数据还在变动</span></span><br><span class="line">	<span class="keyword">if</span> *statep != state &#123;</span><br><span class="line">		<span class="built_in">panic</span> (<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reset waiters count to 0.</span></span><br><span class="line">	<span class="comment">// 重置状态，并用发出等同于等待者数量的信号量，告诉所有等待者任务已经完成</span></span><br><span class="line">	*statep = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">		runtime_Semrelease (semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个要点我们其实已经看到了：</p>
<ul>
<li>Wait 的 <strong> 过程中 </strong> 是不能 Add 的，不然就会 panic，要注意</li>
<li>虽然我们可以借助 Add 一个负数来一次性结束多个任务，但是如果任务数量控制的不好，变成负数也会 panic，Done 次数多了也一样</li>
<li>wg 是通过信号量来通知的，当然可以有很多人在等，wg 它都会一一通知到位的</li>
</ul>
<h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先获取状态</span></span><br><span class="line">	statep, semap := wg.state ()</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 这里注意要用 atomic 的 Load 来保证一下写操作已经完成</span></span><br><span class="line">		state := atomic.LoadUint64 (statep)</span><br><span class="line">		<span class="comment">// 同样的，这里是任务计数</span></span><br><span class="line">		v := <span class="keyword">int32</span> (state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">		<span class="comment">// 这里是等待者计数</span></span><br><span class="line">		w := <span class="keyword">uint32</span> (state)</span><br><span class="line">		<span class="comment">// 如果没有任务，那么直接结束，不用等待了</span></span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用 cas 操作，如果不相等，证明中间已经被其他人修改了状态，重新走 for 循环</span></span><br><span class="line">		<span class="comment">// 注意这里 if 进去之后等待者的数量就 +1 了</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64 (statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 等待信号量</span></span><br><span class="line">			runtime_Semacquire (semap)</span><br><span class="line">			<span class="comment">// 如果信号量来了，但是状态还不是 0，则证明 wait 之后还是在人在 add，证明有人想充分利用 wg 但是时机不对</span></span><br><span class="line">			<span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span> (<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 wait 虽然简单，也有要点</p>
<ul>
<li>通过 load 和 cas 操作 + 循环来避免了锁，其实这个操作可以学一下</li>
<li>其实这里也说明明白了，wg 可以重用，但是你必须等到 wait 全部完成之后再说</li>
</ul>
<h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add (<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(job <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            doJob (job, wg)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait ()</span><br><span class="line">    fmt.Println (<span class="string">&quot;all done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doJob</span> <span class="params">(job <span class="keyword">int</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf (<span class="string">&quot;job % d done\n&quot;</span>, job)</span><br><span class="line">    wg.Done ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有问题吗？问题在哪呢？</p>
<p>其实很简单，wg 作为一个参数传递的时候，wg 还是一个普通的结构体，我们在函数中操作的时候还是操作的一个拷贝的变量而已，对于原来的 wg 是不会改变的，所以这里需要传递指针才是正确的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    wg := &amp;sync.WaitGroup &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            wg.Add (<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(job <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">                doJob (job, wg)</span><br><span class="line">            &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait ()</span><br><span class="line">    fmt.Println (<span class="string">&quot;all done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doJob</span> <span class="params">(job <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf (<span class="string">&quot;job % d done\n&quot;</span>, job)</span><br><span class="line">    wg.Done ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是其实并不推荐这样去传递 wg，因为这样很容易出现问题，一个不好就出问题了，个人还是建议直接在使用 goroutine 之后马上接一个 defer wg.Done () 来的更加靠谱一些</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回过头来看看，之前的问题也都有了答案：</p>
<ol>
<li>Wait 可以被调用多次，并且每个都会收到完成的通知</li>
<li>Wait 之后，如果再 Wait 的过程中不能在 Add，否则会 panic，但是 Wait 结束之后可以继续使用 Add 进行重用</li>
<li>可以使用 Add 传递负数的方式一次性结束多个任务，但是需要保证任务计数器非负，否则会 panic</li>
<li>wg作为参数传递的时候需要注意传递指针，或者尽量避免传递</li>
<li>官方利用位操作节约了空间，存在在同一个地方；利用信号量来实现任务结束的通知….</li>
</ol>
<p>总的来说 wg 的实现还是非常简单的，需要注意的就是几个使用上的点不要出现意外即可。</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>sync.WaitGroup</tag>
      </tags>
  </entry>
  <entry>
    <title>你可能不知道的mysql</title>
    <url>/post/e62eb67f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>以下是针对mysql的知识点整理，用于复习，主要以罗列为主，详细具体讲解可以参考书《高性能mysql》，你可以过一遍看看有无知识点遗漏。<br><span id="more"></span></p>
<h2 id="执行sql过程"><a href="#执行sql过程" class="headerlink" title="执行sql过程"></a>执行sql过程</h2><p>客户端 -&gt; 连接器 -&gt; 分析器 -&gt; 优化器 -&gt; 执行器 -&gt; 存储引擎<br>连接器：连接上数据库，长连接<br>分析器：分析语法（包含解析器和预处理器，解析器生成解析树，预处理器判断字段存在歧义）<br>优化器：选择正确的索引进行优化执行<br>执行器：执行具体sql返回结果</p>
<h2 id="mysql的两个重要日志"><a href="#mysql的两个重要日志" class="headerlink" title="mysql的两个重要日志"></a>mysql的两个重要日志</h2><p>redo-log（重做日志）：固定大小的循环缓存，InnoDB使用，即使重启，只要记录到了redo-log就不会丢失。防止mysql意外。<br>bin-log：归档日志，所有sql都会记录，并且采用追加，满了之后新开，有两种方式，一种是记录sql语句（statement），一种是row，记录出现的事件。<br>如果只记录sql语句会导致主从同步上面存在问题，从库执行相同的sql得到效果不同，所以还有一种混合的方式，mysql会自动判断当前语句是否会造成主从不同步的情况，如果会，那么就使用row记录如果不会就是用sql记录，因为row记录会增加存储空间。</p>
<p>undo-log（回滚日志）：记录修改的状态和回滚信息，利用这个实现mvcc（多版本并发控制），系统会自动判断回滚日志什么时候会被删除。用于回滚操作。</p>
<p>两个日志记录的顺序：<br>更新的行如果不在内存，从磁盘取出 -&gt; 修改内存中的值 -&gt; 写入redo-log状态为prepare -&gt; 写binlog -&gt; 提交事务redo-log进行commit</p>
<h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p>读未提交：能读到别人未提交事务修改的数据<br>读已提交：能读到别人提交事务之后修改的数据<br>可重复读：在读已提交的基础上，当前事务读取第一次和第二次的结果相同<br>串行化：读会加读锁，写会加写锁，读写冲突串行化执行</p>
<p>隔离级别通过视图实现，读未提交没有视图，读已提交每次sql执行创建一个视图，可重复读在开始之前创建一个视图，串行化直接加锁没有视图。</p>
<p>事务与隔离级别：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”；所以即使是可以重复读的隔离级别，更新数据时还是会进行当前读来保证别人已经提交的事务不被覆盖。</p>
<p>幻读：幻读是出现在范围查询，第二次查询之前，由于其他事务新增记录导致查询两次不同，区别于可重复读。InnoDB引入间隙锁来解决，锁住范围内的各个间隙。但是要注意间隙锁也容易导致死锁，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作，间隙锁之间都不存在冲突关系。</p>
<h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>常见的索引类型有：哈希、数组、搜索树<br>哈希用于等值查询，不适合范围查询；数组查询很快，但是更新效率低<br>数据库使用N叉树降低树的层级，innodb使用的是B+树</p>
<p>在InnoDb中，主键索引又叫聚簇索引，非主键索引又叫二级索引<br>主键索引可以拿到全部数据，而非主键索引只能拿到主键id通过回表查询来拿到数据<br>如果一个数据页满了需要新增一个数据页也叫做页分裂性能下降并且空间利用率下降，所以使用自增主键更加合理</p>
<p>覆盖索引：当我们查询的时候只需要查询出id字段的时候就可以直接使用单个索引来完成，不需要进行回表操作，减少搜索次数。</p>
<p>最左前缀原则：当我们进行一个字段查询的时候，如果这个字段没有单独做索引，但是有别的联合索引包含这个字段，且刚好以这个字段开头，那么也可以进行匹配。所以在建立联合索引的时候需要考虑字段排序，这样就可以减少维护的索引个数。</p>
<p>索引下堆优化：mysql5.6之后，当查询的条件中包含索引中的字段，会优先对索引中的字段做判断，而非直接回表查询。</p>
<p>重建索引：当删除很多数据之后，由于索引没有被删除，所以会导致数据页有空洞，而且占用资源，这个时候可以考虑再低谷期重建索引<code>alter table T engine=InnoDB</code>。</p>
<p>唯一索引和普通索引：插入上面性能几乎没有区别，更新上面普通索引可以使用change buffer所以更加快一些，而唯一索引需要判断所以慢一些。选择还是需要根据业务出发去考虑。</p>
<p>合理设置前缀索引：索引可以设置只用前面几位，可以减少索引占用空间，同时设置时应保证合适的区分度。</p>
<h2 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h2><p>全局锁：用于备份的时候，锁住整个库，防止备份过程中数据修改导致问题。<br>表锁：有两种，一种是表锁，在引擎不支持行锁的时候使用，锁住之后不能进行增删改查；另一种是元数据锁，访问表的时候自动加上，读写锁。默认就是。</p>
<p>行锁：在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。<strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p>
<p>间隙锁：专门用来解决幻读的问题，在可重复读的情况下才会生效。<br>（间隙锁和行锁合称next-key lock）<br>next-key lock锁的规则：<br>加锁范围是前开后闭区间；查找过程中访问到的对象才会加锁；当遇到索引等值查询，如果是唯一索引，那么因为只可能有一行记录那么就退化为行锁；如果索引等值查询，发现没有满足情况，就只能退化为间隙锁去锁间隙；如果是范围查询那么就会查询到第一个不满足条件的情况为止。</p>
<p>死锁：当对于同一个表的多行数据进行修改的时候，容易出现死锁，相互等待。死锁可以通过死锁检测或者是超时回滚来解决，但是对于性能损失巨大，最好通过业务或者客户端优化处理。</p>
<p>count(*)：针对这个有特殊优化，但innodb没有直接记录行数，还是需要遍历计数，实在不行可以业务实现计数。</p>
<p>MyISAM不支持事务<br>MyISAM不支持行锁<br>在InnoDB中，每个数据页的大小默认是16KB。</p>
<p>order by的实现：在不用索引的时候，如果内存够用，那么会将查询全部查出来然后放到内存中快排，如果内部不够，使用磁盘进行排序后归并。更好的情况是去使用索引，因为存储的时候默认就是有顺序的，这样能减少排序从而加速。</p>
<h2 id="无法使用索引的情况"><a href="#无法使用索引的情况" class="headerlink" title="无法使用索引的情况"></a>无法使用索引的情况</h2><ol>
<li>如果对字段做了函数计算，就用不上索引了</li>
<li>如果触发隐式转换也用不上索引了</li>
<li>字符集不同触发转换也无法使用索引</li>
</ol>
<h2 id="查看相关命令"><a href="#查看相关命令" class="headerlink" title="查看相关命令"></a>查看相关命令</h2><p>show processlist命令查看Waiting for table metadata lock<br>查看各个线程锁的情况</p>
<p>select <em> from information_schema.innodb_trx\G<br>select </em> from t sys.innodb_lock_waits where locked_table=<code>&#39;test&#39;.&#39;t&#39;</code>\G<br>可以查看具体是被那个线程锁住了</p>
<h2 id="一些小的"><a href="#一些小的" class="headerlink" title="一些小的"></a>一些小的</h2><p>for update和lock in share mode<br>lock in share mode是意向共享锁，其他session可以读取相关记录，也可以继续加IS，但是无法修改<br>for update是意向排他锁，其他session无法进行select…for update操作，也就是排除别的想要加排它锁的情况。<br>两者都不会阻塞别的session进行的快照读。<br>用法，lock in share mode用于两个表之间要保证一致性，a表的操作时要保证b表中的某条数据不能被修改；<br>for update用于同一个表中的数据，a事务操作时不允许b事务进行修改。</p>
<p>在删除数据的时候尽量加limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<p>不要一次性地用delete语句删除太多数据。其实，这就是一个典型的大事务场景。</p>
<h2 id="sql慢的原因"><a href="#sql慢的原因" class="headerlink" title="sql慢的原因"></a>sql慢的原因</h2><p>索引设计不合理<br>sql设计不合理<br>mysql索引自动选择错误</p>
<h2 id="运维上的一些"><a href="#运维上的一些" class="headerlink" title="运维上的一些"></a>运维上的一些</h2><p>双主的时候，通过binlog上面的serverid记录来判断是否与自己相同，如果不同才会更新，避免循环复制</p>
<p>主备延迟的来源：<br>备库机器性能差，备库查询压力大，大事务一直正在处理。<br>mysql5.7采用并行复制的策略减少主备延迟</p>
<p>因为主备同步会存在延迟，所以在开发的时候一定要注意读取从库的时候不一定是最新的值。<br>1、读取的时候读主库，最常用<br>2、读取之前进行睡眠一段时间保证同步<br>保证seconds_behind_master一定为0的时候才执行查询<br>或者可以使用semi-sync replication，当从库收到binlog之后会返回主库一个ack，主库只有收到这个ack之后才认为事务完成</p>
<p><strong>如何进行主备切换？？？？过程是怎么样的？</strong></p>
<p>对比位点<br>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；<br>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。<br>如果位点相同可以认为已经同步</p>
<p>对比GTID集合确保主备无延迟：</p>
<p>如何判断一个数据库正常<br>1、使用select进行查询，查询一个创建在mysql库中的表；容易实现，但是因为只是查询所以会漏掉一些错误条件，比如当磁盘满了，binlog写不进去了，但是可以读不能写。那么可以使用update来进行优化一下下。尝试去修改一个值来实现。</p>
<p>当出现误删除（delete）的时候，这个时候要指望binlog存放了数据，然后逆执行去恢复（Flashback），但是需要确保binlog_format=row 和 binlog_row_image=FULL。</p>
<p>预防才是关键：<br>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</p>
<p>如果是直接执行的drop的话，binlog也无能为力，因为log中没有存放删除的数据，这个时候只能依赖备份了，利用最近一次备份的数据进行恢复，然后进行binlog重放。</p>
<p>故意延迟复制的从库，弄一个故意延迟一个小时复制的从库，这样无论什么时候都能快速拿到一个小时前的数据。</p>
<p>账号权限很关键，没有权限去执行对应操作的sql就可以了</p>
<p>kill query +线程id，可以终止一个线程正在执行的sql语句</p>
<p>mysql采用的是边查边给的，查到就会发给客户端，而不是全部查到全部结果之后再发</p>
<p>使用join的时候一定要注意，使用是有条件的：<br>当使用join的时候被驱动表能使用索引，那么是可以的，同时也需要注意，使用小表作为驱动表，这样能让扫描行数更加少一些，大表去走索引去。<br>当使用join的时候如果不能走索引的情况，那么mysql会使用BNL算法，将驱动表的数据和被驱动表的数据加载到内存中，并且使用join_buffer来进行合并操作，但是这样扫描行会变的非常的巨大，所以这个时候如果表的数据太多就不适合使用。</p>
<h2 id="mysql面试问题"><a href="#mysql面试问题" class="headerlink" title="mysql面试问题"></a>mysql面试问题</h2><h4 id="主从复制的原理与流程？"><a href="#主从复制的原理与流程？" class="headerlink" title="主从复制的原理与流程？"></a>主从复制的原理与流程？</h4><ol>
<li>主库将修改写入本地binlog中</li>
<li>从库将拉取主库binlog写入本地relay log中</li>
<li>从库读取relay log并执行（这里是单线程执行，不能并发，所以慢）</li>
</ol>
<h4 id="innodb和myisam与区别"><a href="#innodb和myisam与区别" class="headerlink" title="innodb和myisam与区别"></a>innodb和myisam与区别</h4><p>innodb支持事务，myisam不支持<br>innodb支持行锁，myisam支持表锁<br>innodb支持mvcc，myisam不支持<br>innodb支持外键，myisam不支持<br>myisam不支持崩溃后安全恢复</p>
<h4 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h4><ol>
<li>插入缓冲insert buffer，change buffer；将一系列的操作缓存，然后一次性写到磁盘，目的还是为了减少随机IO带来性能损耗。</li>
<li>二次写：从innodb buffer pool中flush写文件之前存doublewrite buffer写到物理磁盘上共享表空间。</li>
<li>自适应哈希索引：当二级索引访问频繁的时候，会自动建立哈希索引来加速</li>
<li>预读</li>
</ol>
<h4 id="mysql索引方法有哪些"><a href="#mysql索引方法有哪些" class="headerlink" title="mysql索引方法有哪些"></a>mysql索引方法有哪些</h4><p>B-Tree索引：利用二叉树的特性，同时优化磁盘io，然后查询更快，同时优化索引查询和排序<br>Hash索引：基于hash实现，在hash冲突不高的情况下，速度快，但是对于范围查询和排序都不支持</p>
<h4 id="mysql索引类型有哪些"><a href="#mysql索引类型有哪些" class="headerlink" title="mysql索引类型有哪些"></a>mysql索引类型有哪些</h4><p>主键索引，普通索引（组合索引），唯一索引，全文索引，空间索引</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>你可能不知道的redis</title>
    <url>/post/82b7e52.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>以下是针对redis的知识点整理，用于复习，主要以罗列为主，详细具体讲解可以参考书《Redis设计与实现》，你可以过一遍看看有无知识点遗漏。个人能力有限，如果你还有补充可以再下方评论指出，万分感谢。</p>
<span id="more"></span>
<h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><ul>
<li><p>数据类型<br>string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)<br>底层实现包括：SDS动态字符串，双向链表，数组加链表，渐进式hash，跳表</p>
</li>
<li><p>redis是单线程</p>
</li>
<li><p>redis默认有16个数据库，默认先用0，可以使用select命令切换</p>
</li>
<li><p>过期策略<br>惰性删除：当这个key被访问到，但是已经过期，那就删除<br>定期删除：过一定时间，拿出一定的key判断，进行删除，如果超过一定数量，继续拿出一定的key进行判断删除，时间存在上限</p>
</li>
<li><p>内存超限<br>当redis使用超过内存限制会根据策略来执行：<br>noeviction：不能put，但是可以del和get，默认是这个策略<br>volatile-lru：在有过期时间的key中，淘汰最少用的（redis是近似lru算法，会随机取几个淘汰最少用的）<br>volatile-ttl：在有过期时间的key中，淘汰过期时间最短的（剩下寿命最短的）<br>volatile-random：在有过期时间的key中，随机淘汰<br>allkeys-lru：所有key中，淘汰最少用的<br>allkeys-random：所有key中，随机淘汰</p>
</li>
<li><p>持久化方式<br>RDB、AOF、混合<br>RDB：类似快照，将当前数据拍个照片保存，利用操作系统的 COW 机制来进行数据段页面的分离，进行对数据的复制，同时，新数据会在新的page上面<br>AOF：利用日志来完成记录，当逻辑处理完成记录日志，利用日志重放来恢复，会对aof进行重写瘦身，通过fsync来保证数据刷到磁盘上面，1s一次<br>混合：rdb存储，增量用AOF，重启后先读取rdb再重放aof</p>
</li>
<li><p>通信协议<br>RESP直观的文本协议，利用一些特殊字符来确定当前的是什么语句</p>
</li>
<li><p>redis事务<br>redis可以使用multi/exec/discard。multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。redis是不支持回滚的，只能把当前所有的执行丢弃，事务性能不高，使用管道优化，提供watch机制监听改变，但是针对改变只是知道，但是不予处理。</p>
</li>
<li><p>keys和scan<br>通过这两个命令可以找到对应的键，keys会卡，scan不会但是慢一点，可能会重复。</p>
</li>
<li><p>redis对内存优化<br>在存放大key或者数量量大列表时，会对存储结构进行压缩，ziplist<br>当删除多个键的时候内存不会马上被回收，因为操作系统的内存是按页来的，只有这个页上面的key全部删除才能回收，同时，新的key会利用删除后的空间</p>
</li>
<li><p>Pipeline<br>网络交互中利用了内核的特性，客户发送消息时，只需要将消息写入本地缓存，就马上返回，不需要等待，后续操作由内核网关去异步发送，而读取返回消息时也是读取的本地相对应的读缓存，如果没有数据就需要等待网络返回数据从而从缓存中读取数据，这个时候是真正耗时的时候。</p>
</li>
</ul>
<h2 id="常用架构"><a href="#常用架构" class="headerlink" title="常用架构"></a>常用架构</h2><ul>
<li><p>单机<br>单个节点使用</p>
</li>
<li><p>主从<br>一方面是从做备份，一方面从可以提供get服务<br>Redis同步的是指令流，增量同步，利用buffer进行缓冲，可能出现buffer充满的时候就需要进行快照复制，将主节点进行快照，然后直接发送给从节点，然后从节点删除所有数据，然后从节点进行加载，然后同步新的指令，速度慢。</p>
</li>
<li><p>哨兵<br>利用哨兵去自动选举出主节点，同时出现异常自动重新选出主节点</p>
</li>
<li><p>集群<br>codis：利用中间代理人去访问，将不同的槽位分配到相应的redis节点上面，client通过codis进行访问，codis可以配置多个，通过zk来同步槽位。<br>cluster：官方给出，去中心化，自动维护槽位分布。</p>
</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><p>分布式锁<br>setnx(set if not exists)<br>一开始不支持设置过期时间，后来2.8更新后，命令为：set lock true ex 5 nx<br>但是超时是存在问题的，如果再时间限制过程中，没有执行完，锁自动释放了，但是实际还在执行，但是别的线程可以抢到锁去执行了。</p>
</li>
<li><p>MQ<br>可以利用list来实现消息队列的操作，rpop lpush，redis的list是一个双端队列，同时也支持阻塞拿出消息，来支持队列为空的时候的问题<br>同时有PubSub支持订阅，但是少了很多功能如ack，不能保证数据一定成功发出，后面引入Stream</p>
</li>
<li><p>HyperLogLog<br>用于模糊统计，可以用于统计网站的uv（单个用户访问只能算一次），利用矩阵。</p>
</li>
<li><p>GeoHash<br>redis支持存储地理位置，并且进行附近统计和距离计算</p>
</li>
<li><p>布隆过滤<br>rebloom用于最大化效率去重，会有误判，利用hash原理。实际适用于：爬虫系统过滤已经查过的url、垃圾邮件过滤、缓存击穿防御等，总之用于数据量大、要求速度快、可以忍受误判的情况。</p>
</li>
</ul>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>多次查询那些一定不存在的数据，或者当前数据不在缓存的高并发查询，导致巨大流量涌入数据库。<br>解决方式：</p>
<ol>
<li>缓存空对象，如果可以缓存空对象，将空对象作为null缓存起来，让缓存强制命中（提前缓存或者惰性缓存均可）。存在问题：当空对象多时，浪费了缓存的空间。</li>
<li>利用布隆过滤器缓存出现过的key，保证不在过滤器里面的key一定不存在，布隆过滤器节省很多空间</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>情况一：多数类似缓存同时过期，导致对这些key的查询同时落到数据库。<br>情况二：缓存服务器直接挂掉，导致所有请求全部落到数据库，导致后续雪崩。<br>这里的解决方式就需要视情况而定：<br>情况一的话，可以尝试设置缓存过期时间为随机值，不让同类型缓存同时过期。<br>情况二的话，首先优先保证架构上面能压住，尽可能保证有redis的备份节点可以恢复，当然也要做planB，万一全部缓存节点全部挂，最前面网关层面要要做到限流，后续服务需要做降级或熔断，这个时候就不是缓存的问题了，就是架构的问题了。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>python 基础语法笔记</title>
    <url>/post/fb63c20b.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录python的一些基础语法，用于查阅</p>
<span id="more"></span>
<h2 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h2><ul>
<li>列表和元组都是有序的，可以存储任意数据类型的集合</li>
<li>列表是动态的，长度可变，存储空间和性能略逊与元组</li>
<li>元组是静态的，长度大小固定，不能增加修改</li>
<li>创建一个列表使用 empty_list = [] 相比于 list() 更好，因为 [] 底层走的c，而 list() 是函数，更加贵</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l.count(<span class="number">3</span>)</span><br><span class="line">l.index(<span class="number">7</span>)</span><br><span class="line">l.reverse()</span><br><span class="line">l.sort()</span><br><span class="line">l.append(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># extend会将里面的元素添加进去，而append会直接将[1,2]作为一个元素加入</span></span><br><span class="line">l.extend([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tup.count(<span class="number">3</span>)</span><br><span class="line">tup.index(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">reversed</span>(tup))</span><br><span class="line"><span class="built_in">sorted</span>(tup)</span><br></pre></td></tr></table></figure>
<h2 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h2><p>本质就是hash表</p>
<ul>
<li>删除会赋值为特殊值并在rehash调整大小的时候进行处理</li>
<li>会保留1/3的大小，小于时扩容并rehash</li>
<li>可变元素不能作为key</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">d1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">d2 = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;)</span><br><span class="line">d3 = <span class="built_in">dict</span>([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jason&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">20</span>), (<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;male&#x27;</span>)])</span><br><span class="line">d4 = <span class="built_in">dict</span>(name=<span class="string">&#x27;jason&#x27;</span>, age=<span class="number">20</span>, gender=<span class="string">&#x27;male&#x27;</span>) </span><br><span class="line">d1 == d2 == d3 == d4</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">d[<span class="string">&#x27;name&#x27;</span>]= <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line">d[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">d.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">d.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;null&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">d.pop(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否存在</span></span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">d = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line">d_sorted_by_key = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]) <span class="comment"># 根据字典键的升序排序</span></span><br><span class="line">d_sorted_by_value = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># 根据字典值的升序排序d_sorted_by_key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s1 == s2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基操</span></span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">sorted</span>(s)</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>三个引号用于多行</li>
<li>字符串为不可变的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一样的</span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;123&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">name[<span class="number">0</span>]</span><br><span class="line">name[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> name</span><br><span class="line">	<span class="built_in">print</span>(char)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">s.replace(<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接</span></span><br><span class="line">s += <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="string">&#x27;-&#x27;</span>.join([<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离</span></span><br><span class="line"><span class="string">&#x27;1-1-1-1-2&#x27;</span>.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉开头结尾</span></span><br><span class="line">string.strip(<span class="built_in">str</span>)</span><br><span class="line">string.ltrip(<span class="built_in">str</span>)</span><br><span class="line">string.rtrip(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从开始到结尾进行查找</span></span><br><span class="line">string.find(sub, start, end)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字到字符串，字符串到数字</span></span><br><span class="line"><span class="built_in">str</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;id: &#123;&#125;, name: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;xiaowang&quot;</span>))</span><br><span class="line"><span class="built_in">id</span>: <span class="number">1</span>, name: xiaowang</span><br></pre></td></tr></table></figure>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul>
<li>使用with会自动关闭打开的文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;your name:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;in.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">    text = fin.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;out.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">    fout.write(<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="json操作"><a href="#json操作" class="headerlink" title="json操作"></a>json操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 序列化对象为json字符串</span></span><br><span class="line">json.dumps(params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化json字符串</span></span><br><span class="line">json.loads(params_str)</span><br></pre></td></tr></table></figure>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ul>
<li>使用elif</li>
<li>后面要有冒号</li>
<li>条件内为空的均为false</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">id</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">id</span> == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历元素</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> l:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历下标</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(l)):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(l[index])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下标和元素同时需要，使用enumerate</span></span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while当然也可以</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(l):</span><br><span class="line">    <span class="built_in">print</span>(l[index])</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单行操作，很简洁</span></span><br><span class="line">expression1 <span class="keyword">if</span> condition <span class="keyword">else</span> expression2 <span class="keyword">for</span> item <span class="keyword">in</span> iterable</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        expression1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        expression2</span><br><span class="line"></span><br><span class="line">expression1 <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        expression1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li>json反序列化的时候需要异常处理</li>
<li>文件需要异常处理</li>
<li>必要的时候才进行异常处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = <span class="built_in">input</span>(<span class="string">&#x27;please enter two numbers separated by comma: &#x27;</span>)</span><br><span class="line">    num1 = <span class="built_in">int</span>(s.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>].strip())</span><br><span class="line">    num2 = <span class="built_in">int</span>(s.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>].strip())</span><br><span class="line">    ... </span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Value Error: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(err))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;continue&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> (ValueError, IndexError) <span class="keyword">as</span> err:</span><br><span class="line"></span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Value Error: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(err))</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Index Error: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(err))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Other error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInputError</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Exception raised when there&#x27;re errors in input&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span> <span class="comment"># 自定义异常类型的初始化</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span> <span class="comment"># 自定义异常类型的 string 表达形式</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;&#123;&#125; is invalid input&quot;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.value)))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyInputError(<span class="number">1</span>) <span class="comment"># 抛出 MyInputError 这个异常</span></span><br><span class="line"><span class="keyword">except</span> MyInputError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;error: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(err))</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>要先定义在上面</li>
<li>使用的时候才会创建</li>
<li>内部变量作用域只在函数内部</li>
<li>不能在函数内部随意改变全局变量的值</li>
<li>对于嵌套函数来说，内部函数可以访问外部函数定义的变量，但是无法修改，若要修改，必须加上 nonlocal 这个关键字</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不需要申明类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">param = <span class="number">0</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数定义嵌套，内部函数无法被外部直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">    f2()</span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    x = <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x <span class="comment"># nonlocal 关键字表示这里的 x 就是外部函数 outer 定义的变量 x</span></span><br><span class="line">        x = <span class="string">&#x27;nonlocal&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;inner:&quot;</span>, x)</span><br><span class="line">    inner()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;outer:&quot;</span>, x)</span><br><span class="line">outer()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">inner: <span class="keyword">nonlocal</span></span><br><span class="line">outer: <span class="keyword">nonlocal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 闭包，就是返回一个函数而已</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_power</span>(<span class="params">exponent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exponent_of</span>(<span class="params">base</span>):</span></span><br><span class="line">        <span class="keyword">return</span> base ** exponent</span><br><span class="line">    <span class="keyword">return</span> exponent_of <span class="comment"># 返回值是 exponent_of 函数</span></span><br><span class="line"> </span><br><span class="line">square = nth_power(<span class="number">2</span>) <span class="comment"># 计算一个数的平方</span></span><br><span class="line">cube = nth_power(<span class="number">3</span>) <span class="comment"># 计算一个数的立方</span></span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul>
<li>lambda 是一个表达式（expression），并不是一个语句（statement）</li>
<li>lambda 的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> argument1, argument2,... argumentN : expression</span><br><span class="line"></span><br><span class="line">square = <span class="keyword">lambda</span> x: x**<span class="number">2</span></span><br><span class="line">square(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map函数，对于集合内每个元素都做一次func</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_list = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, l) <span class="comment"># [2， 4， 6， 8， 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filter函数，对于集合内每个元素都做一次func，并返回true或者false，结果返回为true的集合</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">new_list = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, l) <span class="comment"># [2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reduce函数，集合内每个元素都做一次func，最后将结果组合</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">product = reduce(<span class="keyword">lambda</span> x, y: x * y, l) <span class="comment"># 1*2*3*4*5 = 120</span></span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>():</span></span><br><span class="line">    </span><br><span class="line">    WELCOME_STR = <span class="string">&#x27;Welcome! The context for this book is &#123;&#125;.&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, title, author, context</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init function called&#x27;</span>)</span><br><span class="line">        self.title = title</span><br><span class="line">        self.author = author</span><br><span class="line">        self.__context = context</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类函数</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_empty_book</span>(<span class="params">cls, title, author</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(title=title, author=author, context=<span class="string">&#x27;nothing&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__context)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 静态函数</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_welcome</span>(<span class="params">context</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Document.WELCOME_STR.<span class="built_in">format</span>(context)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">empty_book = Document.create_empty_book(<span class="string">&#x27;What Every Man Thinks About Apart from Sex&#x27;</span>, <span class="string">&#x27;Professor Sheridan Simove&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(empty_book.get_context_length())</span><br><span class="line"><span class="built_in">print</span>(empty_book.get_welcome(<span class="string">&#x27;indeed nothing&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"> </span><br><span class="line">init function called</span><br><span class="line"><span class="number">7</span></span><br><span class="line">Welcome! The context <span class="keyword">for</span> this book <span class="keyword">is</span> indeed nothing.</span><br></pre></td></tr></table></figure>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>巧用if <strong>name</strong> == ‘<strong>main</strong>‘来避开 import 时执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入utils包下的util文件的get_sum方法</span></span><br><span class="line"><span class="keyword">from</span> utils.utils <span class="keyword">import</span> get_sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接从项目根目录中导入，并依次向下导入模块 mat.py 中的 Matrix</span></span><br><span class="line"><span class="keyword">from</span> proto.mat <span class="keyword">import</span> Matrix</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> module_name</span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> * </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title>GopherChina2020 个人总结</title>
    <url>/post/c2947f12.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前去过几次相关 go 的线下 meetup，这次相对来说比较大型一些，两天的听下来还是比较烧脑的，光是记录的笔记都有近千行了，整体来说收获很大。</p>
<p>有的人问，值票价吗？我回答：对喜欢的投资没有不值得的。对我来说值了~</p>
<p>有的人问，值得去吗？我回答：不一定，因为可能在很多大佬看来能听到的点不多（采访了几位现场的大厂观众，普遍表示只有其中 1 到 2 场满足他们的要求）但是如果你的小白或者一年到两年左右，还是能见识很多东西的。可能是我听多了，和之前自己学到的有点重复…</p>
<span id="more"></span>
<p>下面是个人精炼总结，全是个人总结，自己如果对这个知识或者相关点比较清晰的我就没有记录了。其中会伴随一些个人思考和疑问，可以小声 bb 。大会分 1和 2 会场，所以只能选其中一个听，我也是记录我自己听到的，另外一个会场不清楚（我交叉穿来穿去的）<strong>注意并不是有的老师讲的真的不好，而是对我个人来说意义不明显，可能由于知识点已经掌握，也可能是由于工作上确实用不到哦</strong></p>
<p>最后会附上会上笔记，仅做个人使用，乱了也不管~ 最后无论如何，感谢每一位老师的付出~~~</p>
<h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><ul>
<li>分布式数据库设计难题：数据分片，节点加入和减少</li>
<li>如果让你设计一个系统，扫描两个人经过的地理位置，从而进行匹配出擦肩而过的人，你会怎么设计？</li>
<li>Go Programming Patterns （这一部分建议直接看 PPT，每一张仔细看，学到很多，这一部分很值）<a href="https://www.slideshare.net/haoel/go-programming-patterns">https://www.slideshare.net/haoel/go-programming-patterns</a><ul>
<li>使用嵌入或者聚合来做设计</li>
<li>使用 IOC 进行控制翻转来设计*</li>
<li>golang 中 如何 做 MapReduce</li>
<li>generic 我还是不太喜欢生成很多无用代码，虽然确实方便，但总觉得代码量太大看着不喜欢</li>
<li>如何实现一个类似 linux 管道 命令的 go 代码 pattern</li>
</ul>
</li>
<li>Go-kit 如何设计一个脚手架生成器，需要关注那些点</li>
<li>奥卡姆剃刀法则，大道至简</li>
<li>是否应该使用 sidecar，我觉得更多时候不需要，虽然这是一个不错的设计</li>
<li>配置加载的最佳实践：配置文件yaml -&gt; struct -&gt; 提供 options 方法 -&gt; 传入到初始化方法中（这个思路可以）</li>
<li>code review 很重要，一次提交 170 多个评论，NB</li>
<li>文档优先，30% coding 时间（我也是一个不太愿意去写文档的开发，后面可能会有所改观）<strong>文档不是补出来的</strong></li>
<li>《软件开发的 201 个原则》</li>
<li>《代码艺术》</li>
<li>拆分时的一个原则：单一职责</li>
<li><a href="https://github.com/didi/nightingale">https://github.com/didi/nightingale</a><ul>
<li>夜莺本身我觉得是一个挺不错的产品，为运维开发提供了一个解决方案</li>
<li>但是讲座本身更多的在将功能和设计，对我来说意义不是特别大</li>
<li>产品定位很明确，希望后面越来越好</li>
</ul>
</li>
<li>go+ 很 py 让我了解了原来可以在一个语言之上构建一个语言，解释器很棒，很喜欢，后面会考虑拿来用；老许没来，可惜了</li>
<li>tidb 遇到的问题<ul>
<li>调度延迟 </li>
<li>内存管理 transparent huge page 透明大页还会有这样的问题，学到了</li>
<li>NUMA 下的问题，多核绑定</li>
</ul>
</li>
<li>Go 语言编译器 这又是一位大牛分享怎么优化编译器的，让我学到了编译过程，但能力有限，后面再说吧….（没有兴趣继续研究）</li>
<li>EDAS 云原生<ul>
<li>讲师对于控制器模式的讲解很到位，这是我第一次听到有人将这个模式比喻的很清晰（建议好好看 ppt）k8 的核心</li>
<li>OAM 模型很不错，这个抽象很棒，后续可以详细了解一下</li>
</ul>
</li>
<li>gorm 嗯，挺棒的，但是我现在不用~ 等我有机会回来再用你</li>
</ul>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>我建议下面几场没听的可以去听下，至少对我来说收获比较大：</p>
<ol>
<li>耗子哥的 Go Programming Patterns 让我学到了一些好的设计，其实和毛老师的有重合，毛老师+了一点点【1.3 go-programming-patterns】【1.6 Functional options and config for APIs】</li>
<li>百度的 BFE 主要学到了代码之外的项目管理方法和思路，还有文档，以及一些非编程相关的思想，经验传递！【2.1.1 百度万亿流量转发平台背后的故事】</li>
<li>tidb 让我认识到了一些极高压力下的性能瓶颈，有些场景怕是我这辈子不一定能遇到，up！【2.1.4 PingCAP-Go runtime related problems in TiDB production environment】</li>
<li>EDAS 其中的 OAM 模型抽象不错，学到了【2.2.6 Golang大规模云原生应用管理实践】</li>
<li>go+ 和 编译器 让我理解了 go 的编译过程，之前学的比较粗，现在有了新的认识，更加明确了，这块确实不适合我~【2.1.5 Go语言编译器简介】</li>
</ol>
<p>当然还有几场我没听到的据说也有很多金子，后面再想办法看看吧。<br>PS：英文的那场普罗米修斯真的对我来说太难了，语速真的超过我的理解能力了，抱歉是我不行。</p>
<hr>
<hr>
<p>-/以下为 大会上 笔记 边听边盲打 易错体质/-</p>
<h1 id="探探分布式存储"><a href="#探探分布式存储" class="headerlink" title="探探分布式存储"></a>探探分布式存储</h1><p>结合业务需求需要一个轮子，需要一个分布式存储</p>
<p>业务：其实更多的业务场景不需要分布式事务，更多是通过补偿机制来完成的。是否需要强一致性的业务？</p>
<ol>
<li>ACID BASE</li>
<li>RECELE</li>
<li>SQL</li>
</ol>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><p>解析 sql</p>
<ol>
<li>AST</li>
<li>语法校验</li>
<li>优化</li>
<li>列执行计划</li>
<li>生成执行器</li>
</ol>
<p>逻辑优化器：列裁剪、谓词下推、聚合下推、topN 下推</p>
<p>执行器优化：从“火山执行器”走到“向量执行器” 以列为单位去处理</p>
<h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>hash：使用 hash 之后之后取余之后存储</p>
<p>rehash：需要将机器上的数据扫一遍，有点慢</p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>中心化：超时，网络分区，使用的是这个</p>
<p>无中心化：gossip 收敛会慢</p>
<p>其实就是通过心跳检测去监控故障检测</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>使用分布式锁，直接进行选举，没必要讲究什么公平性，只要抢占的越快负载越低，直接当选即可</p>
<p>当故障进行恢复的时候，所有的请求直接打到一个新的从节点从而导致峰值，解决方式是偶尔将请求发送给从节点，从而保持从节点的热数据</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>时延从 19ms - 3ms</p>
<p>有针对磁盘的存储进行优化</p>
<p>词法分析的优化暂不考虑</p>
<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>goroutine 限制和泄露，使用 goleak 来进行检测 <a href="http://github.com/uber-go/goleak">http://github.com/uber-go/goleak</a></p>
<p>忘记 defer cancel 导致 context 泄露</p>
<p>主要还是依赖 pprof</p>
<p>尽量减少对象分配，进行逃逸分析，尽量分配到 stack 上去，在外部申请对象，将对象的指针传入到 function</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>将在 2021 年开源，物理优化，同步复制，Range 分区（因为分区的原因，其实是去每一台机器上去查一遍然后进行聚合，暂时没有好的解决），生态</p>
<p>对于 join 的查询支持是不好的，还是有可能出现所有机器进行扫描全量数据的可能性</p>
<h1 id="Go-Programming-Patterns"><a href="#Go-Programming-Patterns" class="headerlink" title="Go Programming Patterns"></a>Go Programming Patterns</h1><p>左耳朵</p>
<h3 id="function-vs-receiver"><a href="#function-vs-receiver" class="headerlink" title="function vs receiver"></a>function vs receiver</h3><p>推荐使用 receiver 进行</p>
<h3 id="interface-patterns"><a href="#interface-patterns" class="headerlink" title="interface patterns"></a>interface patterns</h3><p>使用 对象 进行实现 接口，进行解耦 EX: io.Reaed / ioutil.ReadAll</p>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>使用 RFC3339 的时间格式进行交互</p>
<h3 id="delegation"><a href="#delegation" class="headerlink" title="delegation"></a>delegation</h3><p>使用嵌入或者聚合来做设计</p>
<p>使用 IOC 进行控制翻转来设计</p>
<h3 id="error-handle"><a href="#error-handle" class="headerlink" title="error handle"></a>error handle</h3><p>if err ≠ nil</p>
<p>使用 closure for error</p>
<p>bufio.NewScanner(</p>
<p>想法还是包装一次，使用一个 error 的一个局部变量，当有错误直接 return，否则进行处理</p>
<p>使用包装 error %w</p>
<h3 id="function-options"><a href="#function-options" class="headerlink" title="function options"></a>function options</h3><p>使用 config 进行传入，使用 withOption 进行</p>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>使用 Mapreduce 进行函数式编程</p>
<p>SumIf、CountIF，FileterIn</p>
<h3 id="generic-map"><a href="#generic-map" class="headerlink" title="generic map"></a>generic map</h3><p>使用反射进行 transform 进行处理更加优雅</p>
<p>Verify function signature</p>
<p>可以用它来去类型</p>
<h3 id="type-assert-和-reflection"><a href="#type-assert-和-reflection" class="headerlink" title="type assert 和 reflection"></a>type assert 和 reflection</h3><p>使用类型检查和反射来使泛型操作</p>
<p>go generate，使用代码生成来生成你的不同类型的操作</p>
<p>可以使用 gen</p>
<h3 id="pros-Cons"><a href="#pros-Cons" class="headerlink" title="pros / Cons"></a>pros / Cons</h3><p>别 cv 了，类型检查比较慢，使用 gen 有成本（代码量膨胀），reflection 代码比较难</p>
<h3 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h3><p>使用包装函数来包装一个函数的前后方法</p>
<p>还可以使用 defer 进行包装调用</p>
<p>EX：http server </p>
<h3 id="kubernetes-visitor"><a href="#kubernetes-visitor" class="headerlink" title="kubernetes visitor"></a>kubernetes visitor</h3><p>visitor，使用嵌套进行包装，并且进行内部进行调用装饰处理，这样的就可以实现一个 receiver，进行多个 function 的调用</p>
<p>确实比较绕一点，优雅</p>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>使用一个函数的输入输出来进行 pipe</p>
<p>或者使用一个 channel 进行解耦，可以写出 类似 linux pipeline 的编程模式</p>
<h1 id="Grab-food-discovery"><a href="#Grab-food-discovery" class="headerlink" title="Grab food - discovery"></a>Grab food - discovery</h1><h2 id="preview"><a href="#preview" class="headerlink" title="preview"></a>preview</h2><p>tree - model</p>
<p>api pool</p>
<p>grab-kit</p>
<h2 id="grab-kit"><a href="#grab-kit" class="headerlink" title="grab-kit"></a>grab-kit</h2><p>可伸缩、容错、观察</p>
<p>支持 http/rpc</p>
<p>目标就是去简化 go-kit 的开发过程</p>
<h3 id="脚手架的使用"><a href="#脚手架的使用" class="headerlink" title="脚手架的使用"></a>脚手架的使用</h3><ol>
<li>通过 proto 去定义</li>
<li>service 定义 req 和 resp，req 的简单校验</li>
<li>调用命令去生成其他所有的脚手架</li>
</ol>
<h3 id="中间件的使用"><a href="#中间件的使用" class="headerlink" title="中间件的使用"></a>中间件的使用</h3><ol>
<li>服务中间件将中间件的定义成了不同类型的中间件</li>
<li>defensive 去检测 typed nil，使用中间件去保证业务上不要出现一些问题</li>
<li>chaos 混沌测试，在生产环境中，独立出一部分流量，故意失败一些服务，测试服务伸缩告警等性能是否正常</li>
<li>resilient 弹性控件：限流、cpu 利用率的限制、使用 cache、timeout</li>
</ol>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>datadog，商用的，通过启动时进行注册，打点会直接相关数据直接扔到上面去</p>
<p>会有一个默认的 dashboard 的进行展示</p>
<h2 id="food-discovery（ML-PIPELINE）"><a href="#food-discovery（ML-PIPELINE）" class="headerlink" title="food discovery（ML PIPELINE）"></a>food discovery（ML PIPELINE）</h2><p>候选集合 - 过滤 - 重排序 - 后排序</p>
<p>从移动端的日志流，进入数据湖，train 会生成模型，然后不断进行训练修改，deploy 到线上，然后提供 api 进行调用</p>
<p>模型很复杂、训练样本，特征，都会有影响</p>
<p>模型和模型之间有很多关联关系</p>
<p>训练样本很多，很多时候特征不是很重要，但是计算复杂</p>
<p>特征还好发生变化，模型和系统之间的交互很复杂，对于你的环境造成很多影响</p>
<p>反馈环导致准确率不高，很难评估和验证</p>
<p>需要提供完备的监控来保证这个</p>
<p>将所有的 CI\CT\CD 持续训练，通过 devops 来的想法，将整个流程自动化起来，降低交付成本；</p>
<p>准备数据，训练，实验，部署，监控</p>
<p>Hierarchiacal Temporal-Contextrual</p>
<p>LightGBM</p>
<h2 id="why-go"><a href="#why-go" class="headerlink" title="why go"></a>why go</h2><ol>
<li>编译速度，使用一个 repo 来维护一个整个大的微服务，一个微服务的改动会使得上游进行编译</li>
<li>依赖管理</li>
<li>GC pause time </li>
</ol>
<p>*使用 kubebuilder 进行 build 构建</p>
<h1 id="华为云-通信协议"><a href="#华为云-通信协议" class="headerlink" title="华为云 通信协议"></a>华为云 通信协议</h1><h2 id="Service-Center"><a href="#Service-Center" class="headerlink" title="Service Center"></a>Service Center</h2><p>注册发现：</p>
<ol>
<li>微服务的静态信息和动态信息分离：冗余信息不进行传输，减少网络压力</li>
<li>契约：api 优先，将 api 的定义直接到了注册中心，使用 mock 的方式来保证效率；还有 restful 定义不一致，还有相似的 api 能力，帮助团队 API 审视；</li>
<li>服务依赖管理：让整个微服务架构能知道服务调用链路，这里是通过卖点实现的；使用 webhook 或者 mq 进行解耦；减少链路，层级关系降低，让一个服务去聚合；</li>
<li>缓存更新机制：使用 etcd 来进行维护，将所有的数据缓存到本地，watch key 变化，即使 ETCD 挂了也没事，缓存还有</li>
</ol>
<p>交付的不只有业务，包括监控，告警，中间件，限流，跨域，认证，调用链追踪等等，插件的部署</p>
<p>交付角度：</p>
<ol>
<li>一个分支进行交付（不对的！一定要做好插件化，一个分支进行迭代）</li>
<li>依赖倒置，对接不同的服务，在编译器保证插件</li>
<li>对象存储不同的对接</li>
<li>不同的算法对接</li>
</ol>
<h2 id="chassis"><a href="#chassis" class="headerlink" title="chassis"></a>chassis</h2><p><a href="http://github.com/go-chassis/go-chassis">http://github.com/go-chassis/go-chassis</a></p>
<h3 id="手段-1-将后端服务作为插件使用"><a href="#手段-1-将后端服务作为插件使用" class="headerlink" title="手段 1 将后端服务作为插件使用"></a>手段 1 将后端服务作为插件使用</h3><p>把你的后端服务作为一个资源使用；注意这个并不是一个微服务的体系，这个还是有区别的；</p>
<p>面向用户来说，定义接口，定义插件安装api，然后提供 api；</p>
<h3 id="手段-2-标准化模型"><a href="#手段-2-标准化模型" class="headerlink" title="手段 2 标准化模型"></a>手段 2 标准化模型</h3><p>将不同的请求转换成一个一致的协议，然后到一个统一的中间件进行治理；所有的请求都将转换到一个 invocation 进行调用；</p>
<p>通过申明试的调用，对自己的流量进行描述，然后限流策略，那些接口等；</p>
<p>熔断，复杂均衡等都是通过申明式实现的</p>
<p>收益：其他的业务团队可以减少开发，很多提供的能力都可以复用来看</p>
<h3 id="手段-3-配置治理"><a href="#手段-3-配置治理" class="headerlink" title="手段 3 配置治理"></a>手段 3 配置治理</h3><p>单体对于配置管理很简单，但是分布式的时候配置管理就需要进行配置治理；</p>
<p>source 概念：当发生一些配置变更的时候，将触发不同的 event 然后分发到不同 listeners </p>
<h3 id="手段-4-易处理"><a href="#手段-4-易处理" class="headerlink" title="手段 4 易处理"></a>手段 4 易处理</h3><p>统一的接口层，运行你注册业务逻辑，有基本的 start 和 stop</p>
<p>支持不同的编程模型</p>
<p>利用一个装饰器的模式，进行一个修饰，将框架的东西加进去，利用插件的方式安装进去，利用配置文件，指定不同的协议，都可以</p>
<p>优雅停机：基本的系统信号都会捕捉，保证所有业务请求都处理完成才会真正的 shutdown</p>
<p>提供 pre、post 等自定义之后</p>
<p>go 1.8 之后已经支持优雅停机了</p>
<h3 id="手段-5-奥卡姆剃刀法则"><a href="#手段-5-奥卡姆剃刀法则" class="headerlink" title="手段 5 奥卡姆剃刀法则"></a>手段 5 奥卡姆剃刀法则</h3><p>最小化容器的大小</p>
<p>最小化安全漏洞</p>
<p>最小化代码量</p>
<p>最小化复杂度</p>
<p>其实是将很多依赖都搬运到了 extention 中</p>
<p>bootstrap功能：任意替换默认实现，加载并允许新的模块供运行时提供和使用</p>
<h2 id="该不该用-sidecar"><a href="#该不该用-sidecar" class="headerlink" title="该不该用 sidecar"></a>该不该用 sidecar</h2><p>跟流量相关的治理功能都可以沉降到服务网格中</p>
<p>后面可以将功能进行云原生</p>
<h2 id="go-chassis"><a href="#go-chassis" class="headerlink" title="go-chassis"></a>go-chassis</h2><ul>
<li>华为网关产品</li>
<li>使用了这个产品</li>
<li>实时音频的 RTC</li>
<li>边缘计算 kubeedge</li>
<li>基于框架的二次封装</li>
</ul>
<h1 id="functional-options-and-config-for-apis"><a href="#functional-options-and-config-for-apis" class="headerlink" title="functional options and config for apis"></a>functional options and config for apis</h1><p>毛剑</p>
<h2 id="function-的定义"><a href="#function-的定义" class="headerlink" title="function 的定义"></a>function 的定义</h2><p>初始化 api 定义；将所有的初始化的方法都来一遍，很麻烦</p>
<h3 id="解决方式-1：通过一个结构进行参数定义"><a href="#解决方式-1：通过一个结构进行参数定义" class="headerlink" title="解决方式 1：通过一个结构进行参数定义"></a>解决方式 1：通过一个结构进行参数定义</h3><p>需要将所有的配置对外暴露，其实就是搞个 config 一个对象来进行初始化</p>
<ul>
<li>不知道参数是否可选</li>
<li>文档写起来比较多</li>
<li>外部有可能会直接进行修改</li>
</ul>
<p>*对于一个 public 方法不要传递一个 nil 来进行</p>
<h3 id="解决方式-2：通过-options-来进行扩展"><a href="#解决方式-2：通过-options-来进行扩展" class="headerlink" title="解决方式 2：通过 options 来进行扩展"></a>解决方式 2：通过 options 来进行扩展</h3><p>每一个 withoption 都是可以进行使用的</p>
<p>当 option 为 nil 使用 default 进行替换</p>
<p>独立去维护每个 option 文档</p>
<p>还可以保留状态，使用 defer 进行状态还原，-vvv</p>
<p>还定义 Option interface 在 before 进行前后进行操作</p>
<h3 id="问题：配置文件是-json-或者-yaml"><a href="#问题：配置文件是-json-或者-yaml" class="headerlink" title="问题：配置文件是 json 或者 yaml"></a>问题：配置文件是 json 或者 yaml</h3><p>你的 api 和你的配置文件不应该强绑定</p>
<p>*google sre 运维</p>
<p>将你的配置文件转换成 Config 对象，然后让 Config 对象提供一个 Options 方法，然后将配置返回成 Options slice</p>
<p>这样就能保证使用 json 或者 yaml 格式的配置文件，也能支持 option 方法的 function 设计</p>
<h2 id="配置最佳实践"><a href="#配置最佳实践" class="headerlink" title="配置最佳实践"></a>配置最佳实践</h2><p>配置中心方便了配置变动，那么更加容易出错；</p>
<ul>
<li>避免复杂配置，更多使用默认配置</li>
<li>通过配置文件模板来帮助你减少错误，配置中心或支持配置引用</li>
<li>配置的防御编程</li>
<li>配置的权限变更和追踪</li>
<li>配置版本和应用版本对齐，回滚的时候也要注意配置回滚</li>
</ul>
<h3 id="配置是否需要支持热加载"><a href="#配置是否需要支持热加载" class="headerlink" title="配置是否需要支持热加载"></a>配置是否需要支持热加载</h3><p>配置分为动态配置和静态配置</p>
<p>静态配置热加载是很有风险的，所以不要进行配置热加载，任何一次配置变更都走一个迭代版本；</p>
<p>动态配置还是通过后端数据进行拉取更加靠谱；</p>
<h1 id="百度-BFE-平台"><a href="#百度-BFE-平台" class="headerlink" title="百度 BFE 平台"></a>百度 BFE 平台</h1><p>讲如何做一个 BFE 的，是怎么构成的？</p>
<h2 id="什么是-BFE"><a href="#什么是-BFE" class="headerlink" title="什么是 BFE"></a>什么是 BFE</h2><p>一个统一的七层流量转发平台，在内网跨机房的调度</p>
<p>一个专用的转发引擎</p>
<p>对于流量的转发</p>
<p>支持春晚的红包</p>
<h2 id="团队理念"><a href="#团队理念" class="headerlink" title="团队理念"></a>团队理念</h2><p>对技术足够痴迷，一个东西做 5 年做 6 年去做，寻找的真正的 SE</p>
<p>30 开始只是写代码无数必备素质之一</p>
<p>看中寻找和培养人才，只有把人培养好</p>
<p>看中过程：如果没有正确的方法，成功只是偶然</p>
<p>只需要 975，需要聪明的工作，平衡了工作和生活</p>
<h2 id="项目研发的指导思想"><a href="#项目研发的指导思想" class="headerlink" title="项目研发的指导思想"></a>项目研发的指导思想</h2><p>意识 =》看见 =》行动</p>
<p>研发方向的确立</p>
<p>以一个研究问题的角度，去解决，直接对标了国际上的论文去专门研究</p>
<p>通过趋势的判断，来指定产品的角度</p>
<h2 id="研发过程的管控"><a href="#研发过程的管控" class="headerlink" title="研发过程的管控"></a>研发过程的管控</h2><ul>
<li>质量，来源于对产品研发过程的严格管控</li>
<li>只要的把控<ul>
<li>代码</li>
<li>文档</li>
<li>项目管理</li>
</ul>
</li>
</ul>
<h2 id="一流代码特性"><a href="#一流代码特性" class="headerlink" title="一流代码特性"></a>一流代码特性</h2><ul>
<li>鲁棒</li>
<li>搞笑</li>
<li>*简洁</li>
<li>*简短</li>
<li>可测试性</li>
<li>共享（可复用）</li>
<li>可移植</li>
<li><ul>
<li>可监控</li>
</ul>
</li>
<li><ul>
<li>可运维</li>
</ul>
</li>
<li><ul>
<li>可扩展</li>
</ul>
</li>
</ul>
<p>正确、性能、可读、可维护、共享、重用、运维、运营</p>
<h3 id="code-review-的重要性"><a href="#code-review-的重要性" class="headerlink" title="code review 的重要性"></a>code review 的重要性</h3><p>一个 commit 添加 187 条 commet </p>
<h3 id="复用的基础库"><a href="#复用的基础库" class="headerlink" title="复用的基础库"></a>复用的基础库</h3><p>不断地抽离可以复用的基础库</p>
<p>建立基础库的前提 → 知道怎么切分模块 还是需要抽象的能力</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档本身也是产出：codeing 时间少于30%</p>
<p>写文档是整理思路的过程：打字的速度应该快于思考的速度</p>
<p>没有文档后期会花费更多的维护成本</p>
<p>简单的项目也需要文档</p>
<p>文档不是补出来的</p>
<p><strong>《软件开发的 201 个原则》</strong></p>
<p><em>文档和代码都是一种沟通方式</em></p>
<ul>
<li>文档也需要 review</li>
<li>以项目为单位建立文档索引</li>
</ul>
<h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><p>好的管理比好的技术更重要</p>
<p>项目的规划和启动</p>
<p>周报</p>
<p>迭代管理</p>
<p>项目总结和回顾</p>
<p>lite weight process</p>
<h2 id="研发和运维的一体化"><a href="#研发和运维的一体化" class="headerlink" title="研发和运维的一体化"></a>研发和运维的一体化</h2><ul>
<li>研发和运维分离的问题<ul>
<li>研发不考虑运维的痛点</li>
</ul>
</li>
<li>可运维能力，是系统的重要考虑</li>
<li>日志，内部转给他的展示，监控 monitor 的一个库</li>
<li>链路追踪</li>
</ul>
<h2 id="努力提升工程能力"><a href="#努力提升工程能力" class="headerlink" title="努力提升工程能力"></a>努力提升工程能力</h2><p>正规科学的研发方法，提升工程能力，才是解决之道</p>
<p>复杂系统并不是的技术无法实现，而是因为工程能力没有正确的</p>
<h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>单一目的 single purpose</p>
<p>数据封装 </p>
<p>《代码艺术》</p>
<h1 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h1><p><a href="https://github.com/didi/nightingale">https://github.com/didi/nightingale</a></p>
<h2 id="海量运维问题"><a href="#海量运维问题" class="headerlink" title="海量运维问题"></a>海量运维问题</h2><ul>
<li>大量不同的服务</li>
<li>大规模的机器</li>
<li>网络抖动</li>
<li>机器环境各异</li>
<li>机器上发行版不一样</li>
<li>….</li>
</ul>
<p>在流量转发层做文章</p>
<p>统一机器初始化</p>
<p>统一权限，统一日志，统一审计</p>
<p>自动化工单，知识库构建，答疑</p>
<h2 id="为什么选择-go"><a href="#为什么选择-go" class="headerlink" title="为什么选择 go"></a>为什么选择 go</h2><p>资源占用少，适合开发 agent</p>
<p>静态编译依赖少</p>
<p>运维相关的东西都是用的 go</p>
<h2 id="运维平台体系构筑方向"><a href="#运维平台体系构筑方向" class="headerlink" title="运维平台体系构筑方向"></a>运维平台体系构筑方向</h2><p>安全稳定高效低成本</p>
<p>监控标准</p>
<p>故障的响应原则</p>
<p>漏报率是一个比较重要的指标</p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>预防、发现、定位、止损、富婆</p>
<p>应急备案</p>
<h3 id="变更体系"><a href="#变更体系" class="headerlink" title="变更体系"></a>变更体系</h3><p>带外装机管理、堡垒机跳板、机器初始化</p>
<h3 id="效率体系"><a href="#效率体系" class="headerlink" title="效率体系"></a>效率体系</h3><p><strong>日常工作平台化</strong></p>
<p><strong>重复工作自动化</strong></p>
<p>ChatOps 各类聊天机器人</p>
<p>知识库 </p>
<h2 id="运维体系如何构建"><a href="#运维体系如何构建" class="headerlink" title="运维体系如何构建"></a>运维体系如何构建</h2><p>夜莺</p>
<p>任务执行更新</p>
<p>支持 ansible saltstack 批量执行脚本，权限可以控制的更针对一些，审计方面，轻量级一些</p>
<p>主要还是一个运维工单的能力来进行的一个构建，能够帮助一个新的公司快速构建一个运维体系</p>
<p>想要支持 M3</p>
<p>所有的模块都是高可用的，体系化程度更高</p>
<p>http 接口的成功率，延时，产品化程度更高一些</p>
<p>对于物理机虚拟机的监控更加支持一些</p>
<h1 id="GO"><a href="#GO" class="headerlink" title="GO+"></a>GO+</h1><p>七牛</p>
<h2 id="为什么要做-go"><a href="#为什么要做-go" class="headerlink" title="为什么要做 go+"></a>为什么要做 go+</h2><p>作用于有限的领域</p>
<p>作用于科学领域</p>
<p>数据规模非常的大</p>
<p>python 让数据软件平民化</p>
<p>python 做不了基础设施？</p>
<p>在 go+ 之上做数学软件</p>
<h2 id="现在有什么特征"><a href="#现在有什么特征" class="headerlink" title="现在有什么特征"></a>现在有什么特征</h2><p>和 go 完全兼容</p>
<p>语法、代码简洁</p>
<p>所有 go 的包都可以直接引用</p>
<ul>
<li>支持有理数</li>
<li>map 特有语法</li>
<li>让计算处理更简单</li>
<li>特有的 err 处理 ! ? 。。。</li>
</ul>
<h2 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h2><p>go+ 源码 - ast - 双引擎 - 字节码或者 go 源码</p>
<p>token 和 parser 是生成拓扑序列的</p>
<ol>
<li>词法分析：将源文件转换成 token 序列，go+ 有自己的 tokne</li>
<li>语法分析：将 token 序列转换为 AST，go+ 需要支持自己的语法，需要将这个抽查语法树的重新实现和构建</li>
<li>编译：解析 AST 转换成 二进制或者 go 源码，生成 go 源码将 AST+ → AST 即可，转成 go 的源码</li>
</ol>
<h2 id="Go-的下一步"><a href="#Go-的下一步" class="headerlink" title="Go+的下一步"></a>Go+的下一步</h2><p>冷板凳？其实做语言本身是很难得，很少有人愿意去学习解析语法等等一些功能</p>
<h1 id="PingCAP-TiDB"><a href="#PingCAP-TiDB" class="headerlink" title="PingCAP TiDB"></a>PingCAP TiDB</h1><p>runtime 相关问题</p>
<h2 id="调度延迟"><a href="#调度延迟" class="headerlink" title="调度延迟"></a>调度延迟</h2><p>案例：</p>
<p>多个 goroutine 向 channel 写消息，一个 for 循环去处理这个消息，发现延迟很高</p>
<p>调查：</p>
<p>从网络可读到到 goroutine 被调度唤醒可以处理请求，出现 4.x ms</p>
<p>在混合负载中 由公平调度导致的</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>找操作系统分配内存，都是 runtime 决定的；真正用到的就是 inused memery</p>
<p>runtime 会估算自己要用多少，不会马上归还操作系统，会保留一些</p>
<p>操作系统有一个快表，TLB，默认的一个页大小是 4k，经过虚拟地址和物理地址的映射</p>
<p>透明大页：它把每页的大小改大</p>
<p>案例：</p>
<p>开启透明大页之后发现内存很大</p>
<p>从操作系统层面看到内存量很高，但是实际使用不高</p>
<p>anonHugePage</p>
<p>和 transparent huge page 开启相关</p>
<p>分析：</p>
<p>当开启之后 THP 在 go 的视角里面其实释放了，但是因为页大，所有操作系统看来，有的页还有内存碎片，所以无法回收</p>
<p>操作系统会有对内存进行调整</p>
<h2 id="GC-Reload"><a href="#GC-Reload" class="headerlink" title="GC Reload"></a>GC Reload</h2><p>go gc 有一个优化，写屏障；</p>
<p>当垃圾回收的速度跟不上分配的速度怎么办？</p>
<p>go 会拿 25% CPU 时间，超过 25 之后就会让分配慢下来，进行清扫工作</p>
<p>案例：</p>
<p>请求响应不正常，cpu、io、网络都没问题</p>
<p>抓 go 的 trace，发现请求有被 GC 占用了很多时间</p>
<p>即使没有 STW，但是 runtime 还是会让它慢下来</p>
<p>发现扫描了 1G 的内存，但是只是发现只有 8k 被回收</p>
<p>依然会有抖动</p>
<p>*抢占主要解决 for 死循环导致 STW 时间过长的问题</p>
<h2 id="QPS-瓶颈"><a href="#QPS-瓶颈" class="headerlink" title="QPS 瓶颈"></a>QPS 瓶颈</h2><p>在多核下的单一进程，没有多进程绑核来的快</p>
<p>资源没有被耗尽但是还是有瓶颈，CPU 使用率变高了，NUMA</p>
<p>分析：</p>
<p>pprof/mutex 去查了一下，优化了一下</p>
<p>是不是和 NUMA 绑定核心有关？</p>
<p>单个改动的性能提升最大</p>
<p>发现 67% 时间没有在干活</p>
<p>runtime 在页分配器是有锁的，会有锁的争抢，在多核的情况下会遇到</p>
<p>现在的 go 的版本已经优化了</p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p>现在 CPU 核数很多，每个 NUMA 核心上尽量会分配到和自己近的</p>
<p>gc is not numa aware</p>
<p>所以在多核上的调度不是特别</p>
<h1 id="Go-语言编译器简介"><a href="#Go-语言编译器简介" class="headerlink" title="Go 语言编译器简介"></a>Go 语言编译器简介</h1><h2 id="编译器的重要性"><a href="#编译器的重要性" class="headerlink" title="编译器的重要性"></a>编译器的重要性</h2><p>汇编语言无法构建大型系统</p>
<p>计算机复杂度理论</p>
<h3 id="编译器的难题"><a href="#编译器的难题" class="headerlink" title="编译器的难题"></a>编译器的难题</h3><p>将不同的语言增加，需要有不同的机器，将不同的语言编译成不同的机器需要很多任务</p>
<p>简化：</p>
<p>将别的语言编译成 C 然后再编译成别的语言</p>
<p>将别的机器先编译成 x86，然后再编译成目标机器的语言</p>
<h3 id="通用（非专用）编译器方案"><a href="#通用（非专用）编译器方案" class="headerlink" title="通用（非专用）编译器方案"></a>通用（非专用）编译器方案</h3><p>高级语言先生成 AST 然后再 SSA IR 单一静态赋值</p>
<p>基于 SSA 的优化</p>
<p>LLVM</p>
<p>中断接受中间表示进行优化，对每种机器机械能优化</p>
<h2 id="GO-编译工作流程"><a href="#GO-编译工作流程" class="headerlink" title="GO 编译工作流程"></a>GO 编译工作流程</h2><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>将源代码翻译成 AST</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>编译器会进行常量折叠，会将 2*3 → 6</p>
<p>内联：会将 B 函数调用 A 函数的函数方法直接内联到函数内部，为了提高效率</p>
<h3 id="SSR-IR"><a href="#SSR-IR" class="headerlink" title="SSR IR"></a>SSR IR</h3><p>更像汇编语言</p>
<p>赋值，goto，if。。。</p>
<h3 id="中端优化"><a href="#中端优化" class="headerlink" title="中端优化"></a>中端优化</h3><p>公共子表达式消除，将重复运算减少；</p>
<p>运算强度消除，将乘法进行优化成位操作，或者是取余操作替换为&amp;操作</p>
<p>常量折叠：将两次乘法合成一次乘法</p>
<p>-<strong>循环不变量外提</strong>、<strong>将乘法变成加法</strong></p>
<h3 id="后端指令选择"><a href="#后端指令选择" class="headerlink" title="后端指令选择"></a>后端指令选择</h3><p>将 IR 映射到汇编</p>
<h1 id="阿里云-云原生"><a href="#阿里云-云原生" class="headerlink" title="阿里云-云原生"></a>阿里云-云原生</h1><p>go 在云原生中的应用</p>
<h2 id="程序员视角的云原生"><a href="#程序员视角的云原生" class="headerlink" title="程序员视角的云原生"></a>程序员视角的云原生</h2><p>标准化技术，标准化运维</p>
<p>从资源统筹规划，大规模的自动化运维</p>
<p>让云更经济的被用户使用</p>
<p>go 在 CNCF 中占据了很大的部分</p>
<h2 id="插入：策略与机制"><a href="#插入：策略与机制" class="headerlink" title="插入：策略与机制"></a>插入：策略与机制</h2><p>策略是做事的概念和计划，坐火车和坐飞机是一种策略</p>
<p>机制是面向内部实现的，机制是追求稳定和复用</p>
<h2 id="应用管理额策略和机制"><a href="#应用管理额策略和机制" class="headerlink" title="应用管理额策略和机制"></a>应用管理额策略和机制</h2><p>策略：部署策略，负载均衡策略，路由规则，工作负载</p>
<p>直接面向机制很难；</p>
<p>认知成本高，k8s 没有统一的使用方式，我们需要学习复杂的申明字段，各种申明</p>
<p>对开发者很好的使用这个平台，融入云原生</p>
<h2 id="插入：k8s-的核心机制-申明试资源与控制器"><a href="#插入：k8s-的核心机制-申明试资源与控制器" class="headerlink" title="插入：k8s 的核心机制-申明试资源与控制器"></a>插入：k8s 的核心机制-申明试资源与控制器</h2><ol>
<li>控制器：空调控制器</li>
<li>被控制系统：房间温度</li>
<li>期望状态：26 度</li>
<li>管控动作：送冷气降温</li>
<li>当前状态：28 度</li>
</ol>
<p>label 是一等公民：通过它去寻找</p>
<p>事件触发闭环反馈</p>
<p>由很多的控制器组合来完成的</p>
<h2 id="EDAS"><a href="#EDAS" class="headerlink" title="EDAS"></a>EDAS</h2><p>阿里云云原生 PAAS 平台</p>
<p>将所有平台的运维能力，将所有的控制器都部署到了 k8s 的平台；</p>
<h3 id="OAM-应用模型"><a href="#OAM-应用模型" class="headerlink" title="OAM 应用模型"></a>OAM 应用模型</h3><p>open application model 微软和阿里</p>
<p>一个应用是由很多个组件构成，每个组件都有自己的工作负载去描述运行时（有状态/无状态…），有了不同的运维特征</p>
<p>路由策略，基于 QPS 的自动弹性，这些都是运维特征</p>
<p>多个组件可以通过一个作用域来描述，这几个组件的资源限制</p>
<ul>
<li>应用</li>
<li>组件</li>
<li>工作负载</li>
<li>运维特征</li>
<li>作用域</li>
</ul>
<p>组件间依赖</p>
<h3 id="KubeVela"><a href="#KubeVela" class="headerlink" title="KubeVela"></a>KubeVela</h3><p>内置 workloads Traits 和 Scopes</p>
<p>其实还是通过一个控制器模式，将上面模型中的所有资源进行初始化，配置，调度，向上包装一层</p>
<h3 id="新的复杂度-开发模式"><a href="#新的复杂度-开发模式" class="headerlink" title="新的复杂度-开发模式"></a>新的复杂度-开发模式</h3><p>声明试资源的设计，一定要一个终态；</p>
<p>可重构的状态机，期望状态，你状态是可重构的，事件驱动+主动轮询</p>
<p>重试和幂等，自愈</p>
<h3 id="坑-最终一致性"><a href="#坑-最终一致性" class="headerlink" title="坑-最终一致性"></a>坑-最终一致性</h3><p>有一个资源是成功，很多人同时修改，利用 version 和 resoureveriosn 做乐观 observeVersion</p>
<h3 id="可观测的"><a href="#可观测的" class="headerlink" title="可观测的"></a>可观测的</h3><p>如果应用没有到终态，是因为什么原因；</p>
<p>抛出 k8s 的事件和消息</p>
<p>控制器的管控平台，来管控制器的状态</p>
<h2 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h2><p>通过应用模型描述好了，我们只需要提交代码即可</p>
<p>运行时的依赖也标准化</p>
<p>轻量可观测，开发和运维的区别就是观测上的区别</p>
<p>*datr，全部都已 sidecar 的进行封装了</p>
<p>*将噪音在前面就消除，宁愿什么都不动，也不要动错</p>
<h1 id="gorm-剖析和最佳实践"><a href="#gorm-剖析和最佳实践" class="headerlink" title="gorm 剖析和最佳实践"></a>gorm 剖析和最佳实践</h1><h2 id="语句是如何生成的"><a href="#语句是如何生成的" class="headerlink" title="语句是如何生成的"></a>语句是如何生成的</h2><p>基本就是将代码解析成语句</p>
<p>初始化的时候就将不同的数据库版本来生成不同的配置，对于 sql 进行不同的版本生成</p>
<p>hits 对前后进行封装</p>
<p>对于不同的数据库实现都是不一样的</p>
<h2 id="插件支持"><a href="#插件支持" class="headerlink" title="插件支持"></a>插件支持</h2><p>读写分离的支持，加入一些判断</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="0-值问题"><a href="#0-值问题" class="headerlink" title="0 值问题"></a>0 值问题</h3><p>指定字段，通过传入一个 map 也可以</p>
<p>直接指定字段</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>使用 map 或者 struct 去创建</p>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>支持自定义类型就可以支持 json 类型的数据</p>
<h3 id="分页逻辑"><a href="#分页逻辑" class="headerlink" title="分页逻辑"></a>分页逻辑</h3><p>自定义分页逻辑</p>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>支持全局关闭事务</p>
<p>使用 transaction 块</p>
<p>支持事务嵌套，使用安全点实现</p>
<h3 id="字段的权限"><a href="#字段的权限" class="headerlink" title="字段的权限"></a>字段的权限</h3><p>可读，可写，禁止操作等</p>
]]></content>
      <categories>
        <category>GopherChina</category>
      </categories>
      <tags>
        <tag>GopherChina</tag>
      </tags>
  </entry>
  <entry>
    <title>GopherChina2021 个人总结</title>
    <url>/post/5f9b9e64.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今年本来没想着要去的，因为确实有点远，加上疫情之下不太方便，但是意料之外来了一张门票，那就必须去一下了，这次收获也不少，有了上次的经验，这次就听得很舒服，不像上次那样那么累了，这次能准确的知道什么应该仔细听，什么应该略过，所以这次的笔记就相对来说少一些，精炼一点。</p>
<p>这次去也面基了大佬，果然北京的都是大佬，都比我卷的厉害，以后还要多学习，哈哈哈，膜拜膜拜~</p>
<span id="more"></span>
<h2 id="基于-Golang-构建高可扩展的云原生-PaaS-平台"><a href="#基于-Golang-构建高可扩展的云原生-PaaS-平台" class="headerlink" title="基于 Golang 构建高可扩展的云原生 PaaS 平台"></a>基于 Golang 构建高可扩展的云原生 PaaS 平台</h2><p>端点 PaaS 介绍整个历程 主要是推 Erda，主要有以下几点个人觉得可以</p>
<ul>
<li>自定义 pipeline 开箱即用</li>
<li>微服务治理 兼容 java 族（spring 那一套，还有 dubbo）</li>
<li>可观察性数据采集</li>
</ul>
<p>个人总结：写个这的一定是 java 过来的，autowired 很 java 味道</p>
<p><a href="https://github.com/erda-project/erda">https://github.com/erda-project/erda</a></p>
<h2 id="MOSN-云原生演进历程"><a href="#MOSN-云原生演进历程" class="headerlink" title="MOSN 云原生演进历程"></a>MOSN 云原生演进历程</h2><p>MOSN 之前就有听说的，我觉得很像给 Envoy 加个 buff</p>
<ul>
<li>CGO 并没有想的那么性能堪忧</li>
<li>通过 hacker 的方式可以在调用链路中加一层 filter 实现</li>
<li>想办法做到 zero copy 从 c 到 go 时减少内存拷贝，优化 1</li>
<li>从 go 到 c 不能直接返回 go 中的内存，否则当 gc 时会导致 go 侧被回收，c 侧意外访问的问题</li>
<li>非常 hack 的为每个 envoy 预留了 P 从而保证每个 G 来的时候都有 P，改 runtime，可以可以</li>
<li>结构体内存对齐问题，没有细说，但是可以以后也是一个点</li>
</ul>
<p>个人总结：让我之后可以尝试利用 CGO 来完成一些事情了，没有像以前一样那么抗拒它，并且提前知道了很多坑点</p>
<h2 id="浅谈全链路监控-从应用到数据库到-Runtime"><a href="#浅谈全链路监控-从应用到数据库到-Runtime" class="headerlink" title="浅谈全链路监控: 从应用到数据库到 Runtime"></a>浅谈全链路监控: 从应用到数据库到 <strong>Runtime</strong></h2><blockquote>
<p>所有演讲中我学到最多的一个，这个很值</p>
</blockquote>
<p>从两个方面来评价这个：一方面是演讲能力，演讲者思路很清晰，并且可以将你代入整个优化和实现的思路，你好像亲身经历了整个优化过程，并且思路不快，你能很好的跟上，每一步衔接都很讲究；另一方面是整个选题贴近实际，整个实现思路很多是可以再别的地方相同类比的。</p>
<p>所以两个方面都是非常值得去学习的，果然大佬并不仅仅是技术牛，而且演讲能力也是一流。PS：PingCAP 好像每年都是干货。</p>
<ul>
<li><p>描述问题，当前链路追踪的问题有哪些？</p>
</li>
<li><p>现在的开源方案有哪些实现，jaeger 确实挺好用的，基于现有的方案如何改进呢？</p>
</li>
<li><p>其实普通的 trace 对于我们来说足够用了，因为他们是做数据库的 很多时候需要看到数据库内部执行的时候的链路，并非只看到最终执行的 sql 和 sql 执行时间就可以，还需要知道执行内部的链路方法调用等耗时，现在的 trace 没办法</p>
</li>
<li><p>好像数据库是自己写的就有办法</p>
</li>
<li><p>第一个想法就是加 tracerID 然后传递到 tidb 的内核里面</p>
</li>
<li><p>但是显然还不够，还想知道是因为 go 调度的问题还是 sql 本身的问题</p>
</li>
<li><p>于是想到 go tool trace，可以，但是开销大</p>
</li>
<li><p>于是想到 hack runtime，就是改 runtime，前后加代码，可以，但是需要单独维护一个 go 分支</p>
</li>
<li><p>于是想到 pprof，其中有个功能是 profiler label <a href="https://rakyll.org/profiler-labels/">https://rakyll.org/profiler-labels/</a> 这个功能有点黑，可以再你的 pprof 上打标签，之前没有见到过，有了它就能给你就清晰到搞定你需要定制统计的 链路了，只需要将 label 随着 context 传递就可以</p>
</li>
<li><p>全开 pprof 有性能损耗，那就想办法手动减少了采样的时间</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210628234819590.png" alt="image-20210628234819590"></p>
</li>
</ul>
<p>总结一下：整体优化过程就是一个问题的解决过程，中间有着各种思路，有的走了歪路，发现最后实现起来成本太高，有的很 hank，最终找到了合适的思路。整体思路还是通过 context 传递 traceID 来实现整体链路的 trace，并且没有忘记初心。整个思路可以借鉴。</p>
<h2 id="Improving-Go-Backend-Developer-Experience-in-Grab"><a href="#Improving-Go-Backend-Developer-Experience-in-Grab" class="headerlink" title="Improving Go Backend Developer Experience in Grab"></a>Improving Go Backend Developer Experience in Grab</h2><p>因为我之前上一次已经听过一次 Grab 的分享了，这次的分享和上次有点重复，都是介绍在 Grab 里面代码生成和开发是如何的方便，在这不做赘述。</p>
<h2 id="利用夜莺扩展能力打造全方位监控系统"><a href="#利用夜莺扩展能力打造全方位监控系统" class="headerlink" title="利用夜莺扩展能力打造全方位监控系统"></a>利用夜莺扩展能力打造全方位监控系统</h2><p>这个之前我也听过，之前是秦大讲的，讲的很不错。整体夜莺确实对于监控领域来说是一个当前不错的开源解决方案。</p>
<p>我就说我在现场问的问题吧还有别人问的：</p>
<ul>
<li>v3、v4 版本是从 Telegraf 的架构迁移到了 datadog 原因是：有 agent 里面多了 aggregator 这样客户端本地采集就优先对于采集数据做了一次降采样，这样上传的数据更加精炼</li>
<li>udp 端口如何做监控？因为如何直接访问，那么对于 udp 来说会影响业务，以为是别的正常请求，所以直接尝试 bind 这个端口如果说当前端口已经被 bind 则证明 udp 健康</li>
<li>技术难点主要是在采集侧<ul>
<li>不确定的采集策略</li>
<li>异构机型，不同语言</li>
<li>传输压缩编码问题和错误重传问题</li>
</ul>
</li>
</ul>
<p>总结一下：对于我来说更多的是了解了 agent 上的设计思路，对于以后的采集相关的业务需求可能设计上会有新的考虑方式</p>
<h2 id="Golang主动式内存缓存的优化探索之路"><a href="#Golang主动式内存缓存的优化探索之路" class="headerlink" title="Golang主动式内存缓存的优化探索之路"></a>Golang主动式内存缓存的优化探索之路</h2><p>需要一个 极致的性能 内存缓存（当时就让我想到了 google 把大量数据全部放在内存里面来加速搜索…）</p>
<ol>
<li>直接监听 binlog 然后生成 json 格式数据，给 mq，然后 给集群消费，集群也可以全量做同步</li>
<li>建立索引加速查询</li>
<li>冷热数据交换</li>
<li>多级缓存</li>
<li>不同的淘汰策略</li>
<li><strong>千万级内存对象，GC严重耗时，如何解决? 非常 hank 的方式直接将内存转到 c 里面避免 GC，然后通过 CGO 访问这些内存。这个思路真的可以，学到了。MemoryTile 然后在序列化和反序列化的时候定制了一把，即使是复杂的数据结构也可以。</strong></li>
<li>优化链路，调用和下载链路分开，单个节点下载全量然后同步全网其他</li>
<li><strong>json 中的空值直接连 key 一起剔除，减少传输数据，这个也可以学到了。</strong></li>
<li>尽可能将业务数据存放在内存中，做好冷热数据交换</li>
<li>主动监听数据的变化，并实时更新内存中的缓存数据</li>
</ol>
<p>总结一下：利用 cgo 去避免 GC 这个思路之前没有听过，学到了。期待开源。</p>
<h2 id="如何用Go模拟CPU"><a href="#如何用Go模拟CPU" class="headerlink" title="如何用Go模拟CPU"></a>如何用Go模拟CPU</h2><p>利用 go 来实现了一个 CPU 的所有功能</p>
<p>整个演讲告诉我了一个道理：其实 CPU 的架构并没有你想象的那么复杂，它的功能也就是一个循环读取纸带而已~</p>
<p>演讲者有一句话经常提到：原话我忘记了，大概是说，概念都是人提出来的，有了概念才让事情变得复杂，当我们抛弃很多概念的时候事情就会变得简单。所以在整个演讲中，从一开始的没有几个单元，到后面每次追加一个概念，难度就提升不少。</p>
<p>对于硬件知识强大的大佬来说，应该挺有意思的。我嘛，其他听起来就有点难咯。</p>
<p>一开始的 bug 真的是一只飞蛾~</p>
<h2 id="深入理解BFE"><a href="#深入理解BFE" class="headerlink" title="深入理解BFE"></a>深入理解BFE</h2><p>之前也听过 BFE 的演讲，这次主要是  <a href="https://github.com/baidu/bfe-book">https://github.com/baidu/bfe-book</a> 从这里来的。同样也就不过多赘述。</p>
<h2 id="基于Kubernetes的私有云实战"><a href="#基于Kubernetes的私有云实战" class="headerlink" title="基于Kubernetes的私有云实战"></a>基于Kubernetes的私有云实战</h2><p>这个思路是利用 k8s 做个私有云，其实就是利用 k8s 去创建 pod，然后把 pod 做成和虚拟机几乎一模一样</p>
<ul>
<li>使用 FAT 容器，容器本身啥都带了</li>
<li><strong>网络方案使用的是 Macvlan 这个有点意思</strong> 我很想知道 macvlan 的缺点是什么，后面可能会详细出个博客写一下，有点东西（挖坑）</li>
<li>集群方案是在所有 k8s 上套了一层调度层来管理调度，屏蔽 k8s 各类资源</li>
</ul>
<p>遇到的问题</p>
<ul>
<li>go 在容器内可以看到宿主机的 96 核，那会创建过多的 P M 导致调度时间长 （go.uber.org/automaxprocs）</li>
<li>Go不是NUMA友好的 没办法绑核</li>
<li>宿主机负载不均衡，然后自己基于先有的 cpu 调度器改了一个自己的调度器，插上</li>
<li>提问环节问道只能支持无状态的部署，有状态的就不行了</li>
</ul>
<h2 id="Go-如何助力企业进行微服务转型"><a href="#Go-如何助力企业进行微服务转型" class="headerlink" title="Go 如何助力企业进行微服务转型"></a>Go 如何助力企业进行微服务转型</h2><p>将单体和微服务转型的，因为已经是微服务很多年了，当你也是从单体淌水过来的，里面的辛酸对比一清二楚，很有 b 数，毫不夸张，所以就不多说了</p>
<h2 id="字节跳动在-Go-网络库上的实践"><a href="#字节跳动在-Go-网络库上的实践" class="headerlink" title="字节跳动在 Go 网络库上的实践"></a>字节跳动在 Go 网络库上的实践</h2><blockquote>
<p>这个非常非常烧脑，虽然全程跟下来了，但是演讲者速度超快，真的很佩服这种思路清晰脑子好用的大佬，膜拜一下（回答问题的时候也是思路超级清晰）</p>
</blockquote>
<p>主要是由于 go 原生的 net 包不满足需求，所以要做一个，net 包问题是</p>
<ul>
<li>难以探活</li>
<li>BIO 开销大</li>
</ul>
<h3 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h3><p>改造成 netpoll 使用 epoll 改成事件，水平触发</p>
<h3 id="优化调度"><a href="#优化调度" class="headerlink" title="优化调度"></a>优化调度</h3><p>这里的分析很到位，分析出具体的瓶颈是在 read 上而非 handle 上</p>
<p>想办法优化系统调用，直接改 syscall 为 rawSyscall 去掉了 enter_runtime 和 exit_runtime</p>
<p>动态判断 msec 参数，加快调度速度（没事情就别占着位置）</p>
<h3 id="优化-buffer"><a href="#优化-buffer" class="headerlink" title="优化 buffer"></a>优化 buffer</h3><p>当前很多都是 ringbuffer 实现的零拷贝，但是容量有限制，扩容会成为瓶颈</p>
<p>所以使用无锁的 linkbuffer 来实现，syncPool 来复用节点，利用链表解决扩容问题，利用 atomic 解决 datarace </p>
<p>重新实现 readv 和 wirtev</p>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><ul>
<li>单连接多路复用，这个太难了，没听懂….</li>
<li>改了内核，增加了 multisyscall.read 方法将多个读合并为一个操作进行（我也想要一个内核组）</li>
<li>使用 io_uring 做改掉原来的 epoll 实现异步调用</li>
</ul>
<p>总结一下：想办法改 NIO，想尽一切办法优化调度，想尽一切办法优化 buffer，即找到关键瓶颈去做优化；这是我第一次觉得 BIO 和 NIO 模型讲解的如此简单…大佬牛逼</p>
<p>io_uring 后面可以仔细研究（挖坑）</p>
<p>无锁 linkedbuffer 实现可以（挖坑）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次大会我自己明显感觉到和之前那次不一样，之前那次我算是理解并不深入，所以很多东西都需要听，输入量巨大；这次很多知识点都明白了，也就听的很顺利，之前就是讲师提到一个点我记下一个点，现在是提到一个点我就点点头表示已经知道了。</p>
<p>整个大会上还有其他几个讲师的内容也很不错，因为分了 AB 场，所以另外一边没有听到，不过也都是很不错的。</p>
<p>这次主要还是面基到了一起学习的小伙伴，小伙伴都非常厉害，也都非常努力的~ 希望下一次大会也能有幸继续参加吧，不早了洗洗睡了。</p>
]]></content>
      <categories>
        <category>GopherChina</category>
      </categories>
      <tags>
        <tag>GopherChina</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang逃逸分析</title>
    <url>/post/1ceb1a77.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<p>逃逸分析，看着一个非常高大上的名词，很多人第一次听到它的感觉会觉得它好厉害的样子，其实说到底它很好理解，并不复杂。之前一直没有写也是有原因的，因为其实在实际中，我真的很难用上它。这次写也是有原因的，因为有人催更了…其实拖了有一段时间了，最近终于忙完了，开始补债了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210702224531952.png" alt="image-20210702224531952"></p>
<h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><p>在说逃逸分析之前，我们需要有一些前置知识点</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>我们常说的栈是一种数据结构，当然这里说的栈特指我们在谈论内存分配的时候说的栈。它的作用是在函数调用的过程中保存函数的参数局部变量等数据。而且<strong>当函数调用完毕后，它所使用的栈空间将立即释放。</strong>所以它“便宜”。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆的概念我们就应该非常熟悉了，它用来存放很多需要使用的对象，这些对象的生命，在 go 里面是交给 GC 去管理的，当我们再也不使用的时候，<strong>GC 会将它们回收</strong>。所以它“贵”，因为它需要额外的做功才能将它回收掉。</p>
<h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><h4 id="那为什么需要堆？"><a href="#那为什么需要堆？" class="headerlink" title="那为什么需要堆？"></a>那为什么需要堆？</h4><p>不用堆不行吗？其实答案显然不行，因为如果所有的变量对象都在栈上，用完了就扔掉，那么其他人想要再使用的时候就无法使用了。</p>
<h4 id="那全部都在堆上不行吗？"><a href="#那全部都在堆上不行吗？" class="headerlink" title="那全部都在堆上不行吗？"></a>那全部都在堆上不行吗？</h4><p>答案也很显然不行，因为栈便宜，用完就扔，堆很贵，你不能将所有的东西都扔给 GC，这样它要累死。</p>
<h4 id="那对象到底在哪？"><a href="#那对象到底在哪？" class="headerlink" title="那对象到底在哪？"></a>那对象到底在哪？</h4><p>我怎么知道我使用的这个对象应该放在哪里？我再写程序的时候也没有手动去指定要将对象放在哪里鸭！</p>
<p>没错，go 帮我们做了这个事情，它会聪明的去确定，你使用的对象到底应该放在哪里最合适，编译阶段它就会做这个事情。而确定对象在栈上还是堆上的过程就是我们今天的主角 —— 逃逸分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/QQ20210702-232008 2.png" alt="QQ20210702-232008 2"></p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>其实刚才我们就已经知道了，逃逸分析就是帮我们确定，我们所使用的对象应该放在栈上还是堆上。那么我一开始的想法就很直接了，那不是挺简单的吗，如果这个对象在当前函数外面还在用的时候就应该在堆上，如果只在函数里面用，不就在栈上了吗？但是其实情况远远比我想的要复杂许多….</p>
<h3 id="怎么看？"><a href="#怎么看？" class="headerlink" title="怎么看？"></a>怎么看？</h3><p>首先我们必须要有工具来进行逃逸分析，当让 go 提供了这个工具</p>
<p><code>go build -gcflags &#39;-m -l&#39; main.go</code></p>
<p>其中的 -m 就是会打印出逃逸分析的优化策略，可以多加 m 来查看更加详细的信息，其中的 -l 是禁用函数内联以防止内联优化导致无法正确观察到逃逸的情况</p>
<h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bigBytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bigBytes</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>([]<span class="keyword">int64</span>, <span class="number">8192</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(a))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这真的是我见过最让人眼前一亮的逃逸分析的第一个案例，乍一看，啊？这也能逃逸？没错它逃了，这里的 a 逃了。让我们用命令一敲便知。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ go build -gcflags &#x27;-m -l&#x27; main.go</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">./main.go:10:11: make([]int64, 8192) escapes to heap</span><br><span class="line">./main.go:11:13: ... argument does not escape</span><br><span class="line">./main.go:11:17: len(a) escapes to heap</span><br></pre></td></tr></table></figure>
<p>其实原因也很简单，这里的 a slice 太大了，栈放不下了，所以只能放到堆上了</p>
<h2 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h2><p>案例来源：<a href="https://github.com/golang/go/tree/master/test">https://github.com/golang/go/tree/master/test</a></p>
<p>golang 的单元测试肯定包含了大多数出现逃逸情况，情况数量极多，下面举例其中一些</p>
<h3 id="将内部变量作为指针返回"><a href="#将内部变量作为指针返回" class="headerlink" title="将内部变量作为指针返回"></a>将内部变量作为指针返回</h3><p>显然当你作为指针返回后，外部就可能会使用和修改，就必须在堆上，不能随着函数返回就不见了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">i_escapes</span><span class="params">(x <span class="keyword">int</span>)</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	i = x</span><br><span class="line">	<span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在其他协程访问返回值"><a href="#在其他协程访问返回值" class="headerlink" title="在其他协程访问返回值"></a>在其他协程访问返回值</h3><p>这里的 x 在其他协程还在赋值修改它，所以只能在堆上了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defer1</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; x = i; c &lt;- <span class="number">1</span> &#125;()</span><br><span class="line">	&lt;-c</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在其他函数访问返回值"><a href="#在其他函数访问返回值" class="headerlink" title="在其他函数访问返回值"></a>在其他函数访问返回值</h3><p>特别是还有很多一些闭包表达式操作经常会出现逃逸的问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo21</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   x := <span class="number">42</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">// ERROR &quot;func literal escapes to heap$&quot;</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将函数参数用在别的地方"><a href="#将函数参数用在别的地方" class="headerlink" title="将函数参数用在别的地方"></a>将函数参数用在别的地方</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fooleak</span><span class="params">(xx *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// ERROR &quot;leaking param: xx$&quot;</span></span><br><span class="line">   x = xx</span><br><span class="line">   <span class="keyword">return</span> *x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo31</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// ERROR &quot;moved to heap: x$&quot;</span></span><br><span class="line">   <span class="keyword">return</span> fooleak(&amp;x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将-slice-中的某个元素指针返回"><a href="#将-slice-中的某个元素指针返回" class="headerlink" title="将 slice 中的某个元素指针返回"></a>将 slice 中的某个元素指针返回</h3><p>这里 b 中的某个元素在外部被使用了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> save151 *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo151</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123; <span class="comment">// ERROR &quot;leaking param: x$&quot;</span></span><br><span class="line">   save151 = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar151b</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span> <span class="comment">// ERROR &quot;moved to heap: a$&quot;</span></span><br><span class="line">   b := a[:]</span><br><span class="line">   foo151(&amp;b[<span class="number">4</span>:<span class="number">8</span>][<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大-slice-或不确定的-slice"><a href="#大-slice-或不确定的-slice" class="headerlink" title="大 slice 或不确定的 slice"></a>大 slice 或不确定的 slice</h3><p>太大的 slice 无法分配到栈上，而一些无法确定长度的 slice 也无法分配到栈上</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BAD: x need not leak.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doesMakeSlice</span><span class="params">(x *<span class="keyword">string</span>, y *<span class="keyword">string</span>)</span></span> &#123; <span class="comment">// ERROR &quot;leaking param: x&quot; &quot;leaking param: y&quot;</span></span><br><span class="line">	a := <span class="built_in">make</span>([]*<span class="keyword">string</span>, <span class="number">10</span>) <span class="comment">// ERROR &quot;make\(\[\]\*string, 10\) does not escape&quot;</span></span><br><span class="line">	a[<span class="number">0</span>] = x</span><br><span class="line">	b := <span class="built_in">make</span>([]*<span class="keyword">string</span>, <span class="number">65537</span>) <span class="comment">// ERROR &quot;make\(\[\]\*string, 65537\) escapes to heap&quot;</span></span><br><span class="line">	b[<span class="number">0</span>] = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonconstArray</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">32</span></span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)    <span class="comment">// ERROR &quot;make\(\[\]int, n\) escapes to heap&quot;</span></span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, n) <span class="comment">// ERROR &quot;make\(\[\]int, 0, n\) escapes to heap&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 s1 也是会分配到堆上的，因为你不知道这个 slice 会扩容成什么大小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonconstArray</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      s1 = <span class="built_in">append</span>(s1, i)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串作为返回值"><a href="#字符串作为返回值" class="headerlink" title="字符串作为返回值"></a>字符串作为返回值</h3><p>这里的 t 逃逸了，因为字符串作为返回值出去了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringEs</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123; <span class="comment">// ERROR &quot;s does not escape&quot;</span></span><br><span class="line">   t := s + <span class="string">&quot;YYYY&quot;</span>         <span class="comment">// ERROR &quot;escapes to heap&quot;</span></span><br><span class="line">   <span class="keyword">return</span> t <span class="comment">// ERROR &quot;... argument does not escape&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全局变量赋值"><a href="#全局变量赋值" class="headerlink" title="全局变量赋值"></a>全局变量赋值</h3><p>这个很直观，你都赋值给全局变量了那肯定逃逸了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sink <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;</span><br><span class="line">   p1 *<span class="keyword">int</span></span><br><span class="line">   p2 *<span class="keyword">int</span></span><br><span class="line">   a  [<span class="number">2</span>]*<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Y <span class="keyword">struct</span> &#123;</span><br><span class="line">   x X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">field18</span><span class="params">()</span></span> &#123;</span><br><span class="line">   i := <span class="number">0</span> <span class="comment">// ERROR &quot;moved to heap: i$&quot;</span></span><br><span class="line">   <span class="keyword">var</span> x X</span><br><span class="line">   <span class="comment">// BAD: &amp;i should not escape</span></span><br><span class="line">   x.p1 = &amp;i</span><br><span class="line">   <span class="keyword">var</span> iface <span class="keyword">interface</span>&#123;&#125; = x <span class="comment">// ERROR &quot;x does not escape&quot;</span></span><br><span class="line">   y, _ := iface.(Y)         <span class="comment">// Put X, but extracted Y. The cast will fail, so y is zero initialized.</span></span><br><span class="line">   sink = y                  <span class="comment">// ERROR &quot;y escapes to heap&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="atomic-操作"><a href="#atomic-操作" class="headerlink" title="atomic 操作"></a>atomic 操作</h3><p>当然将一些内部变量通过 atomic 操作放到全局变量上，肯定也会逃逸的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">int</span> <span class="comment">// ERROR &quot;moved to heap: x&quot;</span></span><br><span class="line">   atomic.StorePointer(&amp;ptr, unsafe.Pointer(&amp;x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">int</span> <span class="comment">// ERROR &quot;moved to heap: x&quot;</span></span><br><span class="line">   atomic.SwapPointer(&amp;ptr, unsafe.Pointer(&amp;x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// BAD: x doesn&#x27;t need to be heap allocated</span></span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">int</span> <span class="comment">// ERROR &quot;moved to heap: x&quot;</span></span><br><span class="line">   <span class="keyword">var</span> y <span class="keyword">int</span> <span class="comment">// ERROR &quot;moved to heap: y&quot;</span></span><br><span class="line">   atomic.CompareAndSwapPointer(&amp;ptr, unsafe.Pointer(&amp;x), unsafe.Pointer(&amp;y))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>其实逃逸的情况非常多，你完全没有必要去死记硬背的，情况能想到的也就那一些，即使有一些特殊情况，只要你敲下命令自然就出来了。总的来说大多数情况都是由于将内部变量作为返回值或者在其他函数中使用，或者是作为全局变量赋值等等…. </p>
</li>
<li><p>我写这个博客的目的，只是说当你写代码的时候有这样的意识，这样优化的时候会有思路，去调整一些参数，减少一些全局变量的设置等等。</p>
</li>
<li><p>逃逸分析本身并不神奇，神奇的是 go 去实现逃逸分析的代码 cmd/compile/internal/gc/escape. go </p>
</li>
<li><p>最后重点来了：请你暂时忘记它吧，其实大部分的业务场景都用不到它，因为绝大多数的 OOM 并不会简简单单因为你的变量逃逸而出现问题；大部分的 GC 时间长也并非因为逃逸导致；所以请先分析瓶颈，找到关键瓶颈后再进行优化，不要一上来就逃逸分析半天，结果发现加个索引就好了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>逃逸分析</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 CGO - 利用 CGO 使用 C++ STL</title>
    <url>/post/19c0fd4e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前我也了解过 CGO 相关的知识，但是当时给我的印象全部都是 “CGO 性能差” “完全没有必要，实际根本用不到”，但是这次听了大佬的一些分享发现 CGO 其实就是黑科技啊，<strong>有了它你在使用 go 的时候有了更多的想象力</strong>。本文将带你初步了解和使用 CGO，本文只是抛砖头，因为有关 CGO 的文档其实蛮少的，在其中也有很多坑，所以今天来踩一次，不知道会不会留下什么坑….</p>
<blockquote>
<p>有了 CGO，Go 就有机会继承 C/C++近半个世纪的遗产 by  曹大</p>
</blockquote>
<span id="more"></span>
<h2 id="CGO-使用案例分享"><a href="#CGO-使用案例分享" class="headerlink" title="CGO 使用案例分享"></a>CGO 使用案例分享</h2><p> 首先来看一下最近我看到使用 CGO 的两个案例</p>
<h3 id="案例-1-mosn"><a href="#案例-1-mosn" class="headerlink" title="案例 1 mosn"></a>案例 1 mosn</h3><p><img src="https://raw.githubusercontent.com/mosn/mosn/ab4ca053f4d9d907f4a5f9bcf9f30504ba3d142c/pkg/networkextention/docs/mosn-high-performance-network-framework.png" alt="mosn"></p>
<p><a href="https://github.com/mosn/mosn">https://github.com/mosn/mosn</a></p>
<p>其中 mosn 通过 CGO 的能力，想办法在 envoy 后面加了一层，使得其底层网络具备 C 同等的处理能力的同时，又能使上层业务可高效复用 mosn 的处理能力及 go 的高开发效率。</p>
<h3 id="案例-2-主动式缓存"><a href="#案例-2-主动式缓存" class="headerlink" title="案例 2 主动式缓存"></a>案例 2 主动式缓存</h3><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/active-cache.png" alt="active-cache"></p>
<p>这个 GopherChina 上一个学而思网校的分享，主要讲的是如何设计一个主动式内存缓存，其中提到了 Go 的 GC 导致当有大量内存缓存的时候，对象数量过多，GC 扫描的时间会很长，所以将缓存对象存储到 C 中，然后利用 CGO 去访问缓存的对象，因为当对象在 C 中的时候就不参与 GC 了。当时我听到这个思路的时候也是觉得有点意思，原来 CGO 还可以有这样的操作。</p>
<h2 id="理论存在，实践开始"><a href="#理论存在，实践开始" class="headerlink" title="理论存在，实践开始"></a>理论存在，实践开始</h2><h3 id="开胃小菜"><a href="#开胃小菜" class="headerlink" title="开胃小菜"></a>开胃小菜</h3><p>首先先来一个简单 hello world 让你没有用过 CGO 的同学来体验一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.puts(C.CString(<span class="string">&quot;Hello, World\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单，这里有以下几点</p>
<ul>
<li>import C，有了它我们就能通过 C. 来使用 C 的一些方法，还引入了 &lt;stdio.h&gt;</li>
<li>我们通过 C.CString 将 go 的字符串转换为了 c 的 “字符串”</li>
<li>调用 C 里面的 puts 函数打印了这个字符串</li>
</ul>
<p>就是这么简单，一个 CGO 的代码就完成了，有了它你是不是觉得其实 CGO 很简单，可以为所欲为了？NoNo 其实还有下面几点需要注意</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li>类型转换：Golang 里面类型不能拿出来直接给 C 使用，因为底层的存储方式不同，所以必须通过 C.CString 等类似的方法进行转换；同样的，C 返回的类型也无法在 Go 中直接使用，也需要做一次转换，如通过 C.GoString 将 c 的 *char 转换为 go 的 string</li>
<li>内存：C 是没有 GC 的，所以 C 的内存需要手动管理，比如这里构造的字符串，在 C 里面是需要手动释放的，通过 C.free(unsafe.Pointer(s)) 可以进行 free；当然，反过来，当 C 要访问 go 的内存的时候也需要注意，Go 是有 GC 的，而 Go 的 Gc 是不知道当前这个对象在 C 里面是否还有在使用的，所以如果使用不当，C 中访问 go 的对象，这个对象可能已经被 GC 了</li>
<li>性能损失：因为 Go 和 C 有着不同的内存模型和函数调用规约，所以显然在使用 CGO 的时候需要栈的切换工作，那么势必带来这性能的损失</li>
</ol>
<p>其他细节可以还查看   <a href="https://golang.org/cmd/cgo/">https://golang.org/cmd/cgo/</a>   <a href="https://golang.org/src/cmd/cgo/doc.go">https://golang.org/src/cmd/cgo/doc.go</a></p>
<h3 id="正餐"><a href="#正餐" class="headerlink" title="正餐"></a>正餐</h3><p>基于我之前听到的分享案例二，主动式缓存，它想办法在 C 里面开辟了一片新天地，让它绕过了 GO 的 GC 扫描，于是我就想着实践一下，搞一个最小 demo 看看。</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>在 C 里面搞一个 map 当做缓存</li>
<li>Go 通过 CGO 去访问这个 map 进行操作</li>
</ul>
<p>然后之前写 C++ 的时候就经常用到 STL 库嘛，那里面的 map 自然是耳熟能详，所以就想到了如果我能想办法搞定这个 STL 的库势必就能实现这个 demo 了，理论存在，实践开始。</p>
<h4 id="my-map-h"><a href="#my-map-h" class="headerlink" title="my_map.h"></a>my_map.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MmPut</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">const</span> <span class="keyword">char</span>* value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">MmGet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MmDelete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key)</span></span>;</span><br></pre></td></tr></table></figure>
<p>首先定义一个头文件 <code>my_map.h</code>，里面包含三个函数分别是 put，get，delete 对 map 的相关操作</p>
<p>这里解释一下，因为在 C 里面你需要首先给出这个函数的定义，才能在下面使用这个函数并且实现它，所以就需要定这个。</p>
<h4 id="my-map-cpp"><a href="#my-map-cpp" class="headerlink" title="my_map.cpp"></a>my_map.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_map.h&quot;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;string, string&gt; mm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MmPut</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">const</span> <span class="keyword">char</span>* value)</span> </span>&#123;</span><br><span class="line">    mm[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">MmGet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mm[key].<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MmDelete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key)</span> </span>&#123;</span><br><span class="line">    mm.<span class="built_in">erase</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义我们的具体方法 <code>my_map.h</code> 这里写的很粗糙，就直接定义了一个 map 然后对它进行三个操作的实现，其中需要注点的是：</p>
<ol>
<li>STL 库里面的 map 实现是红黑树，有序，这里是偷懒，如果没有必要的话，需要 hashmap 的话可以使用 unordered_map</li>
<li>这里 <code>using namespace std;</code> 也是偷懒，我不想每个都写一遍 <code>std::</code> 懂的都懂</li>
<li>这里使用 <code>char*</code> 作为入参是因为将 go 的字符串转换过来的时候是这个类型</li>
</ol>
<h4 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void MmPut(const char* key, const char* value);</span></span><br><span class="line"><span class="comment">//const char* MmGet(const char* key);</span></span><br><span class="line"><span class="comment">//void MmDelete(const char* key);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   Put2MyMap(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;linkinstar&quot;</span>)</span><br><span class="line">   </span><br><span class="line">   s := GetFromMyMap(<span class="string">&quot;author&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;before delete:&quot;</span>, s)</span><br><span class="line"></span><br><span class="line">   DeleteFromMyMap(<span class="string">&quot;author&quot;</span>)</span><br><span class="line"></span><br><span class="line">   s = GetFromMyMap(<span class="string">&quot;author&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;after delete:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Put2MyMap</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   k := C.CString(key)</span><br><span class="line">   v := C.CString(value)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      C.free(unsafe.Pointer(k))</span><br><span class="line">      C.free(unsafe.Pointer(v))  </span><br><span class="line">   &#125;()</span><br><span class="line">   C.MmPut(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFromMyMap</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   k := C.CString(key)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      C.free(unsafe.Pointer(k))  </span><br><span class="line">   &#125;()</span><br><span class="line">   v := C.MmGet(k)</span><br><span class="line">   value = C.GoString(v)</span><br><span class="line">   <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteFromMyMap</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   k := C.CString(key)</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      C.free(unsafe.Pointer(k))</span><br><span class="line">   &#125;()</span><br><span class="line">   C.MmDelete(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是我们的 GO 代码了，封装了一下三个方法，在 main 中测试一下，完成~</p>
<p>其中需要注意的是之前上面提到的手动 free 对应的内存，输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">before <span class="built_in">delete</span>: linkinstar</span><br><span class="line">after <span class="built_in">delete</span>: </span><br></pre></td></tr></table></figure>
<p>至此我们就最简单的能通过 CGO 使用 STL 库了，那么相对应的，有了这个砖头，那么其他相关的 vector，set….你都可以使用了，甚至可以来个什么 algorithm 的 next_permutation 什么的，想想就有点刺激。</p>
<blockquote>
<p>当然以上只是个 demo，如果需要真的当缓存来用，还有很多需要优化的地方，比如调用过程中减少 key，value 的拷贝，缓存的并发访问等等…..</p>
<p>也有库已经实现一个这样的 map，如果有需要可以尝试进行使用 <a href="https://github.com/glycerine/offheap">https://github.com/glycerine/offheap</a></p>
</blockquote>
<h2 id="总结与延伸"><a href="#总结与延伸" class="headerlink" title="总结与延伸"></a>总结与延伸</h2><p>其实看着代码很容易，但是当我第一次写的时候碰到一堆的问题，一方面是 CGO 的资料不多，代码也不多，所以参考资料比较少，很多代码需要猜测怎么样写，基本上是照猫画虎，用过之后就好了很多了，基本上能知道大体的使用，剩下的就是细节了。</p>
<p>CGO 的使用前提还需要你对 C 有一定的了解，如果完全没有接触过，可能也会觉得比较困难。很期待主动式缓存那个框架实现的开源，这样可以巴拉巴拉它的代码看看它是</p>
<p>那么其实除了 STL 一个特别有意思的事情，<strong>就是 OC，没错 ObjectC</strong>。我们知道 Cocoa 是苹果官方 macOS 出的一个接口，那么其实可以通过 cgo 来调用其中的接口来做一些 macos 原生做的事情，这就非常有意思了。github 上其实有很多相关的库，这里就不再列举了。</p>
<p><a href="https://coderwall.com/p/l9jr5a/accessing-cocoa-objective-c-from-go-with-cgo">https://coderwall.com/p/l9jr5a/accessing-cocoa-objective-c-from-go-with-cgo</a></p>
<p><a href="https://github.com/alediaferia/gogoa">https://github.com/alediaferia/gogoa</a></p>
<p>总的来说，CGO 就像一座桥，不仅让 Go 继承了 C 的遗产，而且<strong>连接更加广阔的空间，给了你更多的想象力</strong>。我觉得它并不是很多人所说的是 C++ 程序迁移到 Go 程序的一个中间态，我觉得它会一直存在，给我们带来更多的黑魔法。</p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>CGO</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 基于角色的权限控制 RBAC</title>
    <url>/post/bfc8f54a.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>RBAC 之所以一直没有写这个，一方面是因为它确实并不复杂，二来平常确实接触不多，今天就来顺路讲讲它</p>
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Role-Based Access Control 我们常说的 RBAC，我们知道在一个后台管理系统里面经常会有权限管理。而最常用的一种权限设计方式就是基于角色的权限设计，A 用户是管理员拥有所有的权限，B 是普通用户角色只有部分权限等等，而 k8s 也是如此，k8s 内部也有许许多多的资源，通过 RBAC 的权限设计进行管理授权工作。</p>
<ul>
<li>Role: 角色，定义了一组对 Kubernetes API 对象的操作权限</li>
<li>Subject: 用户，绑定角色的对象</li>
<li>RoleBinding: 用户和角色的绑定关系</li>
</ul>
<p>其实非常好理解: 用户 -&gt; 角色 -&gt; 权限</p>
<h2 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; 标明 core API 组</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>这就是 k8s 里面的角色，这里定义了一个角色 pod-reader 这个角色可以对 default 命名空间中的 pod 资源进行 get watch list 操作</p>
<h2 id="ClusterRole"><a href="#ClusterRole" class="headerlink" title="ClusterRole"></a>ClusterRole</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># &quot;namespace&quot; 被忽略，因为 ClusterRoles 不受名字空间限制</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="comment"># 在 HTTP 层面，用来访问 Secret 对象的资源的名称为 &quot;secrets&quot;</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>ClusterRole 属于集群范围，所以整个集群对应的资源都可以被使用</p>
<h2 id="RoleBinding"><a href="#RoleBinding" class="headerlink" title="RoleBinding"></a>RoleBinding</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="comment"># 此角色绑定允许 &quot;jane&quot; 读取 &quot;default&quot; 名字空间中的 Pods</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="comment"># 你可以指定不止一个“subject（主体）”</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span> <span class="comment"># &quot;name&quot; 是区分大小写的</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="comment"># &quot;roleRef&quot; 指定与某 Role 或 ClusterRole 的绑定关系</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span> <span class="comment"># 此字段必须是 Role 或 ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span>     <span class="comment"># 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>
<p>有了角色自然就是将用户绑定到对应的角色上去了，这个没有什么好说的，很容易理解</p>
<h2 id="ClusterRoleBinding"><a href="#ClusterRoleBinding" class="headerlink" title="ClusterRoleBinding"></a>ClusterRoleBinding</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="comment"># 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 secrets</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager</span> <span class="comment"># &#x27;name&#x27; 是区分大小写的</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>
<p>同样的 ClusterRoleBinding 也是类似</p>
<h2 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h2><p>其实 User 不多，其实我们更多的使用 k8s 里的内置用户也就是 ServiceAccount，这个 ServiceAccount 会生成一个 secrets 利用这个可以跟 APIServer 进行交互</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">mynamespace</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-sa</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-rolebinding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">mynamespace</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-sa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">mynamespace</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">mynamespace</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sa-token-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">example-sa</span></span><br></pre></td></tr></table></figure>
<p>通过 serviceAccountName 指定对应的 ServiceAccount 就可以使用了</p>
<h2 id="通过-client-go-来使用"><a href="#通过-client-go-来使用" class="headerlink" title="通过 client-go 来使用"></a>通过 client-go 来使用</h2><p>如果只是上面那样有点空，也有点虚，不如直接开官网文档来的快。下面就直接使用实际的案例来看看 rbac 到底是怎么样作用的。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们的目标是创建一个用户，然后绑定对应的权限，有了对应的权限之后，创建的对应的 deployment 使用对应的用户，然后获取到对应的资源，我们使用 client-go 直接获取对应的资源信息看看。</p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>这里我们使用 ClusterRole，并且直接绑定已有的角色 cluster-admin， 然后创建需要使用的 ServiceAccount</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">my-namespace</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">my-namespace</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br></pre></td></tr></table></figure>
<h3 id="一个简单的-client-go-应用"><a href="#一个简单的-client-go-应用" class="headerlink" title="一个简单的 client-go 应用"></a>一个简单的 client-go 应用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;context&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">   metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">   <span class="string">&quot;k8s.io/client-go/kubernetes&quot;</span></span><br><span class="line">   <span class="string">&quot;k8s.io/client-go/rest&quot;</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Uncomment to load all auth plugins</span></span><br><span class="line">   <span class="comment">// _ &quot;k8s.io/client-go/plugin/pkg/client/auth&quot;</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Or uncomment to load specific auth plugins</span></span><br><span class="line">   <span class="comment">// _ &quot;k8s.io/client-go/plugin/pkg/client/auth/azure&quot;</span></span><br><span class="line">   <span class="comment">// _ &quot;k8s.io/client-go/plugin/pkg/client/auth/gcp&quot;</span></span><br><span class="line">   <span class="comment">// _ &quot;k8s.io/client-go/plugin/pkg/client/auth/oidc&quot;</span></span><br><span class="line">   <span class="comment">// _ &quot;k8s.io/client-go/plugin/pkg/client/auth/openstack&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   config, err := rest.InClusterConfig()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;all namespaces: &quot;</span>)</span><br><span class="line">   nsList, err := clientset.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, item := <span class="keyword">range</span> nsList.Items &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%s &quot;</span>, item.Name)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;all deployments in default namespace: &quot;</span>)</span><br><span class="line">   deployments, err := clientset.AppsV1().Deployments(<span class="string">&quot;default&quot;</span>).List(context.TODO(), metav1.ListOptions&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, item := <span class="keyword">range</span> deployments.Items &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%s &quot;</span>, item.Name)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们的应用运行在 k8s 内部，所以使用 client-go 非常容易，使用 rest.InClusterConfig() 就可以获取到对应配置</p>
<p>只要当前 deployment 有对应的权限，就可以获取到对应的资源 pod 或者 namespace 等</p>
<h3 id="创建-deployment"><a href="#创建-deployment" class="headerlink" title="创建 deployment"></a>创建 deployment</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">rabc-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">my-namespace</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">rabc-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">rabc-test</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">rabc-test</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rabc-test</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">linkinstars.com/rabc-test:latest</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure>
<p>创建 deployment 使用 serviceAccountName 指定刚才创建的 ServiceAccount admin 这里需要注意缩进，它是 template 下的 spec 的一个属性</p>
<p>运行后查看日志则可以获取到对应的所有的 namespace 列表和 default 下的所有 deployment</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>对于 k8s 的 rbac 其实使用还是非常简单的，基本上没有必要单独去记，用到的时候需要创建对应权限角色的时候查询对应的文档使用就可以了。</p>
</li>
<li><p>而当我们有了对应权限之后就可以在 k8s 内部的应用使用 client-go 去获取对应的 k8s 的资源信息，并且还可以对相应的资源进行操作，这样就大大的丰富了你开发 k8s 原生应用的想象力</p>
</li>
</ul>
<p>参考文档：<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/">https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 部署 prometheus</title>
    <url>/post/69ddaf77.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>看到很多部署 prometheus 到 k8s 集群的教程，发现都是非常麻烦的各种配置，懒人的我就想整个一键部署的，开箱即用的，既然有了 helm 那肯定只要一个 charts 就可以搞定了吧，想着就是这样，所以在网上找来找去，终于被我发现了。下面记录一下使用过程，方便以后进行部署。</p>
<blockquote>
<p>PS: 本文适用于开发者单 k8s 集群部署 prometheus，如果是运维可建议进行独立部署，一方面不需要占用集群内部资源并保证多活，另一方面可以支持多集群扩展。</p>
</blockquote>
<span id="more"></span>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm 添加对应 repo</span></span><br><span class="line">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> helm 安装 可以添加参数 --<span class="built_in">set</span> rbacEnable=<span class="literal">true</span>，-n 指定安装的 namespace</span></span><br><span class="line">helm install prometheus prometheus-community/kube-prometheus-stack -n monitoror</span><br></pre></td></tr></table></figure>
<h2 id="默认用户名密码"><a href="#默认用户名密码" class="headerlink" title="默认用户名密码"></a>默认用户名密码</h2><p>admin/prom-operator</p>
<p>也可以通过下面的命令进行查看</p>
<p><code>kubectl get secret --namespace &lt;YOUR-NAMESPACE&gt; prometheus-grafana -o jsonpath=&quot;&#123;.data.admin-password&#125;&quot; | base64 --decode ; echo</code></p>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210721180351209.png" alt="image-20210721180351209"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210721180302468.png" alt="image-20210721180302468"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210721180203931.png" alt="image-20210721180203931"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>直接部署在 k8s 内部的 prometheus 能很容易获取到 k8s 中各种指标和参数，使用 helm 部署也非常方便，基本一个命令就搞定了</p>
<p>但毕竟只能从外部监控，那么势必只能获取到 pod 的 cpu 和 memory 的使用情况，如何需要监控对应应用使用的内部情况，那就势必需要应用本身去暴露 matrix 接口并接入</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/prometheus-community/helm-charts">https://github.com/prometheus-community/helm-charts</a></p>
<p><a href="https://github.com/prometheus/prometheus">https://github.com/prometheus/prometheus</a></p>
<p><a href="https://dev.to/kaitoii11/deploy-prometheus-monitoring-stack-to-kubernetes-with-a-single-helm-chart-2fbd">https://dev.to/kaitoii11/deploy-prometheus-monitoring-stack-to-kubernetes-with-a-single-helm-chart-2fbd</a></p>
<p>多集群部署参考：<a href="https://www.servicemesher.com/blog/prometheus-monitor-k8s-1/">https://www.servicemesher.com/blog/prometheus-monitor-k8s-1/</a></p>
]]></content>
      <categories>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>让你最快上手 go 的 pprof 性能分析大杀器</title>
    <url>/post/a2e80cee.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前言，发现一直没有记录过 pprof 分析的博客，其实在实际的业务场景中已经使用它很多次了，对于性能分析来说它真的是一大杀器，基本上有了它，80% 的性能问题都能被一目了然。每次出现性能问题，总是下面几个步骤，测试环境开 pprof，启动，流量重放，火焰图生成，一看，仔细分析一下，问题就浮于水面。</p>
<p>今天来用最简单的一个案例，来让你快速上手 pprof，所以本博客包含以下内容</p>
<ul>
<li>最快能让你用上 pprof</li>
<li>能让你最快学会认识火焰图</li>
<li>学会了之后其他剩下的功能你就可以慢慢自己摸索了</li>
</ul>
<span id="more"></span>
<p>废话不多直接上案例</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>首先你肯定有 go 环境，需要看火焰图还需要安装 graphviz <a href="http://www.graphviz.org/download/">http://www.graphviz.org/download/</a></p>
<blockquote>
<p>第一个坑来了，如果 mac 使用 brew install graphviz 安装容易出现失败，还有很多奇怪的依赖如 svn java 等，所以建议使用 sudo port install graphviz 安装</p>
</blockquote>
<h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210724163218760.png" alt="image-20210724163218760"></p>
<p>使用一些监控软件发现问题，如当前我发现有一个项目在刚启动之后，其他相同类似的项目 cpu 使用都是 20 多，但是它有 40 多（虽然很少了，但是相较于其他先相同服务来说太多了）想知道为什么，所以想来分析一下。</p>
<h2 id="pprof-代码使用"><a href="#pprof-代码使用" class="headerlink" title="pprof 代码使用"></a>pprof 代码使用</h2><p>pprof 需要你再代码里面主动声明开启</p>
<h3 id="没有使用-web-框架的项目"><a href="#没有使用-web-框架的项目" class="headerlink" title="没有使用 web 框架的项目"></a>没有使用 web 框架的项目</h3><p>如果你的项目没有使用任何 web 框架的话，可以使用如下方式开启</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中加入</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>pprof 包中有 init 函数，会主动注册相关路由，只要你监听对应一个端口，则可以使用了</p>
<p>访问 : <a href="http://127.0.01:8080/debug/pprof/">http://127.0.01:8080/debug/pprof/</a></p>
<h3 id="使用-web-框架的项目"><a href="#使用-web-框架的项目" class="headerlink" title="使用 web 框架的项目"></a>使用 web 框架的项目</h3><p>因为你的项目使用了 web 框架，所以默认的引入方式没办法注册到你自己创建的路由上，所以需要使用一些特殊手段，这里以 gin 框架举例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/gin-contrib/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中加入</span></span><br><span class="line">r := gin.New()</span><br><span class="line">pprof.Register(r)</span><br></pre></td></tr></table></figure>
<p>其实里面的代码也很简单，就是将 pprof 暴露的 handler 包装了一下，将对应的路由注册上就可以，其他相关的 web 框架也应该都有类似的方案</p>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210724163815236.png" alt="image-20210724163815236"></p>
<p>首先你查看之后会有这样一个页面，上面的一些基本信息你就能看到了，最长使用的就是 goroutine 和 heap 了，能很好的看到每个 goroutine 在干嘛，堆里面有哪些东西等等。</p>
<h2 id="pporf-命令行使用"><a href="#pporf-命令行使用" class="headerlink" title="pporf 命令行使用"></a>pporf 命令行使用</h2><p>这里没有什么花里胡哨的各种命令，直接说最简单最常使用的火焰图（还有 top 等其他命令可以查看对应文档学习）</p>
<p><code>go tool pprof http://127.0.0.1:8080/debug/pprof/profile</code></p>
<p>然后耐心等待 30s 左右会生成对应的 cpu 使用采样文件</p>
<p>Fetching profile over HTTP from <a href="http://127.0.0.1:8080/debug/pprof/profile">http://127.0.0.1:8080/debug/pprof/profile</a><br>Saved profile in /Users/linkinstar/pprof/pprof.orders.samples.cpu.001.pb.gz</p>
<blockquote>
<p>如果相关分析的是内存而不是 cpu 则需要将地址 <a href="http://127.0.0.1:8080/debug/pprof/profile">http://127.0.0.1:8080/debug/pprof/profile</a>  修改为 -&gt; <a href="http://127.0.0.1:8080/debug/pprof/heap">http://127.0.0.1:8080/debug/pprof/heap</a></p>
</blockquote>
<p>会弹出一个命令行交互程序输入 help 可以查看相关命令</p>
<p>新开一个命令行窗口：</p>
<p><code>go tool pprof -http=:8081 /Users/linkinstar/pprof/pprof.orders.samples.cpu.001.pb.gz</code></p>
<p>后面的路径为上面生成的采样文件的路径</p>
<p>然后你就能到一个 web 界面了</p>
<blockquote>
<p>Ps: 当然你也可以将两个命令合成为一个命令进行使用，如 <code>go tool pprof -http=:8081 127.0.0.1:8080/debug/pprof/heap</code></p>
</blockquote>
<h2 id="火焰图如何看"><a href="#火焰图如何看" class="headerlink" title="火焰图如何看"></a>火焰图如何看</h2><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210724164906547.png" alt="image-20210724164906547"></p>
<p>首先从 view 中选择 flame graph</p>
<p>然后你就能看到火焰图了，一开始看可能会有点懵，不要紧，告诉你三点，然后就很简单了：</p>
<ol>
<li>看横轴最长的：横着占用最长的，就是 cpu 占用最多的（如果你看的是内存，则是内存占用最多的）</li>
<li>看纵轴最长的：纵轴表示的是函数调用栈，从上到下就是函数 a 调用函数 b 调用函数 c… 纵轴越长调用栈越长</li>
<li>鼠标移到对应横轴最长的，然后点击，即可慢慢继续分析了</li>
</ol>
<h3 id="当前案例分析"><a href="#当前案例分析" class="headerlink" title="当前案例分析"></a>当前案例分析</h3><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210724164932166.png" alt="image-20210724164932166"></p>
<p>当前我们看到这个生成的火焰图中横轴最长的就是 resolveServiceFromConsul 方法</p>
<p>显然就是这个方法占用了很多 cpu 资源，那么就很清楚了，去代码里面看，这个方法在干什么，原来是 consul 和各个注册微服务的消息交互导致。问题不大。</p>
<h3 id="对比图分析"><a href="#对比图分析" class="headerlink" title="对比图分析"></a>对比图分析</h3><p>可以通过 –base 参数对比两个采样数据 <code>tool pprof -http=:9999 --base ./heap.1 heap.2</code></p>
<h2 id="常用-pprof-命令总结"><a href="#常用-pprof-命令总结" class="headerlink" title="常用 pprof 命令总结"></a>常用 pprof 命令总结</h2><p>下面是干货分享，总结了一些最常用的 pprof 的命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载 cpu profile 默认从当前开始收集30s的cρu使用情况, 需要等待3θs</span></span><br><span class="line">go tool pprof http://127.0.0.1:8080/debug/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># wait 120s</span></span><br><span class="line">go tool pprof http://127.0.0.1:8080/debug/pprof/profile?seconds=120</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 heap profile</span></span><br><span class="line">go tool pprof http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载特定类型的heap</span></span><br><span class="line">go tool pprof -sample_index=alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof --inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较base</span></span><br><span class="line">go tool pprof -base pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz pprof.demo.alloc_objects.alloc_ space.inuse_objects.inuse_space.002.pb.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 goroutine profile</span></span><br><span class="line">go tool pprof http://127.0.0.1:8080/debug/pprof/goroutine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 block profile</span></span><br><span class="line">go tool pprof http://127.0.0.1:8080/debug/pprof/block</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 mutex profile</span></span><br><span class="line">go tool pprof http://127.0.0.1:8080/debug/pprof/mutex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在浏览器里交互</span></span><br><span class="line">go tool pprof --http=:8080 ~/Downloads/LinkinStar/profile</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>pprof 还有很多其他功能，这里是最快的入门方式，让你快速能领略这个工具分析的方法，使用其实非常简单，不过显然实际出现问题没有那么简单，有时候经常会出现 cpu 占用最多的是 runtime 的代码，或者有一些内存泄露的分析需要细细排查原因，如果你没有用起来的话，赶紧上吧！</p>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>pprof</tag>
      </tags>
  </entry>
  <entry>
    <title>go 中没怎么用过的 sync.Map</title>
    <url>/post/8e25dde4.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们知道 golang 的 map 并发会有问题，所以 go 官方在 sync 包中加入了一个 sync.map 来作为一个官方的并发安全的 map 实现。</p>
<p>如果你了解过 java 中常用的一个并发安全的 map 叫做 <code>ConcurrentHashMap</code> 就会知道它有两个亮点设计：一是当链表长度过长的时候会转换为红黑树的实现，还有一个就是分段锁。得益于这两个设计也导致 java 中实现的代码非常复杂，偷笑。</p>
<p>那么 go 里面是如何设计的呢？今天我们就来看看它是怎么实现的。</p>
<p>PS: 本文 go 源码基于版本1.16.2，我觉得当有了泛型之后这个库十有八九是要改的….</p>
<span id="more"></span>
<h2 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readOnly is an immutable struct stored atomically in the Map.read field.</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">   m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">   <span class="comment">// 注意这个标志，这个翻译为修改过的，如果为 true 表示 dirty 和 read 是不一致的了</span></span><br><span class="line">   amended <span class="keyword">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An entry is a slot in the map corresponding to a particular key.</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">   p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它的数据结构非常简单</p>
<ul>
<li>mu: dirty 操作所需要使用的锁</li>
<li>read: 里面存储的数据只读</li>
<li>dirty: 最新的数据，但是需要加锁访问</li>
<li>misses: 读取 miss 计数器</li>
</ul>
<p>刚看到这个数据结构的时候，就可以猜测一下，通过这个命名，感觉像是这样的：读写分离，读取全部从 read 中读取；修改操作记录在 dirty 中，然后当 miss 达到一个指标后进行 dirty 和 read 的交换；当然这是猜测，让我们往下看看源码实现。</p>
<h2 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 首先从 read 中获取，因为 read 只读，所以不加锁</span></span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   e, ok := read.m[key]</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果从 read 没有获取到，则需要验证 amended 标志是否为true</span></span><br><span class="line">   <span class="comment">// 如果 amended 为true，则证明 read 和 dirty 不一致，则需要从 dirty 中获取</span></span><br><span class="line">   <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      m.mu.Lock()</span><br><span class="line">      <span class="comment">// double check 因为当加锁之后，可能 read 的数据已经修改，所以需要再次验证</span></span><br><span class="line">      read, _ = m.read.Load().(readOnly)</span><br><span class="line">      e, ok = read.m[key]</span><br><span class="line">      <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">         <span class="comment">// 从 dirty 中获取</span></span><br><span class="line">         e, ok = m.dirty[key]</span><br><span class="line">         <span class="comment">// 注意获取之后需要增加 misses 标志数值，证明这次 read 没读到，是从 dirty 中获取的</span></span><br><span class="line">         m.missLocked()</span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果 dirty 中也没有那么就是没有这个键对应的值</span></span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果一开始已经从 read 中获取到，那么直接 load 就可以了</span></span><br><span class="line">   <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">   <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 misses 标志数值达到了 dirty 的长度，那么就需要将 dirty 赋值给 read，让 read 存储最新的数据</span></span><br><span class="line">    <span class="comment">// 并且把 dirty 清空，misses 标志数值清零</span></span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>优先读取 read</li>
<li>read 没有就看 dirty 和 read 是否一致</li>
<li>不一致就从 dirty 中读取</li>
<li>每次 miss 增加 miss 数值，当 miss 数值到达 dirty 长度的时候就重新将 dirty 赋值给 read</li>
</ol>
<blockquote>
<p>这里利用到了一个常用的并发操作，double check，因为验证和加锁并不是一个原子操作，所以需要二次确认，加锁之后是否还满足原来的加锁条件</p>
</blockquote>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 先从 read 中获取，如果存在则尝试直接修改，注意这里的修改是一个原子操作，并且判断了这个 key 是否已经被删除</span></span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()</span><br><span class="line">   <span class="comment">// double check</span></span><br><span class="line">   read, _ = m.read.Load().(readOnly)</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">      <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">         <span class="comment">// The entry was previously expunged, which implies that there is a</span></span><br><span class="line">         <span class="comment">// non-nil dirty map and this entry is not in it.</span></span><br><span class="line">         <span class="comment">// 这里比较难理解一点：</span></span><br><span class="line">         <span class="comment">// 如果加锁之后，read 能获取到，并且被标记为删除，则认为 dirty 肯定不为空，并且这个 key 不在 dirty 中，所以需要在 dirty 中添加这个 key</span></span><br><span class="line">         m.dirty[key] = e</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 然后将 value 值更新到 entry 中</span></span><br><span class="line">      e.storeLocked(&amp;value)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">      <span class="comment">// 如果 read 中还是不存在，但是 dirty 中存在，则直接更新</span></span><br><span class="line">      e.storeLocked(&amp;value)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果read，dirty都没有，则是一个新的 key</span></span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">         <span class="comment">// We&#x27;re adding the first new key to the dirty map.</span></span><br><span class="line">         <span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line">         <span class="comment">// 如果之前 read 没有被修改过，则需要初始化 dirty</span></span><br><span class="line">         m.dirtyLocked()</span><br><span class="line">         <span class="comment">// 并且需要更行 read 为 已经被修改过</span></span><br><span class="line">         m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 此时 dirty 已经被初始化过了，直接添加新的 key 就可以了</span></span><br><span class="line">      m.dirty[key] = newEntry(value)</span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryStore</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">      <span class="comment">// 如果这个键已经被删除了，则直接返回</span></span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果还存在，则直接修改，利用 cas 原子操作</span></span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">unexpungeLocked</span><span class="params">()</span> <span class="params">(wasExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="comment">// 注意这里有一个细节，需要验证是否已经被删除，如果已经被删除无需要添加到 dirty 中</span></span><br><span class="line">        <span class="comment">// 并且内部将 nil 的 entry 设置为 expunged</span></span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储的时候相对复杂一些：</p>
<ol>
<li>如果 read 中存在则直接尝试更新</li>
<li>如果 read 中不存在则加锁</li>
<li>double check</li>
<li>如何二次确认时已经 read 中存在则需要判断是否已经被删除，如果已经删除需要在 dirty 中加回来</li>
<li>如果二次确认 read 中不存在，则查看 dirty 中是否存在， 如果存在直接更新</li>
<li>如果 read 和 dirty 中都不存在，则是一个新的 key</li>
<li>如果 dirty 还没有被初始化，则先初始化</li>
<li>最后更新 dirty 即可</li>
</ol>
<p>需要把握的细节是：</p>
<ul>
<li>read 和 dirty 可能不一致，dirty 有就可以操作</li>
<li>double check 之后 key 也有可能被删除</li>
</ul>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 如果 read 中没有，就尝试去 dirty 中找</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// 这里也是 double check</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 反正只要 dirty 中有就直接操作就好了</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            <span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></span><br><span class="line">            <span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span><br><span class="line">            <span class="comment">// map.</span></span><br><span class="line">            <span class="comment">// 这里是细节需要增加 miss 的计数，因为这里本质也是一个 load 操作， LoadAndDelete 嘛</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 read 中有，就直接操作就好了</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里上面的所有删除操作都是直接 cas 交换为 nil，并不是很多人说的标记为 expunged，expunged 是在 read 重新赋值个 dirty 初始化的时候才进行的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除比较简单</p>
<ol>
<li>如果 read 中存在则直接操作</li>
<li>如果 read 中不存在则需要去 dirty 中找</li>
<li>删除的时候只需要设置为 nil 就可以了</li>
</ol>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">      m.mu.Lock()</span><br><span class="line">      read, _ = m.read.Load().(readOnly)</span><br><span class="line">      <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">         <span class="comment">// 如果有修改过，那么 dirty 中的数据才是最新的，所以需要重新赋值给 read 然后读取</span></span><br><span class="line">         read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">         m.read.Store(read)</span><br><span class="line">         m.dirty = <span class="literal">nil</span></span><br><span class="line">         m.misses = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      v, ok := e.load()</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解了前面几个方法，range 就很简单了，就只需要知道如果已经修改过的时候需要遍历的是 dirty 的，因为 dirty 才是最新的</p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>那么 sync.map 的设计原理是什么呢？其实非常简单：</p>
<ul>
<li>读写分离，读取大多数情况下会直接读 read 不需要加锁</li>
<li>懒更新，删除标记一下不需要额外操作其他数据结构</li>
</ul>
<p>所以整体设计真的非常简单易懂，没有复杂的数据结构，当然这样的设计其实性能上并不会满足所有情况的要求</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>其实我实际在很多代码中更多的时候看到的是，使用 sync.Mutex 或者 RWMutex 来实现的，如：<a href="https://blog.golang.org/maps#TOC_6">https://blog.golang.org/maps#TOC_6</a>. 一方面我 sync.Map 使用起来必须进行 interface 转换，代码写起来比较麻烦，还需要额外进行封装一层；还有就是当前性能还没有那么极致的追求，所以很多时候也够用。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li>读多写少的场景</li>
<li>多个goroutine读/写/修改的key集合没有交集的场景</li>
<li>压测后 sync.Map 确实能带来性能提升的场景</li>
</ol>
<p>其他场景其实个人也并不建议去使用</p>
<h3 id="为什么-go-不采用类似-java-的实现"><a href="#为什么-go-不采用类似-java-的实现" class="headerlink" title="为什么 go 不采用类似 java 的实现"></a>为什么 go 不采用类似 java 的实现</h3><p>其实肯定有人已经尝试过了 <a href="https://github.com/orcaman/concurrent-map">https://github.com/orcaman/concurrent-map</a> 但是不采纳的原因也很简单，go 官方一直秉承的就是 less is more 他们很多地方都认为简单一点是好事，一旦复杂了，就会变得原来越难以维护。其实个人认为还是等待泛型的出现，否则轮子要重新造一次，有点累。</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>sync.Map</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S之CNI</title>
    <url>/post/47a7987b.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前我们解决了跨主机间容器间通信的问题，但是这也只能说我们铺好了路，村里通路了，但是其实作为 k8s 来说，还有好多其他的问题等待着我们解决。今天我们就通过这些问题来看看 k8s 的 CNI 的设计。CNI 到底究竟是个什么东西，到底是不是和你想的一样那么困难。</p>
<span id="more"></span>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="IP-分配"><a href="#IP-分配" class="headerlink" title="IP 分配"></a>IP 分配</h3><p>我们知道 k8s 整个集群里面有许多的 pod 那么 IP 怎么分配呢？总不能分配着之后出现 IP 冲突了吧。k8s 集群里面是不是能不有一个类似 DHCP 的东西来管这个 IP 地址分配呢？</p>
<h3 id="流量转发"><a href="#流量转发" class="headerlink" title="流量转发"></a>流量转发</h3><p>当流量打到宿主机上时，应该有一个什么设备来快速将请求转到对应的 pod 才对吧？那么谁来做这个事情呢？</p>
<p>那为了解决上面的问题，我们一步步出发。</p>
<h2 id="k8s-网络模型"><a href="#k8s-网络模型" class="headerlink" title="k8s 网络模型"></a>k8s 网络模型</h2><p>首先有关 k8s 的网络模型，官网有下面的描述：（<a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/）">https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/）</a></p>
<ul>
<li>节点上的 Pod 可以不通过 NAT 和其他任何节点上的 Pod 通信</li>
<li>节点上的代理（比如：系统守护进程、kubelet）可以和节点上的所有Pod通信</li>
</ul>
<p>备注：仅针对那些支持 <code>Pods</code> 在主机网络中运行的平台（比如：Linux）：</p>
<ul>
<li>那些运行在节点的主机网络里的 Pod 可以不通过 NAT 和所有节点上的 Pod 通信</li>
</ul>
<p>也就是说所谓的 cni 实现必须满足这样的网络模型才可以，那么 CNI 究竟要做啥呢？</p>
<h2 id="k8s-创建一个-pod-的具体过程"><a href="#k8s-创建一个-pod-的具体过程" class="headerlink" title="k8s 创建一个 pod 的具体过程"></a>k8s 创建一个 pod 的具体过程</h2><p>要说清楚 CNI 那就得从 pod 的创建的具体步骤来说了：</p>
<ol>
<li>调用 CRI 创建 Pod 内的容器</li>
<li>第一个创建的容器是 pause：它就是一个永远阻塞的程序，作用就是占用一个 network namespace（目的就是先 hold 住这个 namespace），另一个作用是“收割”僵尸进程</li>
<li>创建其他用户需要的容器：共享之前 pause 创建的 network namespace，但是不初始化网络协议栈</li>
<li>创建容器网络设备并初始化：<strong>这就是 CNI 要做的</strong>，初始化 pause 的网络设备，也就是 pause 的 eth0 并分配 IP，pod 其他容器就是使用这个 IP 和其他容器通信的</li>
</ol>
<h2 id="CNI-到底是什么❓"><a href="#CNI-到底是什么❓" class="headerlink" title="CNI 到底是什么❓"></a>CNI 到底是什么❓</h2><p>我们知道了 CNI 要做的事情，以及 CNI 在模型中所处的位置，那么它究竟是什么呢？</p>
<p>CNI 全称 Container Networking Interface 容器网络接口，它其实就是一个接口，抽象了 k8s 网络操作的实现。</p>
<p>那么接口是什么样子的呢？</p>
<ul>
<li><code>AddNetwork(net *NetworkConfig, rt* RuntimeConf)(types.Result, error)</code> 创建网络</li>
<li><code>DelNetwork(net *NetworkConfig, rt* RuntimeConf)</code> 删除网络</li>
</ul>
<p>其中 ADD 操作的含义是：把容器添加到 CNI 网络里；DEL 操作的含义则是：把容器从 CNI 网络里移除掉。</p>
<p>而对于网桥类型的 CNI 插件来说，这两个操作意味着把容器以 Veth Pair 的方式“插”到 CNI 网桥上，或者从网桥上“拔”掉。</p>
<h2 id="CNI-插件如何使用"><a href="#CNI-插件如何使用" class="headerlink" title="CNI 插件如何使用"></a>CNI 插件如何使用</h2><p>我们以 flannel 插件为例，部署起来其实非常的方便，就只需要</p>
<p> <code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code> </p>
<p>就可以了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodSecurityPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">psp.flannel.unprivileged</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">seccomp.security.alpha.kubernetes.io/allowedProfileNames:</span> <span class="string">docker/default</span></span><br><span class="line">    <span class="attr">seccomp.security.alpha.kubernetes.io/defaultProfileName:</span> <span class="string">docker/default</span></span><br><span class="line">    <span class="attr">apparmor.security.beta.kubernetes.io/allowedProfileNames:</span> <span class="string">runtime/default</span></span><br><span class="line">    <span class="attr">apparmor.security.beta.kubernetes.io/defaultProfileName:</span> <span class="string">runtime/default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">configMap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">secret</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">emptyDir</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hostPath</span></span><br><span class="line">  <span class="attr">allowedHostPaths:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pathPrefix:</span> <span class="string">&quot;/etc/cni/net.d&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pathPrefix:</span> <span class="string">&quot;/etc/kube-flannel&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pathPrefix:</span> <span class="string">&quot;/run/flannel&quot;</span></span><br><span class="line">  <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">false</span></span><br><span class="line">  <span class="string">........................................................................................</span></span><br><span class="line"><span class="string">....................................................................</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-flannel-cfg</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">node</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">flannel</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">cni-conf.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;name&quot;: &quot;cbr0&quot;,</span></span><br><span class="line"><span class="string">      &quot;cniVersion&quot;: &quot;0.3.1&quot;,</span></span><br><span class="line"><span class="string">      &quot;plugins&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;flannel&quot;,</span></span><br><span class="line"><span class="string">          &quot;delegate&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;hairpinMode&quot;: true,</span></span><br><span class="line"><span class="string">            &quot;isDefaultGateway&quot;: true</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;portmap&quot;,</span></span><br><span class="line"><span class="string">          &quot;capabilities&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;portMappings&quot;: true</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span>  <span class="attr">net-conf.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span></span><br><span class="line"><span class="string">      &quot;Backend&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;Type&quot;: &quot;vxlan&quot;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-flannel-ds</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">node</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">flannel</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">flannel</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">node</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">flannel</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/os</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">system-node-critical</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">flannel</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install-cni</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">quay.io/coreos/flannel:v0.14.0</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cp</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-f</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/kube-flannel/cni-conf.json</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/cni/net.d/10-flannel.conflist</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cni</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/cni/net.d</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flannel-cfg</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/kube-flannel/</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kube-flannel</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">quay.io/coreos/flannel:v0.14.0</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/opt/bin/flanneld</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--ip-masq</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kube-subnet-mgr</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;100m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;50Mi&quot;</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;100m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;50Mi&quot;</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">capabilities:</span></span><br><span class="line">            <span class="attr">add:</span> [<span class="string">&quot;NET_ADMIN&quot;</span>, <span class="string">&quot;NET_RAW&quot;</span>]</span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">run</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/run/flannel</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flannel-cfg</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/kube-flannel/</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">run</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/run/flannel</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cni</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/etc/cni/net.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flannel-cfg</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">kube-flannel-cfg</span></span><br></pre></td></tr></table></figure>
<p>我省略了其中有关 rabc 相关的资源，其实最重要的就是两个</p>
<ul>
<li>kube-flannel-cfg：这是个 configmap 记录了 flannel 的配置，注意其中 net-conf.json 的 Backend.Type 字段，用于标识当前 flannel 使用的是什么模式</li>
<li>kube-flannel-ds：这是个 DaemonSet 所以每个节点都会有一个，它就是传说中我们的 flanneld 进程</li>
</ul>
<p>所以现在 flannel 的部署使用是非常的简单了</p>
<h2 id="为什么需要设计-CNI？"><a href="#为什么需要设计-CNI？" class="headerlink" title="为什么需要设计 CNI？"></a>为什么需要设计 CNI？</h2><p>那为什么 k8s 不自己搞个方案让我们用就好了，非要设计成接口让我们自己找方案呢？</p>
<p>很简单，因为各有所需。下面举例两个方案</p>
<h3 id="flannel-的-Host-Gateway-模式"><a href="#flannel-的-Host-Gateway-模式" class="headerlink" title="flannel 的 Host Gateway 模式"></a>flannel 的 Host Gateway 模式</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>我们知道 flannel 即使用了 vxlan 虽然比 udp 好了不少，但是还是存在瓶颈，因为你必须有一个封包和拆包的过程，而 host-gw 就是为了优化这个问题而来的。</p>
<p>host gateway 顾名思义就是拿宿主机作为网关，所以它的原理其实非常简单：</p>
<ol>
<li>容器 A 内发包到 cni0</li>
<li>cni 的 IP 匹配到 hostA 上的路由规则直接发送到 hostB</li>
<li>hostB 的 eth0 收到后，根据 hostB 上的路由表转发到 hostB 上的 cni0</li>
<li>最终 cni0 将包转发到对应的容器 B</li>
</ol>
<p>重点来了，其实在 host-gw 模式下，需要在宿主机上维护一个路由表，flannel 此时就是不断的监听 etcd 中对应子网的变化，将对应子网的下一跳写到对应的路由表中即可。</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>因为使用路由表下一跳来设置的时候目标的时候是根据 mac 地址来找的，也就是设定的是下一跳宿主机的 mac 地址，而 mac 地址在二层网络是管用的，所以 <strong>host-gw 模式必须要求集群宿主机之间是二层连通的</strong></p>
<p>实际中经常会出现两个宿主机在不同的 vlan 下，或者在不同的机房等等可能。</p>
<h3 id="Calico-的-BGP"><a href="#Calico-的-BGP" class="headerlink" title="Calico 的 BGP"></a>Calico 的 BGP</h3><p>Calico 是一个基于 BGP 的纯三层的数据中心网络方案（<strong>BGP 就是在大规模网络中实现节点路由信息共享的一种协议。</strong>）题外话：说实话 BGP 这个词在大学学计算机网络的时候你应该听过，我对它的印象也是源于此。下面这张图是 Calico 官网找的架构图，我找资料的时候发现显然最新的 Calico 已经多了很多东西了 （<a href="https://docs.projectcalico.org/reference/architecture/overview）">https://docs.projectcalico.org/reference/architecture/overview）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/architecture-calico.svg" alt="architecture-calico"></p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>flannel 的 host-gw 模式是会在宿主机上维护一个路由表，那么讲道理来说，如果能有一个路由器来代替掉这个路由表的功能其实就可以了？对，其实很简单，Calico 的 BGP 简单的说就是在本机上模拟了一个类似路由器的功能来实现的。</p>
<p>它有几个重要的组件</p>
<p>Felix： 是一个 DaemonSet ，负责刷新主机路由规则和 ACL 规则等</p>
<p>BgpClient：读取 Felix 编写的路由信息，将这些路由信息分发到集群的其他工作节点上</p>
<p>Bgp Route Reflector：路由器反射器，简单来说，在网络规模大的时候如果单台机器就要维护全网的路由信息太难了，所以中间加入了 Route Reflector 协助去管理网络，BGP Client 只需要连接它就可以了</p>
<p>由于 Calico 是一种纯三层的实现，因此可以避免与二层方案相关的数据包封装的操作，中间没有任何的 NAT，没有任何的overlay，所以它的转发效率可能是所有方案中最高的，因为它的包直接走原生TCP/IP的协议栈，它的隔离也因为这个栈而变得好做。因为TCP/IP的协议栈提供了一整套的防火墙的规则，所以它可以通过IPTABLES的规则达到比较复杂的隔离逻辑。</p>
<p>其次<strong>它不会在宿主机上创建任何网桥设备</strong>，Calico 的 CNI 插件会为每个容器设置一个 Veth Pair 设备，然后把其中的一端放置在宿主机上（它的名字以 cali 前缀开头）</p>
<h4 id="网络拓扑图"><a href="#网络拓扑图" class="headerlink" title="网络拓扑图"></a>网络拓扑图</h4><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/cailico-arch.png" alt="cailico-arch"></p>
<p>这次懒了，不想自己画了，网上找了一个，说一下链路吧</p>
<ol>
<li>从 node1 中的 podA（1.2.3.4） 想要访问 node2 中的 podB（5.6.7.8）</li>
<li>首先 CNI 会为 podA 和 podB 创建 Veth Pair 一端插在 pod 里面，一端插在主机上，所以从 podA 中出来就走到了 cali.001上</li>
<li>接着由于 BIRD 会将网络中的路由信息同步并记录到对应的路由表中，所以要访问对应的 pod 就知道走哪里了，走到了宿主机的网卡上</li>
<li>然后重点来了，中间的网络路由是通过 BGP 协议实现的，并且其中如果有部署 Route Reflector 会通过它来中转路由信息</li>
<li>最后到达 node2 中，然后接着走类似的链路从而访问到 podB</li>
</ol>
<p>总的来说，Calico 完全是利用了路由规则去实现的组网，利用宿主机协议栈去确保容器之间跨主机的连通性，没有 overlay，没有 NAT，相对的转发效率也比较高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然 k8s 的 CNI 实现还有很多方案，各个网络方案都有自己的特点，而我们更多的时候选择一个合适的 flannel 或许就可以了，而关键在于我们需要明白它究竟帮助我们做了什么事情。网络这个东西，很多时候并不只是通就可以，还有很多性能、安全…的需求，不同的需求需要不同的网络方案去实现，而这也就是为什么 k8s 将设计 CNI 的原因，将网络的实现方案抽象，从而满足不同的使用场景。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.projectcalico.org/reference/architecture/overview">https://docs.projectcalico.org/reference/architecture/overview</a></p>
<p><a href="https://k-grundy.medium.com/project-calico-kubernetes-integration-overview-a3a860cd974e">https://k-grundy.medium.com/project-calico-kubernetes-integration-overview-a3a860cd974e</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s-cni</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S之跨主机通信</title>
    <url>/post/43a15dd1.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>你是否之前看过 k8s 的网络部分，第一次看是否会觉得很困难？或者说你有没有想过为什么 k8s 要这样设计它的网络，<strong>跨主机之间的网络通信究竟是怎么实现的？</strong>今天就来搞一篇干货，其实想写这个很久了，但是一直拖延症，这次正好碰到了一个新的点想让我仔细重新审视一下。</p>
<p>本文可能需要你有以下知识基础：</p>
<ul>
<li>docker基本原理</li>
<li>k8s基本架构</li>
<li>网络基础知识</li>
</ul>
<p>本文不想引出过多细节的概念，因为网络本身确实有很多细节，每一个细节其实都可以写一篇，如果篇幅过长就会让人觉得没有重点，于是本文的重点将会放在从外部的大视角来看<strong>跨主机的网络通信</strong>，其中的细节先挖坑，后面慢慢填。</p>
<span id="more"></span>
<h2 id="引子问题"><a href="#引子问题" class="headerlink" title="引子问题"></a>引子问题</h2><p>我们知道 k8s 往往会有很多主机进行集群的部署，k8s 要管理很多 pod，而这些 pod 里面有很多容器，每个容器都是一个小的服务，服务与服务之间往往需要互相访问，而 pod 并不总是在同一宿主机上，那么问题来了：k8s 是如何做到让服务之间能够互相访问的呢？这里网络的链路到底是怎么走的？</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210820002120656.png" alt="image-20210820002120656"></p>
<p>时刻记住，本文将围绕这个问题展开。</p>
<h3 id="假设和思考"><a href="#假设和思考" class="headerlink" title="假设和思考"></a>假设和思考</h3><p>如果说每个容器都绑定一个宿主机的端口来进行通信，那么一旦容器很多就要占用非常多的宿主机的端口，这样肯定不合适。看来要解决这个大问题，我们要一步步来，先拆分问题然后一步步思考。</p>
<h2 id="问题-1：如何解决同一台物理机上两个容器之间的通信问题"><a href="#问题-1：如何解决同一台物理机上两个容器之间的通信问题" class="headerlink" title="问题 1：如何解决同一台物理机上两个容器之间的通信问题"></a>问题 1：如何解决同一台物理机上两个容器之间的通信问题</h2><p>先把问题的规模变小，想想同一台物理机上的两个容器之间应该是如何通信的。<strong>我们可以把两个容器看做是两个实际的主机</strong>，那么两台主机要通信，如果直接两台主机之间直接连网线可以吗？显然不行，中间至少要个路由器或者交换机对吧，所以容器也是一样的。</p>
<p><em>那么我现在就需要两个设备，“网线”、“交换机/路由器”</em></p>
<h3 id="Veth-Pair"><a href="#Veth-Pair" class="headerlink" title="Veth Pair"></a>Veth Pair</h3><p>首先认识 <code>Veth Pair</code> 设备，veth 是虚拟一台网卡(Virtual Ethernet) 的缩写，它总是成对出现，就如同我们生活中的网线一样连接着两边的设备。它经常就用作跨 namespace 通信（这里的 namespace 不是 k8s 的 namespace，而是 linux 的 network namespace）</p>
<h3 id="docker0"><a href="#docker0" class="headerlink" title="docker0"></a>docker0</h3><p>我们知道 Linux 中有 bridge 也就说我们常说的网桥，它的作用就好像生活中的交换机。任意的设备都可以连接上去，而且有多个端口，数据可以从任意端口进来，然后根据 mac 地址到对应的端口出去。而 <code>docker0</code> 就是这样一个网桥</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210820002204449.png" alt="image-20210820002204449"></p>
<h2 id="问题-2：如何解决容器访问外网"><a href="#问题-2：如何解决容器访问外网" class="headerlink" title="问题 2：如何解决容器访问外网"></a>问题 2：如何解决容器访问外网</h2><p>第一个问题解决了，这个问题就不难了。因为我们正常在一个主机上想要访问外网只需要通过网卡，也就常见的 eth0 这样的。所以在容器访问的时候也是一样:</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210820002243425.png" alt="image-20210820002243425"></p>
<h2 id="问题解决了吗？"><a href="#问题解决了吗？" class="headerlink" title="问题解决了吗？"></a>问题解决了吗？</h2><p>那么理论上来说只要能访问外网就能访问别的宿主机，但是访问别的宿主机里面的容器呢？</p>
<p>我们来看看路能不能通</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210820002313977.png" alt="image-20210820002313977"></p>
<p>其实问题已经很明显了，问题就在于外部的设备并没有办法知道其他宿主机的容器的 ip 和对应 mac 地址的配置。我要访问 172.16.2.101 这个容器，但是外部的交换机只认宿主机的 ip，我不知道这个 ip 是对应的那个一个，所以没有办法帮你路由到对应的宿主机上，那怎么办？</p>
<p><strong>这时就引出了我们今天的主角 Overlay Network 网络</strong></p>
<h2 id="Overlay-Network"><a href="#Overlay-Network" class="headerlink" title="Overlay Network"></a>Overlay Network</h2><p>我们称底层的物理网络为 underlay，然后如果我们通过某种手段在<strong>这个网络之上再叠加一层网络</strong>，那么我们就可以称叠加在这之上的是 overlay network。</p>
<p>那么我们如何理解这里的叠加呢？</p>
<p>我们知道网络中传输的是打包好的一个个网络包，数据通过不同层的协议封装之后得到。而 overlay network 其实简单理解就是<strong>在原有的协议包装之上，再包装了一次</strong>，而这些额外的包装信息就可以让发送端和接收端认识彼此。</p>
<p>如果你不理解，可以先记下，等下面看完之后回过来再想想。</p>
<h3 id="Flannel-的实现"><a href="#Flannel-的实现" class="headerlink" title="Flannel 的实现"></a>Flannel 的实现</h3><p>Flannel 项目是 CoreOS 公司主推的容器网络方案，它有好多的实现方式，为了解决的问题就是跨主机网络的问题。它将是我们入手的第一件兵器。</p>
<h4 id="UDP-模式"><a href="#UDP-模式" class="headerlink" title="UDP 模式"></a>UDP 模式</h4><p>首先我们来看看 UDP 模式的 Flannel 是如何实现的。这里我们引入一个 flannel0 设备，它是一个 TUN 设备，工作在三层的虚拟网络设备。<strong>它的功能：在操作系统内核和用户应用程序之间传递 IP 包。</strong></p>
<p>然后让我们直接上图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210820004421597.png" alt="image-20210820004421597"></p>
<p>如图所示，IP 包走的路线如下：</p>
<ol>
<li>从容器 1 开始发送</li>
<li>然后通过 veth pair 走到了 docker0 网桥</li>
<li>然后 docker0 网桥发送给了 flannel0 设备（flannel 在宿主机配置了对应的路由规则）</li>
<li>flannel0 就会将 IP 包交给 flanneld 进程（这里原来是内核态的网络调用栈上，然后切换到了用户态的 Flannel 进程）</li>
<li>然后 flanneld 进程通过 eth0 网卡发送到对面的宿主机（这里的路由规则是根据在 etcd 中保存的子网和宿主机的关系）同样的这里这次发送是从用户态切换到了内核态</li>
<li>Node2 上的 flanneld 进程监听 8285 端口，收到之后进行拆包，然后依次丢给下面的 flannel0</li>
<li>….</li>
</ol>
<p>所以其实它的关键就是通过 flannel 作为一个包装器和拆包器，发送的时候进行包装，然后在对面进行拆包，并且 flannel 维护了子网和宿主机的关系，其实它又扮演了一层路由器的作用，它知道哪个子网对应哪个宿主机，所以就能正确的进行发送</p>
<h5 id="它的问题"><a href="#它的问题" class="headerlink" title="它的问题"></a>它的问题</h5><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210820004443496.png" alt="image-20210820004443496"></p>
<p>从这个图上就很明显：发送时，一个 IP 包必须先从内核态切换到用户态，然后再从用户态切换到内核态，这很显然导致就导致了性能问题，于是就提出了 VXLAN 模式。</p>
<h4 id="VXLAN-模式"><a href="#VXLAN-模式" class="headerlink" title="VXLAN 模式"></a>VXLAN 模式</h4><p>VXLAN 全称是 <code>Virtual eXtensible Local Area Network</code>，虚拟可扩展的局域网。它是一种 overlay 技术，通过三层的网络来搭建虚拟的二层网络。</p>
<blockquote>
<p><em>A framework for overlaying virtualized layer 2 networks over lay 3 networks.</em></p>
</blockquote>
<p>下面说说其中几个重要概念</p>
<ul>
<li>VTEP（VXLAN Tunnel Endpoints）：vxlan 网络的边缘设备，用来进行 vxlan 报文的处理（封包和解包）。vtep 可以是网络设备（比如交换机），也可以是一台机器（比如虚拟化集群中的宿主机）</li>
<li>VNI（VXLAN Network Identifier）：VNI 是每个 vxlan 的标识，是个 24 位整数，一共有 2^24 = 16,777,216（一千多万），一般每个 VNI 对应一个租户，也就是说使用 vxlan 搭建的公有云可以理论上可以支撑千万级别的租户</li>
<li>Tunnel：隧道是一个逻辑上的概念，在 vxlan 模型中并没有具体的物理实体想对应。隧道可以看做是一种虚拟通道，vxlan 通信双方（图中的虚拟机）认为自己是在直接通信，并不知道底层网络的存在。从整体来说，每个 vxlan 网络像是为通信的虚拟机搭建了一个单独的通信通道，也就是隧道</li>
</ul>
<p>有了 UDP 的认识，其实它就很好理解了，VTEP 的作用就和 flanneld 的作用类似，也是进行 IP 包的封装和解封，但是因为 VXLAN 就是内核中的一个模块，所以省掉了内核态到用户态相互切换的过程</p>
<p>但是相对应的问题也就来了，既然是内核中的一个模块，我怎么知道对面我需要访问的 VTEP 设备的 MAC 地址是什么呢？那就是 ARP 开始表现的时候了。</p>
<blockquote>
<p>在每台节点启动时把它的 VTEP 设备对应的 ARP 记录，直接下放到其他每台宿主机上。</p>
</blockquote>
<p>但是这样还不够，我就算知道了 MAC 地址，我不知道宿主机 IP 也是没有用的。所以还是得依赖 flanneld，需要从它的 FDB 转发数据库中找到对应的 mac 地址对应的宿主机 IP。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210820005306857.png" alt="image-20210820005306857"></p>
<p>这里的路径和之前类似我就不多说了</p>
<h4 id="如何包装"><a href="#如何包装" class="headerlink" title="如何包装"></a>如何包装</h4><p>然后我们来看看包装的 IP 包大概长什么样子，其实没有想象中的那么复杂。最外面还是目标主机的 IP 和 MAC 地址，因为这个包还是在网络中传输的，所以这个部分肯定会包装上，然后就是 UDP 的头部和 VXLAN 的头部信息了，最后不能忘记我们还需要目的的 VTEP 的 mac 地址和最终我们需要访问的容器 IP 地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210820005229969.png" alt="image-20210820005229969"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们之前说的都是 docker 下的情况，那么在 k8s 中呢？其实就是将 docker0 网桥换成了 cni 网桥而已，默认叫 cni0，这下是不是所有的都能串起来了。下面总结一下几个要点：</p>
<ol>
<li>容器之间跨主机的通信的主要难点在于我不知道你在哪</li>
<li>通过协议的封装就可以实现 Overlay 的网络</li>
<li>网络协议的本质就是封装</li>
</ol>
<p>当然对于 k8s 要解决的网络问题当然还不止这些，当前我们只是解决了通不通的问题；当然还有为什么 k8s 需要设计 CNI，为什么不用 docker 那一套就可以了？后面的问题挖个坑，有空了我继续填。</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>k8s-network</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 使用 rabbitmq 延迟队列</title>
    <url>/post/65c8999.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>你在实际业务中是否有遇到过下面这样的场景：</p>
<ol>
<li>订单十分钟没有支付，自动取消</li>
<li>用户注册成功后无任何操作，一天后自动提醒</li>
<li>预定票之后，在出发之前的一天自动提醒用户</li>
</ol>
<p>这样类似的场景经常会发生在实际的业务中，它们总有一个共性，就是当前并不是马上触发，而是需要过一段时间才进行触发，当触发时间到达时才进行具体的执行。那么问题就来了，为了实现这样的功能，我们如何更加灵活的实现呢？</p>
<span id="more"></span>
<h2 id="为什么使用延迟队列"><a href="#为什么使用延迟队列" class="headerlink" title="为什么使用延迟队列"></a>为什么使用延迟队列</h2><p>我们以 <em>订单十分钟过期</em> 场景举例：</p>
<ul>
<li><p>方案 1：为当前订单创建一个定时器，定时器时间到了之后自动去查询当前订单状态，如果没有支付，则进行取消操作</p>
</li>
<li><p>方案 2：设定一个总的定时器，每一分钟检查一次，当检查发现过期的订单就直接进行取消操作</p>
</li>
<li><p>方案 3：如果你有一个延迟队列，你只需将任务丢进去，等到了对应的时间，这个任务会出队，然后出队的时候进行订单过期时间判断</p>
</li>
</ul>
<h3 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h3><p>正所谓抛弃场景谈方案都是耍流氓：我的观点也很明确，这三种方案都有自己所试用的场景。</p>
<h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h4><p>如果全局只有一个用户，并且这个订单又是那种量比较小的，可能每天有个 30 个已经撑死了，这样的后台的系统，可能都谈不上需要高可用的情况，那么方案一的简单实现就足够了。</p>
<p>方案 1 的优点是时间肯定是准的，问题也很明显，使用了过多的定时器会使得系统压力变大，并且肯定有单点问题；当然可以搞个分布式定时任务调度….搞个 cronjob 也能做，</p>
<h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案 2"></a>方案 2</h4><p>这个方案可谓是经常被使用了，虽然看着不太优雅，但是实现简单，大多数简单场景其实用它也够了；但是它也有一个最大的问题，就是时间不准，很有可能到了对应的时间还没有轮到检查，就还没有过期，所以对于时间要求比较高的情况就不能使用了。当然你也可以缩小检查的时间间隔，但是同样的就会增加 系统的压力。</p>
<h3 id="方案-3"><a href="#方案-3" class="headerlink" title="方案 3"></a>方案 3</h3><p>看似这个方案是一个最优雅的解决方案，确实，不得不承认，如何有这样一个队列的话，那么不仅可以解决时间不准的问题，也可能解决压力的问题。但是这个方案的问题就是需要单独维护这个队列了，如果这个队列是个单点，那么出问题一样凉凉。</p>
<h2 id="如何使用延迟队列"><a href="#如何使用延迟队列" class="headerlink" title="如何使用延迟队列"></a>如何使用延迟队列</h2><p>分析完了使用场景，进入我们今天的主角，我们在 golang 里面如何使用 rabbitmq 构建这样的一个延迟队列</p>
<h3 id="如果让你来实现"><a href="#如果让你来实现" class="headerlink" title="如果让你来实现"></a>如果让你来实现</h3><p>首先考虑一下如果让你自己来实现你会怎么做？下面是个人的想法：</p>
<p>那么首先这个队列并不是一个简单的队列了，应该是一个以时间为 key 的小顶堆，每一个任务来了之后都按时间排序入堆。</p>
<p>然后不停的判断堆顶元素是否满足条件，如果满足条件则出堆。</p>
<p>这样的设计就好像 golang timer 的旧版本设计类似（挖个坑有机会写一篇 golang timer 分析）</p>
<h3 id="rabbitmq-要如何使用"><a href="#rabbitmq-要如何使用" class="headerlink" title="rabbitmq 要如何使用"></a>rabbitmq 要如何使用</h3><p>我们知道 mq 可不就是消息从一端发送，另一端进行接收嘛，那要如何实现延迟呢？</p>
<p>首先要引入一个概念：死信队列，当我们的发送的消息被接收端nck或reject，消息在队列的存活时间超过设定的 TTL，消息数量超过最大队列长度，这样的消息会被认为是死信（“dead letter”）通过配置的死信交换机这样的死信可以被投递到对应的死信队列中</p>
<p>没错，你会发现第二个条件就是实现一个延迟队列的关键。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20210919173419547.png" alt="image-20210919173419547"></p>
<ul>
<li>我们将需要延迟的消息设定需要延迟的时间，也就是这个消息的最大存活时间（TTL），然后发送到普通队列中</li>
<li>然后因为普通队列中没有消费者，所以只有静静的等待消息超时</li>
<li>消息超时后，经过死信交换机，发送到对应的死信队列中</li>
<li>我们只需要消费对应死信队列中的消息即可认为当前消息对应的任务已经到了应该执行的时间了</li>
</ul>
<h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><p>我一开始也是这样想的，一切看起来很完美对不对？然后现实并不是那么简单。</p>
<p>举例来说，如果当前队列中为 A -&gt; B -&gt; C</p>
<ul>
<li>A：过期时间为 1 分钟</li>
<li>B：过期时间为 5 分钟</li>
<li>C：过期时间为 10 分钟</li>
</ul>
<p>而如果只是按照上面的方式实现，那么因为它毕竟还是一个队列，只有当 C 过期了之后，出队了之后才轮到 B 和 A</p>
<p>也就是说，即使你已经过期了，但是因为你排在后面，还是轮不到你先出队，也就没有办法到死信队列了。</p>
<blockquote>
<p>所以这也就是为什么我一开始想着实现的时候，这并不是一个队列，而是一个堆的实现，因为过期早的其实应该排到前面去才对。</p>
</blockquote>
<h3 id="那咋办"><a href="#那咋办" class="headerlink" title="那咋办"></a>那咋办</h3><p>别慌，有插件的支持 <a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> <strong>rabbitmq_delayed_message_exchange</strong></p>
<p>只需要安装了插件，这个功能就能实现了，有关这个插件的安装比较简单，这里不多做介绍。（我采用的是 docker 部署，所以直接挂载到对应的目录，并指定启用对应的插件并重启就可以了）</p>
<h2 id="golang-实现连接"><a href="#golang-实现连接" class="headerlink" title="golang 实现连接"></a>golang 实现连接</h2><h3 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h3><p>发送者的实现就很简单了，就和普通的发送实现几乎一致，因为反正就是投递到对应的队列中就可以了，只需要将发送消息的部分，在消息的 header 中加入 <code>x-delay</code> 字段表示当前消息的 TTL 就可以了，也就是设定延迟时间，<strong>注意单位为毫秒</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> producer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"> <span class="string">&quot;errors&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Config 链接配置</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line"> Addr, Exchange, Queue, RoutingKey <span class="keyword">string</span></span><br><span class="line"> AutoDelete                        <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer rabbitmq 生产者</span></span><br><span class="line"><span class="keyword">type</span> Producer <span class="keyword">struct</span> &#123;</span><br><span class="line"> conn       *amqp.Connection</span><br><span class="line"> Channel    *amqp.Channel</span><br><span class="line"> Queue      amqp.Queue</span><br><span class="line"> config     Config</span><br><span class="line"> done       <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line"> connErr    <span class="keyword">chan</span> error</span><br><span class="line"> channelErr <span class="keyword">chan</span> *amqp.Error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewProducer 创建生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProducer</span><span class="params">(config Config)</span> *<span class="title">Producer</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;Producer&#123;</span><br><span class="line">  config:     config,</span><br><span class="line">  done:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">  connErr:    <span class="built_in">make</span>(<span class="keyword">chan</span> error),</span><br><span class="line">  channelErr: <span class="built_in">make</span>(<span class="keyword">chan</span> *amqp.Error),</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect 链接到 MQ 服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Producer)</span> <span class="title">Connect</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> err error</span><br><span class="line"> <span class="keyword">if</span> c.conn, err = amqp.Dial(c.config.Addr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> c.Channel, err = c.conn.Channel(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  _ = c.Close()</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// watching tcp connect</span></span><br><span class="line"> <span class="keyword">go</span> c.WatchConnect()</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close to close remote mq server connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Producer)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> <span class="built_in">close</span>(c.done)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> !c.conn.IsClosed() &#123;</span><br><span class="line">  <span class="keyword">if</span> err := c.conn.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   logger.Error(<span class="string">&quot;rabbitmq producer - connection close failed: &quot;</span>, err)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish 发送消息至mq</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Producer)</span> <span class="title">Publish</span><span class="params">(body []<span class="keyword">byte</span>, delay <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> publishing := amqp.Publishing&#123;</span><br><span class="line">  ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">  Body:        body,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> delay &gt;= <span class="number">0</span> &#123;</span><br><span class="line">  publishing.Headers = amqp.Table&#123;</span><br><span class="line">   <span class="string">&quot;x-delay&quot;</span>: delay,</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> err := c.Channel.Publish(c.config.Exchange, c.config.RoutingKey, <span class="literal">true</span>, <span class="literal">false</span>, publishing)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  target := &amp;amqp.Error&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> errors.As(err, target) &#123;</span><br><span class="line">   c.channelErr &lt;- target</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   c.connErr &lt;- err</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PublishJSON 将对象JSON格式化后发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Producer)</span> <span class="title">PublishJSON</span><span class="params">(body <span class="keyword">interface</span>&#123;&#125;, delay <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> data, err := json.Marshal(body); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c.Publish(data, delay)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WatchConnect 监控 MQ 的链接状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Producer)</span> <span class="title">WatchConnect</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ticker := time.NewTicker(<span class="number">30</span> * time.Second) <span class="comment">// every 30 second</span></span><br><span class="line"> <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> err := &lt;-c.connErr:</span><br><span class="line">   logger.Errorf(<span class="string">&quot;rabbitmq producer - connection notify close: %s&quot;</span>, err.Error())</span><br><span class="line">   c.ReConnect()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> err := &lt;-c.channelErr:</span><br><span class="line">   logger.Errorf(<span class="string">&quot;rabbitmq producer - channel notify close: %s&quot;</span>, err.Error())</span><br><span class="line">   c.ReConnect()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">   c.ReConnect()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> &lt;-c.done:</span><br><span class="line">   logger.Debug(<span class="string">&quot;auto detect connection is done&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReConnect 根据当前链接状态判断是否需要重新连接，如果连接异常则尝试重新连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Producer)</span> <span class="title">ReConnect</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> c.conn == <span class="literal">nil</span> || (c.conn != <span class="literal">nil</span> &amp;&amp; c.conn.IsClosed()) &#123;</span><br><span class="line">  logger.Errorf(<span class="string">&quot;rabbitmq connection is closed try to reconnect&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err := c.Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   logger.Errorf(<span class="string">&quot;rabbitmq reconnect failed: %s&quot;</span>, err.Error())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   logger.Infof(<span class="string">&quot;rabbitmq reconnect succeeded&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者部分主要是需要声明正确的交换机类型和对应的队列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> consumer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;os&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RabbitConsumer rabbitmq 消费者</span></span><br><span class="line"><span class="keyword">type</span> RabbitConsumer <span class="keyword">struct</span> &#123;</span><br><span class="line"> conn          *amqp.Connection</span><br><span class="line"> channel       *amqp.Channel</span><br><span class="line"> connNotify    <span class="keyword">chan</span> *amqp.Error</span><br><span class="line"> channelNotify <span class="keyword">chan</span> *amqp.Error</span><br><span class="line"> done          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> addr          <span class="keyword">string</span></span><br><span class="line"> exchange      <span class="keyword">string</span></span><br><span class="line"> queue         <span class="keyword">string</span></span><br><span class="line"> routingKey    <span class="keyword">string</span></span><br><span class="line"> consumerTag   <span class="keyword">string</span></span><br><span class="line"> autoDelete    <span class="keyword">bool</span></span><br><span class="line"> handler       <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"> delivery      &lt;-<span class="keyword">chan</span> amqp.Delivery</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewConsumer 创建消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConsumer</span><span class="params">(addr, exchange, queue, routingKey <span class="keyword">string</span>, autoDelete <span class="keyword">bool</span>, handler <span class="keyword">func</span>([]<span class="keyword">byte</span>)</span> <span class="title">error</span>) *<span class="title">RabbitConsumer</span></span> &#123;</span><br><span class="line"> hostname, _ := os.Hostname()</span><br><span class="line"> <span class="keyword">return</span> &amp;RabbitConsumer&#123;</span><br><span class="line">  addr:        addr,</span><br><span class="line">  exchange:    exchange,</span><br><span class="line">  queue:       queue,</span><br><span class="line">  routingKey:  routingKey,</span><br><span class="line">  consumerTag: hostname,</span><br><span class="line">  autoDelete:  autoDelete,</span><br><span class="line">  handler:     handler,</span><br><span class="line">  done:        <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RabbitConsumer)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> err := c.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">go</span> c.ReConnect()</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RabbitConsumer)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="built_in">close</span>(c.done)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> !c.conn.IsClosed() &#123;</span><br><span class="line">  <span class="comment">// 关闭 SubMsg message delivery</span></span><br><span class="line">  <span class="keyword">if</span> err := c.channel.Cancel(c.consumerTag, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   logger.Error(<span class="string">&quot;rabbitmq consumer - channel cancel failed: &quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := c.conn.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   logger.Error(<span class="string">&quot;rabbitmq consumer - connection close failed: &quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RabbitConsumer)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> c.conn, err = amqp.Dial(c.addr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> c.channel, err = c.conn.Channel(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  c.conn.Close()</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   c.channel.Close()</span><br><span class="line">   c.conn.Close()</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 声明一个主要使用的 exchange</span></span><br><span class="line"> err = c.channel.ExchangeDeclare(</span><br><span class="line">  c.exchange, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, c.autoDelete, <span class="literal">false</span>, <span class="literal">false</span>, amqp.Table&#123;</span><br><span class="line">   <span class="string">&quot;x-delayed-type&quot;</span>: <span class="string">&quot;fanout&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 声明一个延时队列, 延时消息就是要发送到这里</span></span><br><span class="line"> q, err := c.channel.QueueDeclare(c.queue, <span class="literal">false</span>, c.autoDelete, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> err = c.channel.QueueBind(q.Name, <span class="string">&quot;&quot;</span>, c.exchange, <span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> c.delivery, err = c.channel.Consume(</span><br><span class="line">  q.Name, c.consumerTag, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">go</span> c.Handle()</span><br><span class="line"></span><br><span class="line"> c.connNotify = c.conn.NotifyClose(<span class="built_in">make</span>(<span class="keyword">chan</span> *amqp.Error))</span><br><span class="line"> c.channelNotify = c.channel.NotifyClose(<span class="built_in">make</span>(<span class="keyword">chan</span> *amqp.Error))</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RabbitConsumer)</span> <span class="title">ReConnect</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> err := &lt;-c.connNotify:</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Error(<span class="string">&quot;rabbitmq consumer - connection NotifyClose: &quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">case</span> err := &lt;-c.channelNotify:</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Error(<span class="string">&quot;rabbitmq consumer - channel NotifyClose: &quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">case</span> &lt;-c.done:</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// backstop</span></span><br><span class="line">  <span class="keyword">if</span> !c.conn.IsClosed() &#123;</span><br><span class="line">   <span class="comment">// close message delivery</span></span><br><span class="line">   <span class="keyword">if</span> err := c.channel.Cancel(c.consumerTag, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Error(<span class="string">&quot;rabbitmq consumer - channel cancel failed: &quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := c.conn.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Error(<span class="string">&quot;rabbitmq consumer - channel cancel failed: &quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IMPORTANT: 必须清空 Notify，否则死连接不会释放</span></span><br><span class="line">  <span class="keyword">for</span> err := <span class="keyword">range</span> c.channelNotify &#123;</span><br><span class="line">   logger.Error(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> err := <span class="keyword">range</span> c.connNotify &#123;</span><br><span class="line">   logger.Error(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> quit:</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-c.done:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">    logger.Error(<span class="string">&quot;rabbitmq consumer - reconnect&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := c.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">     logger.Error(<span class="string">&quot;rabbitmq consumer - failCheck: &quot;</span>, err)</span><br><span class="line">     <span class="comment">// sleep 15s reconnect</span></span><br><span class="line">     time.Sleep(time.Second * <span class="number">15</span>)</span><br><span class="line">     <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span> quit</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RabbitConsumer)</span> <span class="title">Handle</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> d := <span class="keyword">range</span> c.delivery &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(delivery amqp.Delivery)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err := c.handler(delivery.Body); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 重新入队，否则未确认的消息会持续占用内存，这里的操作取决于你的实现，你可以当出错之后并直接丢弃也是可以的</span></span><br><span class="line">    _ = delivery.Reject(<span class="literal">true</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _ = delivery.Ack(<span class="literal">false</span>)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;(d)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>交换机必须设定为 x-delayed-message </li>
<li>需要设定 x-delayed-type 根据你所需要的路由方式 topic\fanout\direct….</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>其实 rabbitmq 的这个延迟队列也是有一些问题的：</p>
<ol>
<li>延迟队列插件的实现是先将消息存到一个 <strong>Mnesia</strong> 一个分布式数据库管理系统，所以消息有没有落盘 Mnesia 重启之后能否存在也就会影响消息的延迟触发了</li>
<li>并且插件官方也说了不支持 RAM 节点</li>
<li>100s of thousands or millions 也就是 数十万或数百万 消息的场景也会有问题，毕竟定时还是有瓶颈的 <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/issues/72">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/issues/72</a></li>
</ol>
<p>总之对于我当前业务场景的使用确实是绰绰有余了，但是你在使用之前还是需要提前考虑好这些问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你需要使用 rabbitmq 实现一个延迟队列，就需要看你的使用场景了，如果你的使用场景，延迟时间相同，可以直接使用 TTL + 死信交换机来实现，如果延迟时间不确定，则需要安装插件来满足实现。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>插件官方地址：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p>
<p>直接参考这个 golang 代码进行实现即可：<a href="https://github.com/ghigt/rabbitmq-delayed">https://github.com/ghigt/rabbitmq-delayed</a></p>
<p>非插件的版本可以参考这个实现：<a href="https://blog.justwe.site/post/go-rabbitmq-delay-queue/">https://blog.justwe.site/post/go-rabbitmq-delay-queue/</a></p>
<p><a href="https://mp.weixin.qq.com/s/T6CKU3m8Xv7XYGbquz-04w">https://mp.weixin.qq.com/s/T6CKU3m8Xv7XYGbquz-04w</a></p>
<p><a href="https://www.cnblogs.com/mfrank/p/11260355.html#autoid-0-7-0">https://www.cnblogs.com/mfrank/p/11260355.html#autoid-0-7-0</a></p>
]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>delay-queue</tag>
      </tags>
  </entry>
  <entry>
    <title>我怎么从来没见过 sync.Cond</title>
    <url>/post/122ec973.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>sync.Cond</code> 作为 go 标准库提供的一个并发原语，但是可能你从来没听过，可见它使用场景挺少的，但是我们需要有这个知识储备，只有储备了之后才能在需要用的时候用出来。</p>
<p>其实如果你之前和我一样接触过 java，那么其实对于这个并发原语其实应该很熟悉，其实就是常说的等待通知机制，也就是 wait 方法和 notify 方法。</p>
<span id="more"></span>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们首先从使用的角度的出发，先来看看 cond 是如何使用的</p>
<h3 id="三个方法"><a href="#三个方法" class="headerlink" title="三个方法"></a>三个方法</h3><p>首先我用最白话的方式描述一下 cond 的三个方法</p>
<ul>
<li>Wait 当前调用者等待执行，直到被唤醒，<strong>调用该方法时需要加锁</strong></li>
<li>Signal 唤醒一个调用者</li>
<li>Broadcast 唤醒所有调用者</li>
</ul>
<h3 id="一把锁一个队列"><a href="#一把锁一个队列" class="headerlink" title="一把锁一个队列"></a>一把锁一个队列</h3><p>cond 初始化需要传入一个锁，用于并发控制，调用 wait 的时候需要加锁</p>
<p>cond 内部维护着一个队列，等待调用者排队等待</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>我们创建两个 goroutine 使用 cond 等待执行任务，然后使用 signal 方法唤醒试试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">&quot;a is waiting...&quot;</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">&quot;a was awakened&quot;</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      cond.L.Lock()</span><br><span class="line">      fmt.Println(<span class="string">&quot;b is waiting...&quot;</span>)</span><br><span class="line">      cond.Wait()</span><br><span class="line">      fmt.Println(<span class="string">&quot;b was awakened&quot;</span>)</span><br><span class="line">      cond.L.Unlock()</span><br><span class="line">   &#125;()</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line">   cond.Signal()</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line">   cond.Signal()</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">output: </span><br><span class="line">a is waiting...</span><br><span class="line">b is waiting...</span><br><span class="line">a was awakened</span><br><span class="line">b was awakened</span><br></pre></td></tr></table></figure>
<p>当然你也可以使用功能 <code>Broadcast</code> 方法全部一次性唤醒，输出也是一样的。</p>
<blockquote>
<p>这里埋一个伏笔，我们这里两个 goroutine 都 阻塞在了 wait 方法，都没有 unlock 这里的互斥锁，但是我们看到 waiting 都打印出来了，那为什么可以这样做呢？</p>
</blockquote>
<p>这个使用的给你的感觉是什么？我第一次看到 cond 的时候就给我的感觉是 waitgroup 的反向操作。</p>
<p>我们知道 waitgroup 可以描述为将一个大任务拆分成多个小任务，每次拆成一个任务就 add 一次，每一次任务完成就 done 一次，然后有人 wait 直到所有的任务都完成。而 cond 是不是刚好反了一下，是一堆人在等着执行，等着被唤醒执行，但是好像又不太一样。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在看源码之前还是带着几个问题去看：</p>
<ol>
<li>wait 之前为什么需要 lock？</li>
<li>signal 次数大于当前等待对象数量会有问题吗？</li>
<li>broadcast 之后还能继续 wait 吗？</li>
</ol>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">   noCopy noCopy</span><br><span class="line"></span><br><span class="line">   <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">   L Locker</span><br><span class="line"></span><br><span class="line">   notify  notifyList</span><br><span class="line">   checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// wait is the ticket number of the next waiter. It is atomically</span></span><br><span class="line">	<span class="comment">// incremented outside the lock.</span></span><br><span class="line">	wait <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// notify is the ticket number of the next waiter to be notified. It can</span></span><br><span class="line">	<span class="comment">// be read outside the lock, but is only written to with lock held.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Both wait &amp; notify can wrap around, and such cases will be correctly</span></span><br><span class="line">	<span class="comment">// handled as long as their &quot;unwrapped&quot; difference is bounded by 2^31.</span></span><br><span class="line">	<span class="comment">// For this not to be the case, we&#x27;d need to have 2^31+ goroutines</span></span><br><span class="line">	<span class="comment">// blocked on the same condvar, which is currently not possible.</span></span><br><span class="line">	notify <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// List of parked waiters.</span></span><br><span class="line">	lock mutex</span><br><span class="line">	head *sudog</span><br><span class="line">	tail *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到结构非常简单，noCopy 和 checker 保证 cond 不能被 copy，否则会 panic，而且是个运行时检查。</p>
<p>剩下的就是一把锁一个队列了</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewCond returns a new Cond with Locker l.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建没啥好说的，就是传入一个锁赋值就可以了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c.checker.check()</span><br><span class="line">   runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c.checker.check()</span><br><span class="line">   runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Signal 和 Broadcast 都是 check 一下 cond 有没有被复制，然后就直接通过 sema 的 notify 方法将队列传入唤醒了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c.checker.check()</span><br><span class="line">   t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">   c.L.Unlock()</span><br><span class="line">   runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">   c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait 方法也是类似，不过这里需要注意的一点是，<strong>这里首先 unlock 了一次</strong>，然后再开始 wait，这也就是解释了之前那个伏笔，并且也引出了为什么 wait 之前必须 lock，因为不 lock 的话直接 unlock 肯定报错</p>
<h4 id="runtime-notifyListWait"><a href="#runtime-notifyListWait" class="headerlink" title="runtime_notifyListWait"></a>runtime_notifyListWait</h4><p>首先我们来看 <code>runtime_notifyListAdd</code> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// notifyListAdd adds the caller to a notify list such that it can receive</span></span><br><span class="line"><span class="comment">// notifications. The caller must eventually call notifyListWait to wait for</span></span><br><span class="line"><span class="comment">// such a notification, passing the returned ticket number.</span></span><br><span class="line"><span class="comment">//go:linkname notifyListAdd sync.runtime_notifyListAdd</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">   <span class="comment">// This may be called concurrently, for example, when called from</span></span><br><span class="line">   <span class="comment">// sync.Cond.Wait while holding a RWMutex in read mode.</span></span><br><span class="line">   <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单就是将 notifyList 的中的 wait + 1，并且这是一个原子操作</p>
<h4 id="runtime-notifyListWait-1"><a href="#runtime-notifyListWait-1" class="headerlink" title="runtime_notifyListWait"></a>runtime_notifyListWait</h4><p>然后来看 <code>runtime_notifyListWait</code> 这里的第二个参数 t 就是上一个 Xadd 之后 -1 返回的结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// notifyListAdd was called, it returns immediately. Otherwise, it blocks.</span></span><br><span class="line"><span class="comment">//go:linkname notifyListWait sync.runtime_notifyListWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">   lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return right away if this ticket has already been notified.</span></span><br><span class="line">   <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">      unlock(&amp;l.lock)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Enqueue itself.</span></span><br><span class="line">   s := acquireSudog()</span><br><span class="line">   s.g = getg()</span><br><span class="line">   s.ticket = t</span><br><span class="line">   s.releasetime = <span class="number">0</span></span><br><span class="line">   t0 := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">      t0 = cputicks()</span><br><span class="line">      s.releasetime = <span class="number">-1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">      l.head = s</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l.tail.next = s</span><br><span class="line">   &#125;</span><br><span class="line">   l.tail = s</span><br><span class="line">   goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">      blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难，说几个要点：</p>
<ul>
<li>如果当前传入的 t &lt; notify 的话，证明已经被唤醒了，所以直接解锁返回</li>
<li>获取一个 sudog 用于挂起</li>
<li><code>s.ticket = t</code> 注意这里后面会用到，这里将 sudog 里面的 ticket 标记为当前队列长度</li>
<li>当 tail 为 nil 证明是空队列，直接 head 赋值为 s；如果 tail 不为 nil 证明队列有元素直接链到队尾，并且将当前节点作为新的队尾</li>
<li>然后 gopark 等着被唤醒就可以</li>
</ul>
<h4 id="runtime-notifyListNotifyOne"><a href="#runtime-notifyListNotifyOne" class="headerlink" title="runtime_notifyListNotifyOne"></a>runtime_notifyListNotifyOne</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// notifyListNotifyOne notifies one entry in the list.</span></span><br><span class="line"><span class="comment">//go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Fast-path: if there are no new waiters since the last notification</span></span><br><span class="line">   <span class="comment">// we don&#x27;t need to acquire the lock at all.</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Re-check under the lock if we need to do anything.</span></span><br><span class="line">   t := l.notify</span><br><span class="line">   <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;</span><br><span class="line">      unlock(&amp;l.lock)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Update the next notify ticket number.</span></span><br><span class="line">   atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Try to find the g that needs to be notified.</span></span><br><span class="line">   <span class="comment">// If it hasn&#x27;t made it to the list yet we won&#x27;t find it,</span></span><br><span class="line">   <span class="comment">// but it won&#x27;t park itself once it sees the new notify number.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// This scan looks linear but essentially always stops quickly.</span></span><br><span class="line">   <span class="comment">// Because g&#x27;s queue separately from taking numbers,</span></span><br><span class="line">   <span class="comment">// there may be minor reorderings in the list, but we</span></span><br><span class="line">   <span class="comment">// expect the g we&#x27;re looking for to be near the front.</span></span><br><span class="line">   <span class="comment">// The g has others in front of it on the list only to the</span></span><br><span class="line">   <span class="comment">// extent that it lost the race, so the iteration will not</span></span><br><span class="line">   <span class="comment">// be too long. This applies even when the g is missing:</span></span><br><span class="line">   <span class="comment">// it hasn&#x27;t yet gotten to sleep and has lost the race to</span></span><br><span class="line">   <span class="comment">// the (few) other g&#x27;s that we find on the list.</span></span><br><span class="line">   <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">      <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">         n := s.next</span><br><span class="line">         <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            p.next = n</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l.head = n</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            l.tail = p</span><br><span class="line">         &#125;</span><br><span class="line">         unlock(&amp;l.lock)</span><br><span class="line">         s.next = <span class="literal">nil</span></span><br><span class="line">         readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait 和 notify 数量一致就没有人等着了，直接返回</li>
<li>lock 之后 double check 一次，并发编程的常规操作了</li>
<li>notify 的数量在原有数量上+1，因为这次唤醒一个新的了</li>
<li>只有当 ticket 为 t 的时候证明才是下一个需要被唤醒的 sudog （上面的注释解释了这里为什么使用循环，大多数情况下就是 head 就是需要被唤醒的 sudog 了）</li>
<li>然后就是队列出队的基本操作了</li>
<li>最后 readyWithTime 调用 goready 唤醒对应的 sudog 执行就可以了</li>
</ul>
<h4 id="runtime-notifyListNotifyAll"><a href="#runtime-notifyListNotifyAll" class="headerlink" title="runtime_notifyListNotifyAll"></a>runtime_notifyListNotifyAll</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// notifyListNotifyAll notifies all entries in the list.</span></span><br><span class="line"><span class="comment">//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Fast-path: if there are no new waiters since the last notification</span></span><br><span class="line">   <span class="comment">// we don&#x27;t need to acquire the lock.</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Pull the list out into a local variable, waiters will be readied</span></span><br><span class="line">   <span class="comment">// outside the lock.</span></span><br><span class="line">   lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line">   s := l.head</span><br><span class="line">   l.head = <span class="literal">nil</span></span><br><span class="line">   l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Update the next ticket to be notified. We can set it to the current</span></span><br><span class="line">   <span class="comment">// value of wait because any previous waiters are already in the list</span></span><br><span class="line">   <span class="comment">// or will notice that they have already been notified when trying to</span></span><br><span class="line">   <span class="comment">// add themselves to the list.</span></span><br><span class="line">   atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Go through the local list and ready all waiters.</span></span><br><span class="line">   <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">      next := s.next</span><br><span class="line">      s.next = <span class="literal">nil</span></span><br><span class="line">      readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">      s = next</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完 notify 方法然后再看 notifyAll 方法就很简单了，其实就是遍历了整个队列，对每一个 sudog 都 ready 一次就可以了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说 cond 的实现还是很容易理解的，并没有想的很复杂，只需要在使用的时候多加注意：wait 之前需要加锁。</p>
<p>和 java 比较起来，我记得一开始学的时候 notify 还是随机唤醒一个，然后后来根据不同的 jvm 有了不同的实现，hotspot 实现还是队列。</p>
<p>最后是使用，为什么我这么晚才写这个 cond 呢..其实拖延了很久了，因为在实际中没用过，就在最近在处理一个并发场景的时候偶发的用上了一下，就想着来补一下了。所以在实际中，可能你永远也用不到它，但是知道它，当个知识储备以防不时之需吧。</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>sync.Cond</tag>
      </tags>
  </entry>
  <entry>
    <title>go 中其实不复杂的 timer</title>
    <url>/post/efe08c85.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 go 中当我们需要延迟一段时间后执行，或者需要间隔固定时间去执行某个行为的时候就需要使用到 timer，那么 timer 到底是如何实现的呢？我们今天就来看看 timer 里面是什么样的。</p>
<p>同时因为 1.14 版本前后 timer 的实现有很大的区别，我们顺便来了解一下之前的版本和现在的版本有什么样的不一样，到底做了什么样的优化。</p>
<span id="more"></span>
<h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><p>有以下的知识点支持才能更好的理解今天的分析</p>
<ul>
<li>需要有 GMP 模型的基础</li>
<li>需要有 go 调度相关的基础</li>
<li>需要有数据结构中’堆‘的基础</li>
</ul>
<h2 id="ticker"><a href="#ticker" class="headerlink" title="ticker"></a>ticker</h2><p>要看 timer 可以先从 ticker 入手，ticker 其实我们经常使用到，ticker 顾名思义就是每次间隔一段时间触发一次，下面我们就来看看它的具体实现</p>
<h3 id="带着问题"><a href="#带着问题" class="headerlink" title="带着问题"></a>带着问题</h3><ul>
<li>Ticker 如果当前时间到了，没有及时处理，下一次时间到了，会保留吗？是都在后面排队，还是直接被丢弃了？</li>
<li><code>NewTicker()</code> 和 <code>Tick()</code> 有什么区别？使用上需要注意什么？</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Ticker holds a channel that delivers ``ticks&#x27;&#x27; of a clock</span></span><br><span class="line"><span class="comment">// at intervals.</span></span><br><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;-<span class="keyword">chan</span> Time <span class="comment">// The channel on which the ticks are delivered.</span></span><br><span class="line">	r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它的数据结构非常简单，就是一个 channel 当时间到达就会向这个 channel 里面发送一个触发的时间</p>
<h3 id="Start-Stop-Reset"><a href="#Start-Stop-Reset" class="headerlink" title="Start Stop Reset"></a>Start Stop Reset</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewTicker returns a new Ticker containing a channel that will send</span></span><br><span class="line"><span class="comment">// the time on the channel after each tick. The period of the ticks is</span></span><br><span class="line"><span class="comment">// specified by the duration argument. The ticker will adjust the time</span></span><br><span class="line"><span class="comment">// interval or drop ticks to make up for slow receivers.</span></span><br><span class="line"><span class="comment">// The duration d must be greater than zero; if not, NewTicker will</span></span><br><span class="line"><span class="comment">// panic. Stop the ticker to release associated resources.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span> *<span class="title">Ticker</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errors.New(<span class="string">&quot;non-positive interval for NewTicker&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Give the channel a 1-element time buffer.</span></span><br><span class="line">	<span class="comment">// If the client falls behind while reading, we drop ticks</span></span><br><span class="line">	<span class="comment">// on the floor until the client catches up.</span></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">	t := &amp;Ticker&#123;</span><br><span class="line">		C: c,</span><br><span class="line">		r: runtimeTimer&#123;</span><br><span class="line">			when:   when(d),</span><br><span class="line">			period: <span class="keyword">int64</span>(d),</span><br><span class="line">			f:      sendTime,</span><br><span class="line">			arg:    c,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	startTimer(&amp;t.r)</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop turns off a ticker. After Stop, no more ticks will be sent.</span></span><br><span class="line"><span class="comment">// Stop does not close the channel, to prevent a concurrent goroutine</span></span><br><span class="line"><span class="comment">// reading from the channel from seeing an erroneous &quot;tick&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stopTimer(&amp;t.r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset stops a ticker and resets its period to the specified duration.</span></span><br><span class="line"><span class="comment">// The next tick will arrive after the new period elapses.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">Reset</span><span class="params">(d Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.r.f == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;time: Reset called on uninitialized Ticker&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	modTimer(&amp;t.r, when(d), <span class="keyword">int64</span>(d), t.r.f, t.r.arg, t.r.seq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点有以下几个：</p>
<ul>
<li>ticker 中的 channel 长度为 1，这也就意味着里面只能放一个触发的时间，也就是说如果当前这次触发没有处理完成，下次触发来了可以先存着，但是再下一次就直接会被抛弃了。你是不是奇怪为什么要单独提出这一点来说，想要说明的是，ticker 的使用并不能保证一定间隔相同的时间触发，如果你再处理过程中阻塞住了，间隔时间短就可能出现连续，所以处理一定要保证及时。</li>
<li>stop 并不会关闭 channel，因为并发的时候可能同时到了触发时间，如果关闭了 channel 就有可能出现往一个关闭的 channel 中发消息的 panic；但也只有 stop 了之后相关的资源才会得到释放，所以用完之后记得关闭</li>
</ul>
<p>可以看到三个方法都比较简单，主要就是利用 timer 去实现的 ticker，所有我们主要需要关注在 <code>startTimer</code> <code>stopTimer</code> <code>modTimer</code> 方法上</p>
<h3 id="Tick-方法"><a href="#Tick-方法" class="headerlink" title="Tick 方法"></a>Tick 方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tick is a convenience wrapper for NewTicker providing access to the ticking</span></span><br><span class="line"><span class="comment">// channel only. While Tick is useful for clients that have no need to shut down</span></span><br><span class="line"><span class="comment">// the Ticker, be aware that without a way to shut it down the underlying</span></span><br><span class="line"><span class="comment">// Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;.</span></span><br><span class="line"><span class="comment">// Unlike NewTicker, Tick will return nil if d &lt;= 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NewTicker(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里我们很明显可以看到，其实 Tick 方法就是对 NewTicker 的一个封装，让使用 Ticker 更加简单，直接一行代码搞定，但是随之带来的就是你没有办法去关闭这个 Ticker 了。<br>这也就意味着会导致内存泄露，所以一般在项目中都会使用 NewTicker 方法，除非你的项目当 Tick 停止时就已经直接退出了，那也不必考虑这个问题。</p>
<p>好了，现在我们可以聚焦到这次我们的主角了 <code>Timer</code> 上了</p>
<h2 id="go1-13-的-Timer"><a href="#go1-13-的-Timer" class="headerlink" title="go1.13 的 Timer"></a>go1.13 的 Timer</h2><p>老版本的 timer 实现比较简单，代码也比较清晰</p>
<h3 id="startTimer"><a href="#startTimer" class="headerlink" title="startTimer"></a>startTimer</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racerelease(unsafe.Pointer(t))</span><br><span class="line">	&#125;</span><br><span class="line">	addtimer(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，首先是分配了一个 bucket 然后加锁之后开始 <code>addtimerLocked</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">	tb := t.assignBucket()</span><br><span class="line">	lock(&amp;tb.lock)</span><br><span class="line">	ok := tb.addtimerLocked(t)</span><br><span class="line">	unlock(&amp;tb.lock)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		badTimer()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timersLen = <span class="number">64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span> <span class="title">assignBucket</span><span class="params">()</span> *<span class="title">timersBucket</span></span> &#123;</span><br><span class="line">	id := <span class="keyword">uint8</span>(getg().m.p.ptr().id) % timersLen</span><br><span class="line">	t.tb = &amp;timers[id].timersBucket</span><br><span class="line">	<span class="keyword">return</span> t.tb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add a timer to the heap and start or kick timerproc if the new timer is</span></span><br><span class="line"><span class="comment">// earlier than any of the others.</span></span><br><span class="line"><span class="comment">// Timers are locked.</span></span><br><span class="line"><span class="comment">// Returns whether all is well: false if the data structure is corrupt</span></span><br><span class="line"><span class="comment">// due to user-level races.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *timersBucket)</span> <span class="title">addtimerLocked</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// when must never be negative; otherwise timerproc will overflow</span></span><br><span class="line">	<span class="comment">// during its delta calculation and never expire other runtime timers.</span></span><br><span class="line">	<span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123;</span><br><span class="line">		t.when = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.i = <span class="built_in">len</span>(tb.t)</span><br><span class="line">	tb.t = <span class="built_in">append</span>(tb.t, t)</span><br><span class="line">	<span class="keyword">if</span> !siftupTimer(tb.t, t.i) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.i == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// siftup moved to top: new earliest deadline.</span></span><br><span class="line">		<span class="keyword">if</span> tb.sleeping &amp;&amp; tb.sleepUntil &gt; t.when &#123;</span><br><span class="line">			tb.sleeping = <span class="literal">false</span></span><br><span class="line">			notewakeup(&amp;tb.waitnote)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tb.rescheduling &#123;</span><br><span class="line">			tb.rescheduling = <span class="literal">false</span></span><br><span class="line">			goready(tb.gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !tb.created &#123;</span><br><span class="line">			tb.created = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">go</span> timerproc(tb)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当看到 <code>siftupTimer</code> 这个方法的时候你应该就豁然开朗了，因为这个很明显的就是一个堆的操作，只不过这里的堆是一个 4 叉堆，你看它找父节点的时候是 /4 的，<code>siftdownTimer</code> 也是类似这里也不多赘述了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftupTimer</span><span class="params">(t []*timer, i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(t) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	when := t[i].when</span><br><span class="line">	tmp := t[i]</span><br><span class="line">	<span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">		p := (i - <span class="number">1</span>) / <span class="number">4</span> <span class="comment">// parent</span></span><br><span class="line">		<span class="keyword">if</span> when &gt;= t[p].when &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		t[i] = t[p]</span><br><span class="line">		t[i].i = i</span><br><span class="line">		i = p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tmp != t[i] &#123;</span><br><span class="line">		t[i] = tmp</span><br><span class="line">		t[i].i = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说启动一个 timer 就是三步走</p>
<ul>
<li>加锁</li>
<li>将新的 timer 添加到数组末尾</li>
<li>堆化</li>
</ul>
<h3 id="stopTimer"><a href="#stopTimer" class="headerlink" title="stopTimer"></a>stopTimer</h3><p>其实知道了启动停止就不难了，也是类似的，从数组中删除之后然后堆化就可以了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stopTimer removes t from the timer heap if it is there.</span></span><br><span class="line"><span class="comment">// It returns true if t was removed, false if t wasn&#x27;t even there.</span></span><br><span class="line"><span class="comment">//go:linkname stopTimer time.stopTimer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTimer</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> deltimer(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete timer t from the heap.</span></span><br><span class="line"><span class="comment">// Do not need to update the timerproc: if it wakes up early, no big deal.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deltimer</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.tb == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// t.tb can be nil if the user created a timer</span></span><br><span class="line">		<span class="comment">// directly, without invoking startTimer e.g</span></span><br><span class="line">		<span class="comment">//    time.Ticker&#123;C: c&#125;</span></span><br><span class="line">		<span class="comment">// In this case, return early without any deletion.</span></span><br><span class="line">		<span class="comment">// See Issue 21874.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tb := t.tb</span><br><span class="line"></span><br><span class="line">	lock(&amp;tb.lock)</span><br><span class="line">	removed, ok := tb.deltimerLocked(t)</span><br><span class="line">	unlock(&amp;tb.lock)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		badTimer()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> removed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *timersBucket)</span> <span class="title">deltimerLocked</span><span class="params">(t *timer)</span> <span class="params">(removed, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// t may not be registered anymore and may have</span></span><br><span class="line">	<span class="comment">// a bogus i (typically 0, if generated by Go).</span></span><br><span class="line">	<span class="comment">// Verify it before proceeding.</span></span><br><span class="line">	i := t.i</span><br><span class="line">	last := <span class="built_in">len</span>(tb.t) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt; last || tb.t[i] != t &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i != last &#123;</span><br><span class="line">		tb.t[i] = tb.t[last]</span><br><span class="line">		tb.t[i].i = i</span><br><span class="line">	&#125;</span><br><span class="line">	tb.t[last] = <span class="literal">nil</span></span><br><span class="line">	tb.t = tb.t[:last]</span><br><span class="line">	ok = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> i != last &#123;</span><br><span class="line">		<span class="keyword">if</span> !siftupTimer(tb.t, i) &#123;</span><br><span class="line">			ok = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !siftdownTimer(tb.t, i) &#123;</span><br><span class="line">			ok = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="何时触发？"><a href="#何时触发？" class="headerlink" title="何时触发？"></a>何时触发？</h3><p>那么问题来了，时间到了之后什么地方在触发往 timer 中的 channel 中发数据呢？其实前面的源码中已经给出了细节，在 <code>addtimerLocked</code> 方法中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !tb.created &#123;</span><br><span class="line">	tb.created = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// 这里创建了一个 goroutine 专门来运行 timerproc 方法</span></span><br><span class="line">	<span class="keyword">go</span> timerproc(tb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的时候会调用 <code>timerproc</code> 方法，我们来看看这个方法里面做了什么。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Timerproc runs the time-driven events.</span></span><br><span class="line"><span class="comment">// It sleeps until the next event in the tb heap.</span></span><br><span class="line"><span class="comment">// If addtimer inserts a new earlier event, it wakes timerproc early.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line">	tb.gp = getg()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		lock(&amp;tb.lock)</span><br><span class="line">		tb.sleeping = <span class="literal">false</span></span><br><span class="line">		now := nanotime()</span><br><span class="line">		delta := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(tb.t) == <span class="number">0</span> &#123;</span><br><span class="line">				delta = <span class="number">-1</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取堆顶元素</span></span><br><span class="line">			t := tb.t[<span class="number">0</span>]</span><br><span class="line">			<span class="comment">// 看是否满足触发时间</span></span><br><span class="line">			delta = t.when - now</span><br><span class="line">			<span class="keyword">if</span> delta &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			ok := <span class="literal">true</span></span><br><span class="line">			<span class="comment">// 当 period &gt; 0 则说明这是一个需要周期性触发的 timer 也就是 ticker，否则就触发一次后直接从堆里面移除</span></span><br><span class="line">			<span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// leave in heap but adjust next time to fire</span></span><br><span class="line">				<span class="comment">// 修改当前元素的触发时间，然后直接开始堆化即可，自己就排到后面去了</span></span><br><span class="line">				t.when += t.period * (<span class="number">1</span> + -delta/t.period)</span><br><span class="line">				<span class="keyword">if</span> !siftdownTimer(tb.t, <span class="number">0</span>) &#123;</span><br><span class="line">					ok = <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// remove from heap</span></span><br><span class="line">				last := <span class="built_in">len</span>(tb.t) - <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">					tb.t[<span class="number">0</span>] = tb.t[last]</span><br><span class="line">					tb.t[<span class="number">0</span>].i = <span class="number">0</span></span><br><span class="line">				&#125;</span><br><span class="line">				tb.t[last] = <span class="literal">nil</span></span><br><span class="line">				tb.t = tb.t[:last]</span><br><span class="line">				<span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> !siftdownTimer(tb.t, <span class="number">0</span>) &#123;</span><br><span class="line">						ok = <span class="literal">false</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				t.i = <span class="number">-1</span> <span class="comment">// mark as removed</span></span><br><span class="line">			&#125;</span><br><span class="line">			f := t.f</span><br><span class="line">			arg := t.arg</span><br><span class="line">			seq := t.seq</span><br><span class="line">			unlock(&amp;tb.lock)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				badTimer()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				raceacquire(unsafe.Pointer(t))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这里就是真正触发定时方法的地方，如果是 ticker 的话就是初始化的 sendTime 方法，就是将当前时间发送到 channel 中</span></span><br><span class="line">			f(arg, seq)</span><br><span class="line">			lock(&amp;tb.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delta &lt; <span class="number">0</span> || faketime &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// No timers left - put goroutine to sleep.</span></span><br><span class="line">			tb.rescheduling = <span class="literal">true</span></span><br><span class="line">			goparkunlock(&amp;tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// At least one timer pending. Sleep until then.</span></span><br><span class="line">		<span class="comment">// 这里可以看到，如果对顶元素还没有到对应的触发时间，那么就睡眠相对应的时间即可</span></span><br><span class="line">		tb.sleeping = <span class="literal">true</span></span><br><span class="line">		tb.sleepUntil = now + delta</span><br><span class="line">		noteclear(&amp;tb.waitnote)</span><br><span class="line">		unlock(&amp;tb.lock)</span><br><span class="line">		notetsleepg(&amp;tb.waitnote, delta)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到整体思路很清晰，就是将最先触发的元素拿出来，然后判断是否到时间，如果到了时间就触发，如果没到，就睡眠一个 delta 的时间等待触发。当然在 <code>addtimerLocked</code> 方法中也会尝试唤醒 (调用<code>notewakeup</code>方法)，因为新加入的 timer 肯定会影响当前整个堆的下一次触发时间。</p>
<p>所以总的来说在 go1.13 版本中，timer 的实现还是比较简单清晰的</p>
<h2 id="go1-17-的-Timer"><a href="#go1-17-的-Timer" class="headerlink" title="go1.17 的 Timer"></a>go1.17 的 Timer</h2><p>那么我们来看看现在版本的 timer 是如何实现的，因为我们上面详细看过，这里就省略其中部分。</p>
<p>在当前新的版本中对于 timer 的定义有了各种状态的表示，下面的注释也很清晰，标识了各种状态所出现的情况，至于状态的转换这里就不给出具体的状态图了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Values for the timer status field.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Timer has no status set yet.</span></span><br><span class="line">	timerNoStatus = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Waiting for timer to fire.</span></span><br><span class="line">	<span class="comment">// The timer is in some P&#x27;s heap.</span></span><br><span class="line">	timerWaiting</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Running the timer function.</span></span><br><span class="line">	<span class="comment">// A timer will only have this status briefly.</span></span><br><span class="line">	timerRunning</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer is deleted and should be removed.</span></span><br><span class="line">	<span class="comment">// It should not be run, but it is still in some P&#x27;s heap.</span></span><br><span class="line">	timerDeleted</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer is being removed.</span></span><br><span class="line">	<span class="comment">// The timer will only have this status briefly.</span></span><br><span class="line">	timerRemoving</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer has been stopped.</span></span><br><span class="line">	<span class="comment">// It is not in any P&#x27;s heap.</span></span><br><span class="line">	timerRemoved</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer is being modified.</span></span><br><span class="line">	<span class="comment">// The timer will only have this status briefly.</span></span><br><span class="line">	timerModifying</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer has been modified to an earlier time.</span></span><br><span class="line">	<span class="comment">// The new when value is in the nextwhen field.</span></span><br><span class="line">	<span class="comment">// The timer is in some P&#x27;s heap, possibly in the wrong place.</span></span><br><span class="line">	timerModifiedEarlier</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer has been modified to the same or a later time.</span></span><br><span class="line">	<span class="comment">// The new when value is in the nextwhen field.</span></span><br><span class="line">	<span class="comment">// The timer is in some P&#x27;s heap, possibly in the wrong place.</span></span><br><span class="line">	timerModifiedLater</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer has been modified and is being moved.</span></span><br><span class="line">	<span class="comment">// The timer will only have this status briefly.</span></span><br><span class="line">	timerMoving</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="addtimer"><a href="#addtimer" class="headerlink" title="addtimer"></a>addtimer</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addtimer adds a timer to the current P.</span></span><br><span class="line"><span class="comment">// This should only be called with a newly created timer.</span></span><br><span class="line"><span class="comment">// That avoids the risk of changing the when field of a timer in some P&#x27;s heap,</span></span><br><span class="line"><span class="comment">// which could cause the heap to become unsorted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">	<span class="comment">//.................</span></span><br><span class="line"></span><br><span class="line">	when := t.when</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable preemption while using pp to avoid changing another P&#x27;s heap.</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前 g 所绑定的 m，然后再拿到绑定的 p</span></span><br><span class="line">	pp := getg().m.p.ptr()</span><br><span class="line">	lock(&amp;pp.timersLock)</span><br><span class="line">	<span class="comment">// 首先做清除，清除那些已经标记为删除的 timer</span></span><br><span class="line">	cleantimers(pp)</span><br><span class="line">	<span class="comment">// 然后将当前的 timer 加入到当前 p 所属的 timer 列表中</span></span><br><span class="line">	doaddtimer(pp, t)</span><br><span class="line">	unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	wakeNetPoller(when)</span><br><span class="line"></span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// doaddtimer adds t to the current P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doaddtimer</span><span class="params">(pp *p, t *timer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...............</span></span><br><span class="line">	</span><br><span class="line">	t.pp.set(pp)</span><br><span class="line">	i := <span class="built_in">len</span>(pp.timers)</span><br><span class="line">	<span class="comment">// 这里的操作和之前类似，只不过这次不是放在桶里了，而是放到了 P 上，放完之后依旧是堆化</span></span><br><span class="line">	pp.timers = <span class="built_in">append</span>(pp.timers, t)</span><br><span class="line">	siftupTimer(pp.timers, i)</span><br><span class="line">	<span class="keyword">if</span> t == pp.timers[<span class="number">0</span>] &#123;</span><br><span class="line">		atomic.Store64(&amp;pp.timer0When, <span class="keyword">uint64</span>(t.when))</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.Xadd(&amp;pp.numTimers, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ..............</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lock for timers. We normally access the timers while running</span></span><br><span class="line">	<span class="comment">// on this P, but the scheduler can also do it from a different P.</span></span><br><span class="line">	timersLock mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// P 里面是有一个专门的地方来保存这个 timer 堆的</span></span><br><span class="line">	<span class="comment">// Actions to take at some time. This is used to implement the</span></span><br><span class="line">	<span class="comment">// standard library&#x27;s time package.</span></span><br><span class="line">	<span class="comment">// Must hold timersLock to access.</span></span><br><span class="line">	timers []*timer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of timers in P&#x27;s heap.</span></span><br><span class="line">	<span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">	numTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of timerDeleted timers in P&#x27;s heap.</span></span><br><span class="line">	<span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">	deletedTimers <span class="keyword">uint32</span></span><br><span class="line">	<span class="comment">// ..............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到我们的 timer 堆已经不再是一个放在全局各个桶下面的了，而是在 P 内部保存 timer 堆，其他和原来的基本思路一致</p>
<h3 id="deltimer"><a href="#deltimer" class="headerlink" title="deltimer"></a>deltimer</h3><p>删除和原来的操作就不一样了，原先删除后会直接进行堆的操作，而在新版本中不是的，只是标记了状态，根据当前不同的状态进行操作，如：没有运行怎么办，或已经运行了怎么办，当前还未被添加….</p>
<p>而在 <code>cleantimers</code> 方法中会对已经标记为删除的 timer 做相对应的处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deltimer deletes the timer t. It may be on some other P, so we can&#x27;t</span></span><br><span class="line"><span class="comment">// actually remove it from the timers heap. We can only mark it as deleted.</span></span><br><span class="line"><span class="comment">// It will be removed in due course by the P whose heap it is on.</span></span><br><span class="line"><span class="comment">// Reports whether the timer was removed before it was run.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deltimer</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">		<span class="keyword">case</span> timerWaiting, timerModifiedLater:</span><br><span class="line">			<span class="comment">// Prevent preemption while the timer is in timerModifying.</span></span><br><span class="line">			<span class="comment">// This could lead to a self-deadlock. See #38070.</span></span><br><span class="line">			mp := acquirem()</span><br><span class="line">			<span class="keyword">if</span> atomic.Cas(&amp;t.status, s, timerModifying) &#123;</span><br><span class="line">				<span class="comment">// Must fetch t.pp before changing status,</span></span><br><span class="line">				<span class="comment">// as cleantimers in another goroutine</span></span><br><span class="line">				<span class="comment">// can clear t.pp of a timerDeleted timer.</span></span><br><span class="line">				tpp := t.pp.ptr()</span><br><span class="line">				<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerModifying, timerDeleted) &#123;</span><br><span class="line">					badTimer()</span><br><span class="line">				&#125;</span><br><span class="line">				releasem(mp)</span><br><span class="line">				atomic.Xadd(&amp;tpp.deletedTimers, <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// Timer was not yet run.</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				releasem(mp)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> timerModifiedEarlier:</span><br><span class="line">			<span class="comment">// Prevent preemption while the timer is in timerModifying.</span></span><br><span class="line">			<span class="comment">// This could lead to a self-deadlock. See #38070.</span></span><br><span class="line">			mp := acquirem()</span><br><span class="line">			<span class="keyword">if</span> atomic.Cas(&amp;t.status, s, timerModifying) &#123;</span><br><span class="line">				<span class="comment">// Must fetch t.pp before setting status</span></span><br><span class="line">				<span class="comment">// to timerDeleted.</span></span><br><span class="line">				tpp := t.pp.ptr()</span><br><span class="line">				<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerModifying, timerDeleted) &#123;</span><br><span class="line">					badTimer()</span><br><span class="line">				&#125;</span><br><span class="line">				releasem(mp)</span><br><span class="line">				atomic.Xadd(&amp;tpp.deletedTimers, <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// Timer was not yet run.</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				releasem(mp)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> timerDeleted, timerRemoving, timerRemoved:</span><br><span class="line">			<span class="comment">// Timer was already run.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		<span class="keyword">case</span> timerRunning, timerMoving:</span><br><span class="line">			<span class="comment">// The timer is being run or moved, by a different P.</span></span><br><span class="line">			<span class="comment">// Wait for it to complete.</span></span><br><span class="line">			osyield()</span><br><span class="line">		<span class="keyword">case</span> timerNoStatus:</span><br><span class="line">			<span class="comment">// Removing timer that was never added or</span></span><br><span class="line">			<span class="comment">// has already been run. Also see issue 21874.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		<span class="keyword">case</span> timerModifying:</span><br><span class="line">			<span class="comment">// Simultaneous calls to deltimer and modtimer.</span></span><br><span class="line">			<span class="comment">// Wait for the other call to complete.</span></span><br><span class="line">			osyield()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			badTimer()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="何时触发？-1"><a href="#何时触发？-1" class="headerlink" title="何时触发？"></a>何时触发？</h3><p>那么问题来了，在新版本里面是什么时候出发的。其实如果之前没有看过调度相关的源码还真的有点难找。</p>
<ol>
<li><code>schedule -&gt; checkTimers -&gt; runtimer</code></li>
<li><code>stealWork -&gt; checkTimers -&gt; runtimer</code></li>
<li><code>findrunnable -&gt; checkTimers -&gt; runtimer</code></li>
</ol>
<p>其实是当调度的时候触发的 timer 检查，检查的时候触发的对应执行。而且如果你第一次看你会觉得神奇，为什么 work steal 的时候还会进行 timer 的检查呢？我们慢慢往下看。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ....................</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	pp := _g_.m.p.ptr()</span><br><span class="line">	pp.preempt = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pp.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sanity check: if we are spinning, the run queue should be empty.</span></span><br><span class="line">	<span class="comment">// Check this before calling checkTimers, as that might call</span></span><br><span class="line">	<span class="comment">// goready to put a ready goroutine on the local run queue.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &amp;&amp; (pp.runnext != <span class="number">0</span> || pp.runqhead != pp.runqtail) &#123;</span><br><span class="line">		throw(<span class="string">&quot;schedule: spinning with local work&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	checkTimers(pp, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ..................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finds a runnable goroutine to execute.</span></span><br><span class="line"><span class="comment">// Tries to steal from other P&#x27;s, get g from local or global queue, poll network.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line">	<span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line">	<span class="comment">// an M.</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	now, pollUntil, _ := checkTimers(_p_, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ..................</span></span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，确实是在调度的时候触发的 <code>checkTimers</code> 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkTimers</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="params">(rnow, pollUntil <span class="keyword">int64</span>, ran <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If it&#x27;s not yet time for the first timer, or the first adjusted</span></span><br><span class="line">	<span class="comment">// timer, then there is nothing to do.</span></span><br><span class="line">	next := <span class="keyword">int64</span>(atomic.Load64(&amp;pp.timer0When))</span><br><span class="line">	nextAdj := <span class="keyword">int64</span>(atomic.Load64(&amp;pp.timerModifiedEarliest))</span><br><span class="line">	<span class="keyword">if</span> next == <span class="number">0</span> || (nextAdj != <span class="number">0</span> &amp;&amp; nextAdj &lt; next) &#123;</span><br><span class="line">		next = nextAdj</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// No timers to run or adjust.</span></span><br><span class="line">		<span class="keyword">return</span> now, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">		now = nanotime()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> now &lt; next &#123;</span><br><span class="line">		<span class="comment">// Next timer is not ready to run, but keep going</span></span><br><span class="line">		<span class="comment">// if we would clear deleted timers.</span></span><br><span class="line">		<span class="comment">// This corresponds to the condition below where</span></span><br><span class="line">		<span class="comment">// we decide whether to call clearDeletedTimers.</span></span><br><span class="line">		<span class="comment">// 当下一次触发实现还没有到的时候，这里有一个小细节，当需要删除 timer 个数小于 1/4 的时候是不操作的，直接返回，也就是说等着批量一起处理</span></span><br><span class="line">		<span class="keyword">if</span> pp != getg().m.p.ptr() || <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &lt;= <span class="keyword">int</span>(atomic.Load(&amp;pp.numTimers)/<span class="number">4</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> now, next, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 进行当前 p 的 timer 堆的调整，这个方法里面还有很多细节，这里不展开，推荐看一眼</span></span><br><span class="line">		adjusttimers(pp, now)</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Note that runtimer may temporarily unlock</span></span><br><span class="line">			<span class="comment">// pp.timersLock.</span></span><br><span class="line">			<span class="comment">// 如果有需要执行的 timer 的话，那么就调用 runtimer 方法去执行</span></span><br><span class="line">			<span class="keyword">if</span> tw := runtimer(pp, now); tw != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> tw &gt; <span class="number">0</span> &#123;</span><br><span class="line">					pollUntil = tw</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			ran = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is the local P, and there are a lot of deleted timers,</span></span><br><span class="line">	<span class="comment">// clear them out. We only do this for the local P to reduce</span></span><br><span class="line">	<span class="comment">// lock contention on timersLock.</span></span><br><span class="line">	<span class="keyword">if</span> pp == getg().m.p.ptr() &amp;&amp; <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &gt; <span class="built_in">len</span>(pp.timers)/<span class="number">4</span> &#123;</span><br><span class="line">		clearDeletedTimers(pp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> now, pollUntil, ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们就来赶紧看看 runtimer 方法到底是如何运行的吧</p>
<h3 id="runtimer"><a href="#runtimer" class="headerlink" title="runtimer"></a>runtimer</h3><p>这个方法其实非常简单，就是将堆顶元素取出来看状态，根据不同状态去处理，如果满足运行时间则运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtimer</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 取出堆顶元素</span></span><br><span class="line">		t := pp.timers[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">			throw(<span class="string">&quot;runtimer: bad p&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">		<span class="keyword">case</span> timerWaiting:</span><br><span class="line">			<span class="keyword">if</span> t.when &gt; now &#123;</span><br><span class="line">				<span class="comment">// Not ready to run.</span></span><br><span class="line">				<span class="keyword">return</span> t.when</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRunning) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note that runOneTimer may temporarily unlock</span></span><br><span class="line">			<span class="comment">// pp.timersLock.</span></span><br><span class="line">			<span class="comment">// 如果已经到了当前触发时间，就运行当前这个 timer</span></span><br><span class="line">			runOneTimer(pp, t, now)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">case</span> timerDeleted:</span><br><span class="line">			<span class="comment">//.....................</span></span><br><span class="line">		<span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line">			<span class="comment">//.....................</span></span><br><span class="line">		<span class="keyword">case</span> timerModifying:</span><br><span class="line">			osyield()</span><br><span class="line">		<span class="keyword">case</span> timerNoStatus, timerRemoved:</span><br><span class="line">			badTimer()</span><br><span class="line">		<span class="keyword">case</span> timerRunning, timerRemoving, timerMoving:</span><br><span class="line">			badTimer()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			badTimer()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行其实和原来的逻辑是一样的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runOneTimer</span><span class="params">(pp *p, t *timer, now <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line"></span><br><span class="line">	f := t.f</span><br><span class="line">	arg := t.arg</span><br><span class="line">	seq := t.seq</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里的逻辑和原来的 timerproc 中的逻辑是一致的</span></span><br><span class="line">	<span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Leave in heap but adjust next time to fire.</span></span><br><span class="line">		delta := t.when - now</span><br><span class="line">		t.when += t.period * (<span class="number">1</span> + -delta/t.period)</span><br><span class="line">		<span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123; <span class="comment">// check for overflow.</span></span><br><span class="line">			t.when = maxWhen</span><br><span class="line">		&#125;</span><br><span class="line">		siftdownTimer(pp.timers, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRunning, timerWaiting) &#123;</span><br><span class="line">			badTimer()</span><br><span class="line">		&#125;</span><br><span class="line">		updateTimer0When(pp)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Remove from heap.</span></span><br><span class="line">		dodeltimer0(pp)</span><br><span class="line">		<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRunning, timerNoStatus) &#123;</span><br><span class="line">			badTimer()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line"></span><br><span class="line">	unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里就是真正执行触发的方法了</span></span><br><span class="line">	f(arg, seq)</span><br><span class="line"></span><br><span class="line">	lock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="moveTimer"><a href="#moveTimer" class="headerlink" title="moveTimer"></a>moveTimer</h3><p>你以为这样就没有了？还有什么问题我们没有考虑到呢？我们现在已经知道新版本的 timer 堆是在 P 上的了，那么问题来了，当 P 被销毁的时候，可能当前的 P 上还有 timer 呢，那这些 timer 应该怎么办？当然是移走咯</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">	assertLockHeld(&amp;sched.lock)</span><br><span class="line">	assertWorldStopped()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 找一个别的 P</span></span><br><span class="line">		plocal := getg().m.p.ptr()</span><br><span class="line">		<span class="comment">// The world is stopped, but we acquire timersLock to</span></span><br><span class="line">		<span class="comment">// protect against sysmon calling timeSleepUntil.</span></span><br><span class="line">		<span class="comment">// This is the only case where we hold the timersLock of</span></span><br><span class="line">		<span class="comment">// more than one P, so there are no deadlock concerns.</span></span><br><span class="line">		lock(&amp;plocal.timersLock)</span><br><span class="line">		lock(&amp;pp.timersLock)</span><br><span class="line">		<span class="comment">// 这里把当前 P 上的 timer 都移走</span></span><br><span class="line">		moveTimers(plocal, pp.timers)</span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h2><p>看完了源码你会发现，1.14 前后 timer 变化点主要在两个方面:</p>
<ol>
<li>存储方式由原来的放在全局的桶里转而放到了 P 上</li>
<li>触发方式的由原来的单个 goroutine 方法循环定期触发改为调度中触发</li>
</ol>
<p>接下来就是篇的最后重点部分了：为什么 1.14 前后 timer 需要做这样的优化？更快了吗？</p>
<p>我用图来让你快速明白为什么会有这个改动。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211101002348919.png" alt="image-20211101002348919"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211101002408162.png" alt="image-20211101002408162"></p>
<p>存储结构上的改变很容易看出来，就是从原来的桶换成了 P，那么为什么呢？</p>
<h3 id="问题关键"><a href="#问题关键" class="headerlink" title="问题关键"></a>问题关键</h3><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211101001552833.png" alt="image-20211101001552833"></p>
<p>PS：图中的 TP 意思是 运行 timerproc 的 G</p>
<p>可以看到，改动之前，timer 的触发需要频繁的做 M 和 P 的绑定和解绑操作。</p>
<p>就这？对这就是问题的关键。我们举个例子，如果有一个 ticker 每秒触发一次，每触发一次就需要绑定一次 M 解绑一次，而当系统中的 timer 越来越多，那么随之带来的就是越加频繁的切换了。</p>
<p>而改动之后，timer 的触发是在调度循环里面，而且存储在本地的 P 中，<strong>所以没有了绑定和解绑的过程</strong>，也不再需要一个运行 <code>timerproc</code> goroutine 单独去维护触发。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面回顾总结几个点：</p>
<ol>
<li>timer 堆从原有的桶移动到了 P 上，是为了解决频繁切换 MP 的问题。</li>
<li>因为 checkTimers 是在调度循环里面执行的，所以一些操作被延后执行，比如删除 timer 的操作只是修改状态，而懒到后面一起去执行。</li>
<li>其实 timer 的设计说到底还是一个堆的存储，然后堆顶就是下一次最近要执行的 timer。</li>
</ol>
<p>总的来说 timer 的实现还是比较清晰的，其实更老的版本中，一开始 timer 的实现的堆只有一个，而为了优化全局锁的并发性能才出现了 64 个桶这样的结构，然后又发现了切换的性能问题，继续优化才有了现在的 timer。所以其实现在看来很多 go 里面复杂的设计原本都是也是由一个非常简单的设计演变而来的。</p>
]]></content>
      <categories>
        <category>golang源码解析</category>
      </categories>
      <tags>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title>go 函数调用规约</title>
    <url>/post/fecd400.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>函数调用规约？如果你是第一次听到这个名词可能会有疑惑，这是在说什么？难道两个函数之间调用还需要约定什么吗？难道不是定好入参出参就可以了吗？没错函数的调用规约其实就是：我在调用其他函数的时候我的参数和返回值要如何分布？</p>
<p>那么其实在 golang 底层函数的调用还是有很多细节的，比如你的入参放在哪里？返回值存放在哪里？相信看完这篇你就都明白了。</p>
<span id="more"></span>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote>
<p>首先我们定一下基调，因为我们今天讨论的是函数调用规约，所以我们今天的主角是栈，没有堆什么事，也就是说，所有变量都默认分配在栈上，不考虑逃逸的情况</p>
</blockquote>
<h3 id="栈的样子"><a href="#栈的样子" class="headerlink" title="栈的样子"></a>栈的样子</h3><p>先来看看我们今天主角的样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211107220239152.png" alt="image-20211107220239152"></p>
<p>我们今天说的要说的栈，其实应该叫调用栈 <code>call stack</code> 而不是我们平常说的数据结构中栈。栈的增长方向是从高位地址到地位地址向下进行增长的，栈底是我们的高地址，而栈顶是我们的低地址，栈的作用是存放程序执行过程中使用的局部变量。</p>
<h2 id="调用规约"><a href="#调用规约" class="headerlink" title="调用规约"></a>调用规约</h2><p>说简单也简单，说复杂也复杂，这里准备由浅入深，首先用一张图来直接描述 go 里面的函数调用规约究竟是怎么样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211107221858502.png" alt="image-20211107221858502"></p>
<ul>
<li>左边是调用者栈情况，右边是被调用者栈情况</li>
<li>可以看到调用者栈里有本地的一些变量、当前调用函数的返回值、调用函数的参数</li>
<li>而被调用者存储的也是自己本地的一些变量、函数返回值、入参等</li>
</ul>
<p><strong>函数调用规约最重要的就是参数的传递，入参和出参是如何传递的</strong>，故从图中我们可以看到：</p>
<ol>
<li>在调用函数之前，调用方需要将参数和返回值都存放在栈空间上</li>
<li>调用方有自己的栈存储参数</li>
<li>当调用函数完成后，被调用方的栈可以直接被销毁，因为所有返回值是被分配在调用方的栈上的</li>
</ol>
<p>没错 go 中的函数调用规约就是这样简单，所以其实你也就明白了 go 函数的多返回值是如何实现的。</p>
<h2 id="卷卷汇编"><a href="#卷卷汇编" class="headerlink" title="卷卷汇编"></a>卷卷汇编</h2><p>当然如果就是这样那也太敷衍了，上面是我告诉你的，函数调用规约是这样，但是实际真的是这样吗？我怎么样能看到函数调用的这个过程呢？下面我们就从汇编的角度看看。</p>
<h3 id="生成汇编"><a href="#生成汇编" class="headerlink" title="生成汇编"></a>生成汇编</h3><p>我们用一个最简单的函数调用来看看具体到汇编层面函数调用究竟是怎么样实现的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := Add(<span class="number">123</span>, <span class="number">321</span>)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(c <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令 <code>go tool compile -S -N -l main.go&gt;&gt; main.md</code> 生成汇编代码，下面代码中省略和函数调用无关的代码</p>
<blockquote>
<p>当前编译使用 go 版本为 1.16</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.main STEXT size=<span class="number">236</span> args=<span class="number">0x0</span> locals=<span class="number">0x78</span> funcid=<span class="number">0x0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	TEXT	<span class="string">&quot;&quot;</span>.main(SB), ABIInternal, $<span class="number">120</span><span class="number">-0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	MOVQ	(TLS), CX</span><br><span class="line">	<span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	CMPQ	SP, <span class="number">16</span>(CX)</span><br><span class="line">	<span class="number">0x000d</span> <span class="number">00013</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	PCDATA	$<span class="number">0</span>, $<span class="number">-2</span></span><br><span class="line">	<span class="number">0x000d</span> <span class="number">00013</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	JLS	<span class="number">226</span></span><br><span class="line">	<span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	PCDATA	$<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line">	<span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	SUBQ	$<span class="number">120</span>, SP</span><br><span class="line">	<span class="number">0x0017</span> <span class="number">00023</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	MOVQ	BP, <span class="number">112</span>(SP)</span><br><span class="line">	<span class="number">0x001c</span> <span class="number">00028</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	LEAQ	<span class="number">112</span>(SP), BP</span><br><span class="line">	<span class="number">0x0021</span> <span class="number">00033</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	FUNCDATA	$<span class="number">0</span>, gclocals·<span class="number">69</span>c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">	<span class="number">0x0021</span> <span class="number">00033</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	FUNCDATA	$<span class="number">1</span>, gclocals·ce02aabaa73fa33b1b70f5cfd490303f(SB)</span><br><span class="line">	<span class="number">0x0021</span> <span class="number">00033</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	FUNCDATA	$<span class="number">2</span>, <span class="string">&quot;&quot;</span>.main.stkobj(SB)</span><br><span class="line">	<span class="number">0x0021</span> <span class="number">00033</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVQ	$<span class="number">123</span>, (SP) <span class="comment">// 将当前 SP 的位置赋值为 123</span></span><br><span class="line">	<span class="number">0x0029</span> <span class="number">00041</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVQ	$<span class="number">321</span>, <span class="number">8</span>(SP) <span class="comment">// 将当前 SP+8 的位置赋值为 321</span></span><br><span class="line">	<span class="number">0x0032</span> <span class="number">00050</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></span><br><span class="line">	<span class="number">0x0032</span> <span class="number">00050</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	CALL	<span class="string">&quot;&quot;</span>.Add(SB)  <span class="comment">// 调用 Add 方法</span></span><br><span class="line">	<span class="number">0x0037</span> <span class="number">00055</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVQ	<span class="number">16</span>(SP), AX <span class="comment">// 将 SP+16 的值赋值给 AX 寄存器</span></span><br><span class="line">	<span class="number">0x003c</span> <span class="number">00060</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVQ	AX, <span class="string">&quot;&quot;</span>.c+<span class="number">48</span>(SP) <span class="comment">// 将 AX 寄存器的值赋值给 c 也就是 SP+48 的位置</span></span><br><span class="line">	...........................</span><br><span class="line"><span class="string">&quot;&quot;</span>.Add STEXT nosplit size=<span class="number">25</span> args=<span class="number">0x18</span> locals=<span class="number">0x0</span> funcid=<span class="number">0x0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	TEXT	<span class="string">&quot;&quot;</span>.Add(SB), NOSPLIT|ABIInternal, $<span class="number">0</span><span class="number">-24</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	FUNCDATA	$<span class="number">0</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	FUNCDATA	$<span class="number">1</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.c+<span class="number">24</span>(SP) <span class="comment">// 初始化 c 也就是 SP+24 为 0</span></span><br><span class="line">	<span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	MOVQ	<span class="string">&quot;&quot;</span>.a+<span class="number">8</span>(SP), AX <span class="comment">// 将 a 也就是 SP+8 赋值给 AX 寄存器</span></span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	ADDQ	<span class="string">&quot;&quot;</span>.b+<span class="number">16</span>(SP), AX <span class="comment">// 将 b 也就是 SP+16 加到 AX 寄存器</span></span><br><span class="line">	<span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	MOVQ	AX, <span class="string">&quot;&quot;</span>.c+<span class="number">24</span>(SP) <span class="comment">// 将 AX 寄存器的值赋值给 c 也就是 SP + 24</span></span><br><span class="line">	<span class="number">0x0018</span> <span class="number">00024</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	RET</span><br></pre></td></tr></table></figure>
<p>其中重要的语句我的给到了注释说明，我们可以再看看图就很清楚了</p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211107225733219.png" alt="image-20211107225733219"></p>
<p>左边是调用之前，中间是调用中，右边是调用完成</p>
<ol>
<li>可以看到，很明显调用之前，调用方就分配好了入参和出参栈上的空间用于存储</li>
<li>在执行 call 指令时，会将返回地址压栈，这里 SP 会向低地址移动 8</li>
<li>在执行 ret 指令时，会将返回地址出栈，这里 SP 会向高地址移动 8</li>
</ol>
<h3 id="go1-17-实现"><a href="#go1-17-实现" class="headerlink" title="go1.17 实现"></a>go1.17 实现</h3><p>既然都分析到这里了，我们就来看看 go1.17 是怎么样的，为什么要看 1.17 呢？因为 go 在 1.17 有一个优化，就是将函数调用由原来的栈分配改为了寄存器分配，加速了函数调用的速度，那我们来看看是怎么样做的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.main STEXT size=<span class="number">186</span> args=<span class="number">0x0</span> locals=<span class="number">0x60</span> funcid=<span class="number">0x0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	TEXT	<span class="string">&quot;&quot;</span>.main(SB), ABIInternal, $<span class="number">96</span><span class="number">-0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	CMPQ	SP, <span class="number">16</span>(R14)</span><br><span class="line">	<span class="number">0x0004</span> <span class="number">00004</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	PCDATA	$<span class="number">0</span>, $<span class="number">-2</span></span><br><span class="line">	<span class="number">0x0004</span> <span class="number">00004</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	JLS	<span class="number">176</span></span><br><span class="line">	<span class="number">0x000a</span> <span class="number">00010</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	PCDATA	$<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line">	<span class="number">0x000a</span> <span class="number">00010</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	SUBQ	$<span class="number">96</span>, SP</span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	MOVQ	BP, <span class="number">88</span>(SP)</span><br><span class="line">	<span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	LEAQ	<span class="number">88</span>(SP), BP</span><br><span class="line">	<span class="number">0x0018</span> <span class="number">00024</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	FUNCDATA	$<span class="number">0</span>, gclocals·<span class="number">69</span>c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">	<span class="number">0x0018</span> <span class="number">00024</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	FUNCDATA	$<span class="number">1</span>, gclocals·ce02aabaa73fa33b1b70f5cfd490303f(SB)</span><br><span class="line">	<span class="number">0x0018</span> <span class="number">00024</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	FUNCDATA	$<span class="number">2</span>, <span class="string">&quot;&quot;</span>.main.stkobj(SB)</span><br><span class="line">	<span class="number">0x0018</span> <span class="number">00024</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVL	$<span class="number">123</span>, AX  <span class="comment">// 将 123 放入 AX 寄存器</span></span><br><span class="line">	<span class="number">0x001d</span> <span class="number">00029</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVL	$<span class="number">321</span>, BX  <span class="comment">// 将 312 放入 BX 寄存器</span></span><br><span class="line">	<span class="number">0x0022</span> <span class="number">00034</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></span><br><span class="line">	<span class="number">0x0022</span> <span class="number">00034</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	CALL	<span class="string">&quot;&quot;</span>.Add(SB)  <span class="comment">// 调用 Add 函数</span></span><br><span class="line">	<span class="number">0x0027</span> <span class="number">00039</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVQ	AX, <span class="string">&quot;&quot;</span>.c+<span class="number">24</span>(SP) <span class="comment">// 将当前 AX 寄存器中存储的结果放到 c 中</span></span><br><span class="line">	...................................</span><br><span class="line"><span class="string">&quot;&quot;</span>.Add STEXT nosplit size=<span class="number">56</span> args=<span class="number">0x10</span> locals=<span class="number">0x10</span> funcid=<span class="number">0x0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	TEXT	<span class="string">&quot;&quot;</span>.Add(SB), NOSPLIT|ABIInternal, $<span class="number">16</span><span class="number">-16</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	SUBQ	$<span class="number">16</span>, SP  <span class="comment">// 将 SP 向低地址移动 16 bytes；意思是分配 16 bytes 栈空间</span></span><br><span class="line">	<span class="number">0x0004</span> <span class="number">00004</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	MOVQ	BP, <span class="number">8</span>(SP)  <span class="comment">// SP + 8 = BP；将 BP 的值存储到栈上</span></span><br><span class="line">	<span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	LEAQ	<span class="number">8</span>(SP), BP  <span class="comment">// BP = SP + 8</span></span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	FUNCDATA	$<span class="number">0</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	FUNCDATA	$<span class="number">1</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	FUNCDATA	$<span class="number">5</span>, <span class="string">&quot;&quot;</span>.Add.arginfo1(SB)</span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	MOVQ	AX, <span class="string">&quot;&quot;</span>.a+<span class="number">24</span>(SP)  <span class="comment">// 将 AX 寄存器中的值赋值给 a</span></span><br><span class="line">	<span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	MOVQ	BX, <span class="string">&quot;&quot;</span>.b+<span class="number">32</span>(SP)  <span class="comment">// 将 BX 寄存器中的值赋值给 b</span></span><br><span class="line">	<span class="number">0x0018</span> <span class="number">00024</span> (main.<span class="keyword">go</span>:<span class="number">12</span>)	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.c(SP)  <span class="comment">// 将 c 变量初始化为 0 值</span></span><br><span class="line">	<span class="number">0x0020</span> <span class="number">00032</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	MOVQ	<span class="string">&quot;&quot;</span>.a+<span class="number">24</span>(SP), AX  <span class="comment">// AX = 123</span></span><br><span class="line">	<span class="number">0x0025</span> <span class="number">00037</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	ADDQ	<span class="string">&quot;&quot;</span>.b+<span class="number">32</span>(SP), AX  <span class="comment">// AX = AX + 321</span></span><br><span class="line">	<span class="number">0x002a</span> <span class="number">00042</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	MOVQ	AX, <span class="string">&quot;&quot;</span>.c(SP)  <span class="comment">// c = AX；c 就拿到了计算结果 444</span></span><br><span class="line">	<span class="number">0x002e</span> <span class="number">00046</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	MOVQ	<span class="number">8</span>(SP), BP  <span class="comment">// 将当前 BP 的值复原</span></span><br><span class="line">	<span class="number">0x0033</span> <span class="number">00051</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	ADDQ	$<span class="number">16</span>, SP  <span class="comment">// 将 SP 向高地址移动 16 bytes；删除使用的栈空间</span></span><br><span class="line">	<span class="number">0x0037</span> <span class="number">00055</span> (main.<span class="keyword">go</span>:<span class="number">13</span>)	RET   <span class="comment">// 函数返回</span></span><br></pre></td></tr></table></figure>
<p>很明显对比之下就和原来的不一样了，函数的入参 a 和 b 是通过 <code>AX</code> <code>BX</code> 两个寄存器去传递的，而不是通过原有的栈去传递的，返回值也是通过 <code>AX</code> 寄存器得到的。</p>
<p>因为寄存器和 CPU 关系更好离的更近，传递速度就更快，从而就优化了函数调用的速度。</p>
<h2 id="延伸一下"><a href="#延伸一下" class="headerlink" title="延伸一下"></a>延伸一下</h2><p>那么从函数调用规约里面我们还能联系到之前的那些知识点呢？</p>
<h3 id="为什么-go-不能直接调用-c-而需要-cgo？"><a href="#为什么-go-不能直接调用-c-而需要-cgo？" class="headerlink" title="为什么 go 不能直接调用 c 而需要 cgo？"></a>为什么 go 不能直接调用 c 而需要 cgo？</h3><p>因为 c 的函数调用规约和 go 不一致</p>
<h3 id="return-和-defer-到底谁先？"><a href="#return-和-defer-到底谁先？" class="headerlink" title="return 和 defer 到底谁先？"></a>return 和 defer 到底谁先？</h3><p>return 其实包含两个步骤，一个步骤是给返回值复制，而另一个步骤是函数返回，也就是出栈了，所以其实 defer 加在中间，defer 的问题后面还会出一期来详细说说</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结两条：</p>
<ol>
<li><p>在 1.17 之前 go 的函数调用规约很简单，由调用方分配好入参和返回值的空间，调用完成之后可以直接销毁被调用方的栈空间</p>
</li>
<li><p>go1.17 函数调用中可以使用寄存器来传递参数</p>
</li>
</ol>
]]></content>
      <categories>
        <category>golang基础</category>
      </categories>
      <tags>
        <tag>func-call</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我的</title>
    <url>/about/index.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="LinkinStar"><a href="#LinkinStar" class="headerlink" title="LinkinStar"></a>LinkinStar</h2><h3 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h3><ul>
<li>谢邀，刚下飞机，人在杭州</li>
<li>创业 done -&gt; 搬砖 done -&gt; 创业 ing</li>
<li>笔名 LinkinStar 名字起源于 最喜欢的乐队 Linkin Park</li>
<li>熟悉 c.. java. golang… 等语言的单词拼写</li>
<li>文笔一般，错别字很多，见谅</li>
<li>当前较忙，随缘更新…..</li>
</ul>
<h3 id="博客经历"><a href="#博客经历" class="headerlink" title="博客经历"></a>博客经历</h3><ul>
<li>2016-02 至 2019-03 博客园 <a href="https://www.cnblogs.com/linkstar/">https://www.cnblogs.com/linkstar/</a></li>
<li>2019-03 至今 简书 <a href="https://www.jianshu.com/u/dcc4b2396fc4">https://www.jianshu.com/u/dcc4b2396fc4</a></li>
<li>2019-03 至今 个人博客 <a href="http://www.linkinstars.com/">http://www.linkinstars.com/</a> 主题从 next 切换 至 butterfly</li>
<li>站点资源详见博客底部</li>
</ul>
<h3 id="个人联系方式"><a href="#个人联系方式" class="headerlink" title="个人联系方式"></a>个人联系方式</h3><blockquote>
<p>bGlua2luc3RhckBmb3htYWlsLmNvbQo=</p>
</blockquote>
<iframe src="https://board.linkinstars.com/shared?id=6599a7ee-1a95-45eb-866f-2be055d3194c&v=b4791732-ba57-4a05-8db1-fb6330a7df34&r=d0581501-d6c6-449f-8761-c60046fa9db8" width="100%" height="600" frameborder="0" loading="lazy" allowfullscreen></iframe>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/background.css</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">#site-title {
  color: white;
}

body,
html{
  cursor: url('https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur'),auto !important;
}
a,
img {
    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur), default
}]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/randombg.js</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">//随机背景图片数组,图片可以换成图床链接，注意最后一条后面不要有逗号
var backimg = [
  "url(/img/bg1.JPG)",
  "url(/img/bg2.jpg)",
  "url(/img/bg3.jpg)",
  "url(/img/bg4.jpg)",
];
//获取背景图片总数，生成随机数
var bgindex = Math.ceil(Math.random() * (backimg.length - 1));
//重设背景图片
document.getElementById("web_bg").style.backgroundImage = backimg[bgindex];
//随机banner数组,图片可以换成图床链接，注意最后一条后面不要有逗号
var bannerimg = [
  "url(/img/bg1.JPG)",
  "url(/img/bg2.jpg)",
  "url(/img/bg3.jpg)",
  "url(/img/bg4.jpg)",
];
//获取banner图片总数，生成随机数
var bannerindex = Math.ceil(Math.random() * (bannerimg.length - 1));
//重设banner图片
document.getElementById("page-header").style.backgroundImage =
  bannerimg[bannerindex];
]]></content>
  </entry>
  <entry>
    <title>友情链接</title>
    <url>/link/index.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
  </entry>
</search>
