<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>go 中其实不复杂的 timer | LinkinStar's Blog</title><meta name="keywords" content="timer"><meta name="author" content="LinkinStar"><meta name="copyright" content="LinkinStar"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 go 中当我们需要延迟一段时间后执行，或者需要间隔固定时间去执行某个行为的时候就需要使用到 timer，那么 timer 到底是如何实现的呢？我们今天就来看看 timer 里面是什么样的。 同时因为 1.14 版本前后 timer 的实现有很大的区别，我们顺便来了解一下之前的版本和现在的版本有什么样的不一样，到底做了什么样的优化。">
<meta property="og:type" content="article">
<meta property="og:title" content="go 中其实不复杂的 timer">
<meta property="og:url" content="https://www.linkinstars.com/post/efe08c85.html">
<meta property="og:site_name" content="LinkinStar&#39;s Blog">
<meta property="og:description" content="在 go 中当我们需要延迟一段时间后执行，或者需要间隔固定时间去执行某个行为的时候就需要使用到 timer，那么 timer 到底是如何实现的呢？我们今天就来看看 timer 里面是什么样的。 同时因为 1.14 版本前后 timer 的实现有很大的区别，我们顺便来了解一下之前的版本和现在的版本有什么样的不一样，到底做了什么样的优化。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/background.jpeg">
<meta property="article:published_time" content="2021-10-10T16:00:00.000Z">
<meta property="article:modified_time" content="2021-10-31T16:25:26.293Z">
<meta property="article:author" content="LinkinStar">
<meta property="article:tag" content="timer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/background.jpeg"><link rel="shortcut icon" href="/images/favicon-32x32.png"><link rel="canonical" href="https://www.linkinstars.com/post/efe08c85"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fdfc5a0657a5391841c109d653e9ce22";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'go 中其实不复杂的 timer',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-01 00:25:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="LinkinStar's Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/LLX.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa-fw fa fa-list-ul"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-fw fa fa-universal-access"></i><span> 我的</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw fab fa-modx"></i><span> 兴趣</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fa-fw fa fa-book"></i><span> 读书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/LinkinStars/image/img/background.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LinkinStar's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa-fw fa fa-list-ul"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-fw fa fa-universal-access"></i><span> 我的</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw fab fa-modx"></i><span> 兴趣</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fa-fw fa fa-book"></i><span> 读书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">go 中其实不复杂的 timer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-10-10T16:00:00.000Z" title="undefined 2021-10-11 00:00:00">2021-10-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">golang源码解析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="go 中其实不复杂的 timer"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 go 中当我们需要延迟一段时间后执行，或者需要间隔固定时间去执行某个行为的时候就需要使用到 timer，那么 timer 到底是如何实现的呢？我们今天就来看看 timer 里面是什么样的。</p>
<p>同时因为 1.14 版本前后 timer 的实现有很大的区别，我们顺便来了解一下之前的版本和现在的版本有什么样的不一样，到底做了什么样的优化。</p>
<span id="more"></span>
<h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><p>有以下的知识点支持才能更好的理解今天的分析</p>
<ul>
<li>需要有 GMP 模型的基础</li>
<li>需要有 go 调度相关的基础</li>
<li>需要有数据结构中’堆‘的基础</li>
</ul>
<h2 id="ticker"><a href="#ticker" class="headerlink" title="ticker"></a>ticker</h2><p>要看 timer 可以先从 ticker 入手，ticker 其实我们经常使用到，ticker 顾名思义就是每次间隔一段时间触发一次，下面我们就来看看它的具体实现</p>
<h3 id="带着问题"><a href="#带着问题" class="headerlink" title="带着问题"></a>带着问题</h3><ul>
<li>Ticker 如果当前时间到了，没有及时处理，下一次时间到了，会保留吗？是都在后面排队，还是直接被丢弃了？</li>
<li><code>NewTicker()</code> 和 <code>Tick()</code> 有什么区别？使用上需要注意什么？</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Ticker holds a channel that delivers ``ticks&#x27;&#x27; of a clock</span></span><br><span class="line"><span class="comment">// at intervals.</span></span><br><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;-<span class="keyword">chan</span> Time <span class="comment">// The channel on which the ticks are delivered.</span></span><br><span class="line">	r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它的数据结构非常简单，就是一个 channel 当时间到达就会向这个 channel 里面发送一个触发的时间</p>
<h3 id="Start-Stop-Reset"><a href="#Start-Stop-Reset" class="headerlink" title="Start Stop Reset"></a>Start Stop Reset</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewTicker returns a new Ticker containing a channel that will send</span></span><br><span class="line"><span class="comment">// the time on the channel after each tick. The period of the ticks is</span></span><br><span class="line"><span class="comment">// specified by the duration argument. The ticker will adjust the time</span></span><br><span class="line"><span class="comment">// interval or drop ticks to make up for slow receivers.</span></span><br><span class="line"><span class="comment">// The duration d must be greater than zero; if not, NewTicker will</span></span><br><span class="line"><span class="comment">// panic. Stop the ticker to release associated resources.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span> *<span class="title">Ticker</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errors.New(<span class="string">&quot;non-positive interval for NewTicker&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Give the channel a 1-element time buffer.</span></span><br><span class="line">	<span class="comment">// If the client falls behind while reading, we drop ticks</span></span><br><span class="line">	<span class="comment">// on the floor until the client catches up.</span></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">	t := &amp;Ticker&#123;</span><br><span class="line">		C: c,</span><br><span class="line">		r: runtimeTimer&#123;</span><br><span class="line">			when:   when(d),</span><br><span class="line">			period: <span class="keyword">int64</span>(d),</span><br><span class="line">			f:      sendTime,</span><br><span class="line">			arg:    c,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	startTimer(&amp;t.r)</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop turns off a ticker. After Stop, no more ticks will be sent.</span></span><br><span class="line"><span class="comment">// Stop does not close the channel, to prevent a concurrent goroutine</span></span><br><span class="line"><span class="comment">// reading from the channel from seeing an erroneous &quot;tick&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stopTimer(&amp;t.r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset stops a ticker and resets its period to the specified duration.</span></span><br><span class="line"><span class="comment">// The next tick will arrive after the new period elapses.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">Reset</span><span class="params">(d Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.r.f == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;time: Reset called on uninitialized Ticker&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	modTimer(&amp;t.r, when(d), <span class="keyword">int64</span>(d), t.r.f, t.r.arg, t.r.seq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点有以下几个：</p>
<ul>
<li>ticker 中的 channel 长度为 1，这也就意味着里面只能放一个触发的时间，也就是说如果当前这次触发没有处理完成，下次触发来了可以先存着，但是再下一次就直接会被抛弃了。你是不是奇怪为什么要单独提出这一点来说，想要说明的是，ticker 的使用并不能保证一定间隔相同的时间触发，如果你再处理过程中阻塞住了，间隔时间短就可能出现连续，所以处理一定要保证及时。</li>
<li>stop 并不会关闭 channel，因为并发的时候可能同时到了触发时间，如果关闭了 channel 就有可能出现往一个关闭的 channel 中发消息的 panic；但也只有 stop 了之后相关的资源才会得到释放，所以用完之后记得关闭</li>
</ul>
<p>可以看到三个方法都比较简单，主要就是利用 timer 去实现的 ticker，所有我们主要需要关注在 <code>startTimer</code> <code>stopTimer</code> <code>modTimer</code> 方法上</p>
<h3 id="Tick-方法"><a href="#Tick-方法" class="headerlink" title="Tick 方法"></a>Tick 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tick is a convenience wrapper for NewTicker providing access to the ticking</span></span><br><span class="line"><span class="comment">// channel only. While Tick is useful for clients that have no need to shut down</span></span><br><span class="line"><span class="comment">// the Ticker, be aware that without a way to shut it down the underlying</span></span><br><span class="line"><span class="comment">// Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;.</span></span><br><span class="line"><span class="comment">// Unlike NewTicker, Tick will return nil if d &lt;= 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NewTicker(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里我们很明显可以看到，其实 Tick 方法就是对 NewTicker 的一个封装，让使用 Ticker 更加简单，直接一行代码搞定，但是随之带来的就是你没有办法去关闭这个 Ticker 了。<br>这也就意味着会导致内存泄露，所以一般在项目中都会使用 NewTicker 方法，除非你的项目当 Tick 停止时就已经直接退出了，那也不必考虑这个问题。</p>
<p>好了，现在我们可以聚焦到这次我们的主角了 <code>Timer</code> 上了</p>
<h2 id="go1-13-的-Timer"><a href="#go1-13-的-Timer" class="headerlink" title="go1.13 的 Timer"></a>go1.13 的 Timer</h2><p>老版本的 timer 实现比较简单，代码也比较清晰</p>
<h3 id="startTimer"><a href="#startTimer" class="headerlink" title="startTimer"></a>startTimer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racerelease(unsafe.Pointer(t))</span><br><span class="line">	&#125;</span><br><span class="line">	addtimer(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，首先是分配了一个 bucket 然后加锁之后开始 <code>addtimerLocked</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">	tb := t.assignBucket()</span><br><span class="line">	lock(&amp;tb.lock)</span><br><span class="line">	ok := tb.addtimerLocked(t)</span><br><span class="line">	unlock(&amp;tb.lock)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		badTimer()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timersLen = <span class="number">64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span> <span class="title">assignBucket</span><span class="params">()</span> *<span class="title">timersBucket</span></span> &#123;</span><br><span class="line">	id := <span class="keyword">uint8</span>(getg().m.p.ptr().id) % timersLen</span><br><span class="line">	t.tb = &amp;timers[id].timersBucket</span><br><span class="line">	<span class="keyword">return</span> t.tb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a timer to the heap and start or kick timerproc if the new timer is</span></span><br><span class="line"><span class="comment">// earlier than any of the others.</span></span><br><span class="line"><span class="comment">// Timers are locked.</span></span><br><span class="line"><span class="comment">// Returns whether all is well: false if the data structure is corrupt</span></span><br><span class="line"><span class="comment">// due to user-level races.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *timersBucket)</span> <span class="title">addtimerLocked</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// when must never be negative; otherwise timerproc will overflow</span></span><br><span class="line">	<span class="comment">// during its delta calculation and never expire other runtime timers.</span></span><br><span class="line">	<span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123;</span><br><span class="line">		t.when = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.i = <span class="built_in">len</span>(tb.t)</span><br><span class="line">	tb.t = <span class="built_in">append</span>(tb.t, t)</span><br><span class="line">	<span class="keyword">if</span> !siftupTimer(tb.t, t.i) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.i == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// siftup moved to top: new earliest deadline.</span></span><br><span class="line">		<span class="keyword">if</span> tb.sleeping &amp;&amp; tb.sleepUntil &gt; t.when &#123;</span><br><span class="line">			tb.sleeping = <span class="literal">false</span></span><br><span class="line">			notewakeup(&amp;tb.waitnote)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tb.rescheduling &#123;</span><br><span class="line">			tb.rescheduling = <span class="literal">false</span></span><br><span class="line">			goready(tb.gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !tb.created &#123;</span><br><span class="line">			tb.created = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">go</span> timerproc(tb)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当看到 <code>siftupTimer</code> 这个方法的时候你应该就豁然开朗了，因为这个很明显的就是一个堆的操作，只不过这里的堆是一个 4 叉堆，你看它找父节点的时候是 /4 的，<code>siftdownTimer</code> 也是类似这里也不多赘述了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftupTimer</span><span class="params">(t []*timer, i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(t) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	when := t[i].when</span><br><span class="line">	tmp := t[i]</span><br><span class="line">	<span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">		p := (i - <span class="number">1</span>) / <span class="number">4</span> <span class="comment">// parent</span></span><br><span class="line">		<span class="keyword">if</span> when &gt;= t[p].when &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		t[i] = t[p]</span><br><span class="line">		t[i].i = i</span><br><span class="line">		i = p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tmp != t[i] &#123;</span><br><span class="line">		t[i] = tmp</span><br><span class="line">		t[i].i = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说启动一个 timer 就是三步走</p>
<ul>
<li>加锁</li>
<li>将新的 timer 添加到数组末尾</li>
<li>堆化</li>
</ul>
<h3 id="stopTimer"><a href="#stopTimer" class="headerlink" title="stopTimer"></a>stopTimer</h3><p>其实知道了启动停止就不难了，也是类似的，从数组中删除之后然后堆化就可以了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stopTimer removes t from the timer heap if it is there.</span></span><br><span class="line"><span class="comment">// It returns true if t was removed, false if t wasn&#x27;t even there.</span></span><br><span class="line"><span class="comment">//go:linkname stopTimer time.stopTimer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTimer</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> deltimer(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete timer t from the heap.</span></span><br><span class="line"><span class="comment">// Do not need to update the timerproc: if it wakes up early, no big deal.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deltimer</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.tb == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// t.tb can be nil if the user created a timer</span></span><br><span class="line">		<span class="comment">// directly, without invoking startTimer e.g</span></span><br><span class="line">		<span class="comment">//    time.Ticker&#123;C: c&#125;</span></span><br><span class="line">		<span class="comment">// In this case, return early without any deletion.</span></span><br><span class="line">		<span class="comment">// See Issue 21874.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tb := t.tb</span><br><span class="line"></span><br><span class="line">	lock(&amp;tb.lock)</span><br><span class="line">	removed, ok := tb.deltimerLocked(t)</span><br><span class="line">	unlock(&amp;tb.lock)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		badTimer()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> removed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *timersBucket)</span> <span class="title">deltimerLocked</span><span class="params">(t *timer)</span> <span class="params">(removed, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// t may not be registered anymore and may have</span></span><br><span class="line">	<span class="comment">// a bogus i (typically 0, if generated by Go).</span></span><br><span class="line">	<span class="comment">// Verify it before proceeding.</span></span><br><span class="line">	i := t.i</span><br><span class="line">	last := <span class="built_in">len</span>(tb.t) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt; last || tb.t[i] != t &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i != last &#123;</span><br><span class="line">		tb.t[i] = tb.t[last]</span><br><span class="line">		tb.t[i].i = i</span><br><span class="line">	&#125;</span><br><span class="line">	tb.t[last] = <span class="literal">nil</span></span><br><span class="line">	tb.t = tb.t[:last]</span><br><span class="line">	ok = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> i != last &#123;</span><br><span class="line">		<span class="keyword">if</span> !siftupTimer(tb.t, i) &#123;</span><br><span class="line">			ok = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !siftdownTimer(tb.t, i) &#123;</span><br><span class="line">			ok = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="何时触发？"><a href="#何时触发？" class="headerlink" title="何时触发？"></a>何时触发？</h3><p>那么问题来了，时间到了之后什么地方在触发往 timer 中的 channel 中发数据呢？其实前面的源码中已经给出了细节，在 <code>addtimerLocked</code> 方法中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !tb.created &#123;</span><br><span class="line">	tb.created = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// 这里创建了一个 goroutine 专门来运行 timerproc 方法</span></span><br><span class="line">	<span class="keyword">go</span> timerproc(tb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的时候会调用 <code>timerproc</code> 方法，我们来看看这个方法里面做了什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Timerproc runs the time-driven events.</span></span><br><span class="line"><span class="comment">// It sleeps until the next event in the tb heap.</span></span><br><span class="line"><span class="comment">// If addtimer inserts a new earlier event, it wakes timerproc early.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line">	tb.gp = getg()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		lock(&amp;tb.lock)</span><br><span class="line">		tb.sleeping = <span class="literal">false</span></span><br><span class="line">		now := nanotime()</span><br><span class="line">		delta := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(tb.t) == <span class="number">0</span> &#123;</span><br><span class="line">				delta = <span class="number">-1</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取堆顶元素</span></span><br><span class="line">			t := tb.t[<span class="number">0</span>]</span><br><span class="line">			<span class="comment">// 看是否满足触发时间</span></span><br><span class="line">			delta = t.when - now</span><br><span class="line">			<span class="keyword">if</span> delta &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			ok := <span class="literal">true</span></span><br><span class="line">			<span class="comment">// 当 period &gt; 0 则说明这是一个需要周期性触发的 timer 也就是 ticker，否则就触发一次后直接从堆里面移除</span></span><br><span class="line">			<span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// leave in heap but adjust next time to fire</span></span><br><span class="line">				<span class="comment">// 修改当前元素的触发时间，然后直接开始堆化即可，自己就排到后面去了</span></span><br><span class="line">				t.when += t.period * (<span class="number">1</span> + -delta/t.period)</span><br><span class="line">				<span class="keyword">if</span> !siftdownTimer(tb.t, <span class="number">0</span>) &#123;</span><br><span class="line">					ok = <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// remove from heap</span></span><br><span class="line">				last := <span class="built_in">len</span>(tb.t) - <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">					tb.t[<span class="number">0</span>] = tb.t[last]</span><br><span class="line">					tb.t[<span class="number">0</span>].i = <span class="number">0</span></span><br><span class="line">				&#125;</span><br><span class="line">				tb.t[last] = <span class="literal">nil</span></span><br><span class="line">				tb.t = tb.t[:last]</span><br><span class="line">				<span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> !siftdownTimer(tb.t, <span class="number">0</span>) &#123;</span><br><span class="line">						ok = <span class="literal">false</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				t.i = <span class="number">-1</span> <span class="comment">// mark as removed</span></span><br><span class="line">			&#125;</span><br><span class="line">			f := t.f</span><br><span class="line">			arg := t.arg</span><br><span class="line">			seq := t.seq</span><br><span class="line">			unlock(&amp;tb.lock)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				badTimer()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				raceacquire(unsafe.Pointer(t))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这里就是真正触发定时方法的地方，如果是 ticker 的话就是初始化的 sendTime 方法，就是将当前时间发送到 channel 中</span></span><br><span class="line">			f(arg, seq)</span><br><span class="line">			lock(&amp;tb.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delta &lt; <span class="number">0</span> || faketime &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// No timers left - put goroutine to sleep.</span></span><br><span class="line">			tb.rescheduling = <span class="literal">true</span></span><br><span class="line">			goparkunlock(&amp;tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// At least one timer pending. Sleep until then.</span></span><br><span class="line">		<span class="comment">// 这里可以看到，如果对顶元素还没有到对应的触发时间，那么就睡眠相对应的时间即可</span></span><br><span class="line">		tb.sleeping = <span class="literal">true</span></span><br><span class="line">		tb.sleepUntil = now + delta</span><br><span class="line">		noteclear(&amp;tb.waitnote)</span><br><span class="line">		unlock(&amp;tb.lock)</span><br><span class="line">		notetsleepg(&amp;tb.waitnote, delta)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到整体思路很清晰，就是将最先触发的元素拿出来，然后判断是否到时间，如果到了时间就触发，如果没到，就睡眠一个 delta 的时间等待触发。当然在 <code>addtimerLocked</code> 方法中也会尝试唤醒 (调用<code>notewakeup</code>方法)，因为新加入的 timer 肯定会影响当前整个堆的下一次触发时间。</p>
<p>所以总的来说在 go1.13 版本中，timer 的实现还是比较简单清晰的</p>
<h2 id="go1-17-的-Timer"><a href="#go1-17-的-Timer" class="headerlink" title="go1.17 的 Timer"></a>go1.17 的 Timer</h2><p>那么我们来看看现在版本的 timer 是如何实现的，因为我们上面详细看过，这里就省略其中部分。</p>
<p>在当前新的版本中对于 timer 的定义有了各种状态的表示，下面的注释也很清晰，标识了各种状态所出现的情况，至于状态的转换这里就不给出具体的状态图了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for the timer status field.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Timer has no status set yet.</span></span><br><span class="line">	timerNoStatus = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Waiting for timer to fire.</span></span><br><span class="line">	<span class="comment">// The timer is in some P&#x27;s heap.</span></span><br><span class="line">	timerWaiting</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Running the timer function.</span></span><br><span class="line">	<span class="comment">// A timer will only have this status briefly.</span></span><br><span class="line">	timerRunning</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer is deleted and should be removed.</span></span><br><span class="line">	<span class="comment">// It should not be run, but it is still in some P&#x27;s heap.</span></span><br><span class="line">	timerDeleted</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer is being removed.</span></span><br><span class="line">	<span class="comment">// The timer will only have this status briefly.</span></span><br><span class="line">	timerRemoving</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer has been stopped.</span></span><br><span class="line">	<span class="comment">// It is not in any P&#x27;s heap.</span></span><br><span class="line">	timerRemoved</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer is being modified.</span></span><br><span class="line">	<span class="comment">// The timer will only have this status briefly.</span></span><br><span class="line">	timerModifying</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer has been modified to an earlier time.</span></span><br><span class="line">	<span class="comment">// The new when value is in the nextwhen field.</span></span><br><span class="line">	<span class="comment">// The timer is in some P&#x27;s heap, possibly in the wrong place.</span></span><br><span class="line">	timerModifiedEarlier</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer has been modified to the same or a later time.</span></span><br><span class="line">	<span class="comment">// The new when value is in the nextwhen field.</span></span><br><span class="line">	<span class="comment">// The timer is in some P&#x27;s heap, possibly in the wrong place.</span></span><br><span class="line">	timerModifiedLater</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer has been modified and is being moved.</span></span><br><span class="line">	<span class="comment">// The timer will only have this status briefly.</span></span><br><span class="line">	timerMoving</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="addtimer"><a href="#addtimer" class="headerlink" title="addtimer"></a>addtimer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addtimer adds a timer to the current P.</span></span><br><span class="line"><span class="comment">// This should only be called with a newly created timer.</span></span><br><span class="line"><span class="comment">// That avoids the risk of changing the when field of a timer in some P&#x27;s heap,</span></span><br><span class="line"><span class="comment">// which could cause the heap to become unsorted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">	<span class="comment">//.................</span></span><br><span class="line"></span><br><span class="line">	when := t.when</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable preemption while using pp to avoid changing another P&#x27;s heap.</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前 g 所绑定的 m，然后再拿到绑定的 p</span></span><br><span class="line">	pp := getg().m.p.ptr()</span><br><span class="line">	lock(&amp;pp.timersLock)</span><br><span class="line">	<span class="comment">// 首先做清除，清除那些已经标记为删除的 timer</span></span><br><span class="line">	cleantimers(pp)</span><br><span class="line">	<span class="comment">// 然后将当前的 timer 加入到当前 p 所属的 timer 列表中</span></span><br><span class="line">	doaddtimer(pp, t)</span><br><span class="line">	unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	wakeNetPoller(when)</span><br><span class="line"></span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doaddtimer adds t to the current P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doaddtimer</span><span class="params">(pp *p, t *timer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...............</span></span><br><span class="line">	</span><br><span class="line">	t.pp.set(pp)</span><br><span class="line">	i := <span class="built_in">len</span>(pp.timers)</span><br><span class="line">	<span class="comment">// 这里的操作和之前类似，只不过这次不是放在桶里了，而是放到了 P 上，放完之后依旧是堆化</span></span><br><span class="line">	pp.timers = <span class="built_in">append</span>(pp.timers, t)</span><br><span class="line">	siftupTimer(pp.timers, i)</span><br><span class="line">	<span class="keyword">if</span> t == pp.timers[<span class="number">0</span>] &#123;</span><br><span class="line">		atomic.Store64(&amp;pp.timer0When, <span class="keyword">uint64</span>(t.when))</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.Xadd(&amp;pp.numTimers, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ..............</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lock for timers. We normally access the timers while running</span></span><br><span class="line">	<span class="comment">// on this P, but the scheduler can also do it from a different P.</span></span><br><span class="line">	timersLock mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// P 里面是有一个专门的地方来保存这个 timer 堆的</span></span><br><span class="line">	<span class="comment">// Actions to take at some time. This is used to implement the</span></span><br><span class="line">	<span class="comment">// standard library&#x27;s time package.</span></span><br><span class="line">	<span class="comment">// Must hold timersLock to access.</span></span><br><span class="line">	timers []*timer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of timers in P&#x27;s heap.</span></span><br><span class="line">	<span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">	numTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of timerDeleted timers in P&#x27;s heap.</span></span><br><span class="line">	<span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">	deletedTimers <span class="keyword">uint32</span></span><br><span class="line">	<span class="comment">// ..............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到我们的 timer 堆已经不再是一个放在全局各个桶下面的了，而是在 P 内部保存 timer 堆，其他和原来的基本思路一致</p>
<h3 id="deltimer"><a href="#deltimer" class="headerlink" title="deltimer"></a>deltimer</h3><p>删除和原来的操作就不一样了，原先删除后会直接进行堆的操作，而在新版本中不是的，只是标记了状态，根据当前不同的状态进行操作，如：没有运行怎么办，或已经运行了怎么办，当前还未被添加….</p>
<p>而在 <code>cleantimers</code> 方法中会对已经标记为删除的 timer 做相对应的处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deltimer deletes the timer t. It may be on some other P, so we can&#x27;t</span></span><br><span class="line"><span class="comment">// actually remove it from the timers heap. We can only mark it as deleted.</span></span><br><span class="line"><span class="comment">// It will be removed in due course by the P whose heap it is on.</span></span><br><span class="line"><span class="comment">// Reports whether the timer was removed before it was run.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deltimer</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">		<span class="keyword">case</span> timerWaiting, timerModifiedLater:</span><br><span class="line">			<span class="comment">// Prevent preemption while the timer is in timerModifying.</span></span><br><span class="line">			<span class="comment">// This could lead to a self-deadlock. See #38070.</span></span><br><span class="line">			mp := acquirem()</span><br><span class="line">			<span class="keyword">if</span> atomic.Cas(&amp;t.status, s, timerModifying) &#123;</span><br><span class="line">				<span class="comment">// Must fetch t.pp before changing status,</span></span><br><span class="line">				<span class="comment">// as cleantimers in another goroutine</span></span><br><span class="line">				<span class="comment">// can clear t.pp of a timerDeleted timer.</span></span><br><span class="line">				tpp := t.pp.ptr()</span><br><span class="line">				<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerModifying, timerDeleted) &#123;</span><br><span class="line">					badTimer()</span><br><span class="line">				&#125;</span><br><span class="line">				releasem(mp)</span><br><span class="line">				atomic.Xadd(&amp;tpp.deletedTimers, <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// Timer was not yet run.</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				releasem(mp)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> timerModifiedEarlier:</span><br><span class="line">			<span class="comment">// Prevent preemption while the timer is in timerModifying.</span></span><br><span class="line">			<span class="comment">// This could lead to a self-deadlock. See #38070.</span></span><br><span class="line">			mp := acquirem()</span><br><span class="line">			<span class="keyword">if</span> atomic.Cas(&amp;t.status, s, timerModifying) &#123;</span><br><span class="line">				<span class="comment">// Must fetch t.pp before setting status</span></span><br><span class="line">				<span class="comment">// to timerDeleted.</span></span><br><span class="line">				tpp := t.pp.ptr()</span><br><span class="line">				<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerModifying, timerDeleted) &#123;</span><br><span class="line">					badTimer()</span><br><span class="line">				&#125;</span><br><span class="line">				releasem(mp)</span><br><span class="line">				atomic.Xadd(&amp;tpp.deletedTimers, <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// Timer was not yet run.</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				releasem(mp)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> timerDeleted, timerRemoving, timerRemoved:</span><br><span class="line">			<span class="comment">// Timer was already run.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		<span class="keyword">case</span> timerRunning, timerMoving:</span><br><span class="line">			<span class="comment">// The timer is being run or moved, by a different P.</span></span><br><span class="line">			<span class="comment">// Wait for it to complete.</span></span><br><span class="line">			osyield()</span><br><span class="line">		<span class="keyword">case</span> timerNoStatus:</span><br><span class="line">			<span class="comment">// Removing timer that was never added or</span></span><br><span class="line">			<span class="comment">// has already been run. Also see issue 21874.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		<span class="keyword">case</span> timerModifying:</span><br><span class="line">			<span class="comment">// Simultaneous calls to deltimer and modtimer.</span></span><br><span class="line">			<span class="comment">// Wait for the other call to complete.</span></span><br><span class="line">			osyield()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			badTimer()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="何时触发？-1"><a href="#何时触发？-1" class="headerlink" title="何时触发？"></a>何时触发？</h3><p>那么问题来了，在新版本里面是什么时候出发的。其实如果之前没有看过调度相关的源码还真的有点难找。</p>
<ol>
<li><code>schedule -&gt; checkTimers -&gt; runtimer</code></li>
<li><code>stealWork -&gt; checkTimers -&gt; runtimer</code></li>
<li><code>findrunnable -&gt; checkTimers -&gt; runtimer</code></li>
</ol>
<p>其实是当调度的时候触发的 timer 检查，检查的时候触发的对应执行。而且如果你第一次看你会觉得神奇，为什么 work steal 的时候还会进行 timer 的检查呢？我们慢慢往下看。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ....................</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	pp := _g_.m.p.ptr()</span><br><span class="line">	pp.preempt = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pp.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sanity check: if we are spinning, the run queue should be empty.</span></span><br><span class="line">	<span class="comment">// Check this before calling checkTimers, as that might call</span></span><br><span class="line">	<span class="comment">// goready to put a ready goroutine on the local run queue.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &amp;&amp; (pp.runnext != <span class="number">0</span> || pp.runqhead != pp.runqtail) &#123;</span><br><span class="line">		throw(<span class="string">&quot;schedule: spinning with local work&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	checkTimers(pp, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ..................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finds a runnable goroutine to execute.</span></span><br><span class="line"><span class="comment">// Tries to steal from other P&#x27;s, get g from local or global queue, poll network.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line">	<span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line">	<span class="comment">// an M.</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	now, pollUntil, _ := checkTimers(_p_, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ..................</span></span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，确实是在调度的时候触发的 <code>checkTimers</code> 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkTimers</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="params">(rnow, pollUntil <span class="keyword">int64</span>, ran <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If it&#x27;s not yet time for the first timer, or the first adjusted</span></span><br><span class="line">	<span class="comment">// timer, then there is nothing to do.</span></span><br><span class="line">	next := <span class="keyword">int64</span>(atomic.Load64(&amp;pp.timer0When))</span><br><span class="line">	nextAdj := <span class="keyword">int64</span>(atomic.Load64(&amp;pp.timerModifiedEarliest))</span><br><span class="line">	<span class="keyword">if</span> next == <span class="number">0</span> || (nextAdj != <span class="number">0</span> &amp;&amp; nextAdj &lt; next) &#123;</span><br><span class="line">		next = nextAdj</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// No timers to run or adjust.</span></span><br><span class="line">		<span class="keyword">return</span> now, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">		now = nanotime()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> now &lt; next &#123;</span><br><span class="line">		<span class="comment">// Next timer is not ready to run, but keep going</span></span><br><span class="line">		<span class="comment">// if we would clear deleted timers.</span></span><br><span class="line">		<span class="comment">// This corresponds to the condition below where</span></span><br><span class="line">		<span class="comment">// we decide whether to call clearDeletedTimers.</span></span><br><span class="line">		<span class="comment">// 当下一次触发实现还没有到的时候，这里有一个小细节，当需要删除 timer 个数小于 1/4 的时候是不操作的，直接返回，也就是说等着批量一起处理</span></span><br><span class="line">		<span class="keyword">if</span> pp != getg().m.p.ptr() || <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &lt;= <span class="keyword">int</span>(atomic.Load(&amp;pp.numTimers)/<span class="number">4</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> now, next, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 进行当前 p 的 timer 堆的调整，这个方法里面还有很多细节，这里不展开，推荐看一眼</span></span><br><span class="line">		adjusttimers(pp, now)</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Note that runtimer may temporarily unlock</span></span><br><span class="line">			<span class="comment">// pp.timersLock.</span></span><br><span class="line">			<span class="comment">// 如果有需要执行的 timer 的话，那么就调用 runtimer 方法去执行</span></span><br><span class="line">			<span class="keyword">if</span> tw := runtimer(pp, now); tw != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> tw &gt; <span class="number">0</span> &#123;</span><br><span class="line">					pollUntil = tw</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			ran = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is the local P, and there are a lot of deleted timers,</span></span><br><span class="line">	<span class="comment">// clear them out. We only do this for the local P to reduce</span></span><br><span class="line">	<span class="comment">// lock contention on timersLock.</span></span><br><span class="line">	<span class="keyword">if</span> pp == getg().m.p.ptr() &amp;&amp; <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &gt; <span class="built_in">len</span>(pp.timers)/<span class="number">4</span> &#123;</span><br><span class="line">		clearDeletedTimers(pp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> now, pollUntil, ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们就来赶紧看看 runtimer 方法到底是如何运行的吧</p>
<h3 id="runtimer"><a href="#runtimer" class="headerlink" title="runtimer"></a>runtimer</h3><p>这个方法其实非常简单，就是将堆顶元素取出来看状态，根据不同状态去处理，如果满足运行时间则运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtimer</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 取出堆顶元素</span></span><br><span class="line">		t := pp.timers[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">			throw(<span class="string">&quot;runtimer: bad p&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">		<span class="keyword">case</span> timerWaiting:</span><br><span class="line">			<span class="keyword">if</span> t.when &gt; now &#123;</span><br><span class="line">				<span class="comment">// Not ready to run.</span></span><br><span class="line">				<span class="keyword">return</span> t.when</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRunning) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Note that runOneTimer may temporarily unlock</span></span><br><span class="line">			<span class="comment">// pp.timersLock.</span></span><br><span class="line">			<span class="comment">// 如果已经到了当前触发时间，就运行当前这个 timer</span></span><br><span class="line">			runOneTimer(pp, t, now)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">case</span> timerDeleted:</span><br><span class="line">			<span class="comment">//.....................</span></span><br><span class="line">		<span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line">			<span class="comment">//.....................</span></span><br><span class="line">		<span class="keyword">case</span> timerModifying:</span><br><span class="line">			osyield()</span><br><span class="line">		<span class="keyword">case</span> timerNoStatus, timerRemoved:</span><br><span class="line">			badTimer()</span><br><span class="line">		<span class="keyword">case</span> timerRunning, timerRemoving, timerMoving:</span><br><span class="line">			badTimer()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			badTimer()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行其实和原来的逻辑是一样的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runOneTimer</span><span class="params">(pp *p, t *timer, now <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line"></span><br><span class="line">	f := t.f</span><br><span class="line">	arg := t.arg</span><br><span class="line">	seq := t.seq</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里的逻辑和原来的 timerproc 中的逻辑是一致的</span></span><br><span class="line">	<span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Leave in heap but adjust next time to fire.</span></span><br><span class="line">		delta := t.when - now</span><br><span class="line">		t.when += t.period * (<span class="number">1</span> + -delta/t.period)</span><br><span class="line">		<span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123; <span class="comment">// check for overflow.</span></span><br><span class="line">			t.when = maxWhen</span><br><span class="line">		&#125;</span><br><span class="line">		siftdownTimer(pp.timers, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRunning, timerWaiting) &#123;</span><br><span class="line">			badTimer()</span><br><span class="line">		&#125;</span><br><span class="line">		updateTimer0When(pp)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Remove from heap.</span></span><br><span class="line">		dodeltimer0(pp)</span><br><span class="line">		<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRunning, timerNoStatus) &#123;</span><br><span class="line">			badTimer()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line"></span><br><span class="line">	unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里就是真正执行触发的方法了</span></span><br><span class="line">	f(arg, seq)</span><br><span class="line"></span><br><span class="line">	lock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="moveTimer"><a href="#moveTimer" class="headerlink" title="moveTimer"></a>moveTimer</h3><p>你以为这样就没有了？还有什么问题我们没有考虑到呢？我们现在已经知道新版本的 timer 堆是在 P 上的了，那么问题来了，当 P 被销毁的时候，可能当前的 P 上还有 timer 呢，那这些 timer 应该怎么办？当然是移走咯</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">	assertLockHeld(&amp;sched.lock)</span><br><span class="line">	assertWorldStopped()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 找一个别的 P</span></span><br><span class="line">		plocal := getg().m.p.ptr()</span><br><span class="line">		<span class="comment">// The world is stopped, but we acquire timersLock to</span></span><br><span class="line">		<span class="comment">// protect against sysmon calling timeSleepUntil.</span></span><br><span class="line">		<span class="comment">// This is the only case where we hold the timersLock of</span></span><br><span class="line">		<span class="comment">// more than one P, so there are no deadlock concerns.</span></span><br><span class="line">		lock(&amp;plocal.timersLock)</span><br><span class="line">		lock(&amp;pp.timersLock)</span><br><span class="line">		<span class="comment">// 这里把当前 P 上的 timer 都移走</span></span><br><span class="line">		moveTimers(plocal, pp.timers)</span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h2><p>看完了源码你会发现，1.14 前后 timer 变化点主要在两个方面:</p>
<ol>
<li>存储方式由原来的放在全局的桶里转而放到了 P 上</li>
<li>触发方式的由原来的单个 goroutine 方法循环定期触发改为调度中触发</li>
</ol>
<p>接下来就是篇的最后重点部分了：为什么 1.14 前后 timer 需要做这样的优化？更快了吗？</p>
<p>我用图来让你快速明白为什么会有这个改动。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211101002348919.png" alt="image-20211101002348919"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211101002408162.png" alt="image-20211101002408162"></p>
<p>存储结构上的改变很容易看出来，就是从原来的桶换成了 P，那么为什么呢？</p>
<h3 id="问题关键"><a href="#问题关键" class="headerlink" title="问题关键"></a>问题关键</h3><p><img src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/image-20211101001552833.png" alt="image-20211101001552833"></p>
<p>PS：图中的 TP 意思是 运行 timerproc 的 G</p>
<p>可以看到，改动之前，timer 的触发需要频繁的做 M 和 P 的绑定和解绑操作。</p>
<p>就这？对这就是问题的关键。我们举个例子，如果有一个 ticker 每秒触发一次，每触发一次就需要绑定一次 M 解绑一次，而当系统中的 timer 越来越多，那么随之带来的就是越加频繁的切换了。</p>
<p>而改动之后，timer 的触发是在调度循环里面，而且存储在本地的 P 中，<strong>所以没有了绑定和解绑的过程</strong>，也不再需要一个运行 <code>timerproc</code> goroutine 单独去维护触发。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面回顾总结几个点：</p>
<ol>
<li>timer 堆从原有的桶移动到了 P 上，是为了解决频繁切换 MP 的问题。</li>
<li>因为 checkTimers 是在调度循环里面执行的，所以一些操作被延后执行，比如删除 timer 的操作只是修改状态，而懒到后面一起去执行。</li>
<li>其实 timer 的设计说到底还是一个堆的存储，然后堆顶就是下一次最近要执行的 timer。</li>
</ol>
<p>总的来说 timer 的实现还是比较清晰的，其实更老的版本中，一开始 timer 的实现的堆只有一个，而为了优化全局锁的并发性能才出现了 64 个桶这样的结构，然后又发现了切换的性能问题，继续优化才有了现在的 timer。所以其实现在看来很多 go 里面复杂的设计原本都是也是由一个非常简单的设计演变而来的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LinkinStar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.linkinstars.com/post/efe08c85.html">https://www.linkinstars.com/post/efe08c85.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.linkinstars.com" target="_blank">LinkinStar's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/timer/">timer</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/background.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/images/wechatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/122ec973.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我怎么从来没见过 sync.Cond</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/LinkinStars/image/img/LLX.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">LinkinStar</div><div class="author-info__description">No one but myself can do it.<br> Don't worry. Be happy!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LinkinStars"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LinkinStars" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:linkinstar@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.jianshu.com/u/dcc4b2396fc4" target="_blank" title="简书"><i class="fas fa-book"></i></a><a class="social-icon" href="https://www.cnblogs.com/linkstar" target="_blank" title="博客园"><i class="fas fa-link"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"><a target='_blank' href='https://board.linkinstars.com/shared?id=6599a7ee-1a95-45eb-866f-2be055d3194c&v=b4791732-ba57-4a05-8db1-fb6330a7df34&r=d0581501-d6c6-449f-8761-c60046fa9db8'>点我查看“划水看板”，用于记录当前博客划水状态，催更可以直接fa邮件哒，看到上面👆邮件小图标了吗✉️</a><p style='color:red;font-weight:bold;'>本博客封面图可能来源于网络，无商用，侵删</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">前置知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ticker"><span class="toc-number">2.</span> <span class="toc-text">ticker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">带着问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Start-Stop-Reset"><span class="toc-number">2.3.</span> <span class="toc-text">Start Stop Reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tick-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">Tick 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go1-13-%E7%9A%84-Timer"><span class="toc-number">3.</span> <span class="toc-text">go1.13 的 Timer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#startTimer"><span class="toc-number">3.1.</span> <span class="toc-text">startTimer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stopTimer"><span class="toc-number">3.2.</span> <span class="toc-text">stopTimer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">何时触发？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go1-17-%E7%9A%84-Timer"><span class="toc-number">4.</span> <span class="toc-text">go1.17 的 Timer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addtimer"><span class="toc-number">4.1.</span> <span class="toc-text">addtimer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deltimer"><span class="toc-number">4.2.</span> <span class="toc-text">deltimer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%9F-1"><span class="toc-number">4.3.</span> <span class="toc-text">何时触发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runtimer"><span class="toc-number">4.4.</span> <span class="toc-text">runtimer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#moveTimer"><span class="toc-number">4.5.</span> <span class="toc-text">moveTimer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94"><span class="toc-number">5.</span> <span class="toc-text">版本对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%85%B3%E9%94%AE"><span class="toc-number">5.2.</span> <span class="toc-text">问题关键</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/efe08c85.html" title="go 中其实不复杂的 timer">go 中其实不复杂的 timer</a><time datetime="2021-10-10T16:00:00.000Z" title="发表于 2021-10-11 00:00:00">2021-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/122ec973.html" title="我怎么从来没见过 sync.Cond">我怎么从来没见过 sync.Cond</a><time datetime="2021-09-17T16:00:00.000Z" title="发表于 2021-09-18 00:00:00">2021-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/65c8999.html" title="golang 使用 rabbitmq 延迟队列">golang 使用 rabbitmq 延迟队列</a><time datetime="2021-09-10T16:00:00.000Z" title="发表于 2021-09-11 00:00:00">2021-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/47a7987b.html" title="K8S之CNI">K8S之CNI</a><time datetime="2021-08-23T16:00:00.000Z" title="发表于 2021-08-24 00:00:00">2021-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/43a15dd1.html" title="K8S之跨主机通信">K8S之跨主机通信</a><time datetime="2021-08-19T16:00:00.000Z" title="发表于 2021-08-20 00:00:00">2021-08-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/LinkinStars/image/img/background.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By LinkinStar</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/LinkinStars/linkinstars.github.io"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a><br><a href="https://beian.miit.gov.cn/" target="_blank">浙B2-20080101</a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'fb1c6a994a1f26c2655e',
      clientSecret: '512d1338f3c8e48f1be73caf0661c005bf1c0425',
      repo: 'linkinstars.github.io',
      owner: 'LinkinStars',
      admin: ['LinkinStars'],
      id: 'fd99f97c814814efe53b0ca464498c9c',
      language: 'zh-CN',
      perPage: 50,
      distractionFreeMode: true,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer src="/live2d-widget/autoload.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>